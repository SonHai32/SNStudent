{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nconst Resolver = require(\"./Resolver\");\n\nconst SyncAsyncFileSystemDecorator = require(\"./SyncAsyncFileSystemDecorator\");\n\nconst ParsePlugin = require(\"./ParsePlugin\");\n\nconst DescriptionFilePlugin = require(\"./DescriptionFilePlugin\");\n\nconst NextPlugin = require(\"./NextPlugin\");\n\nconst TryNextPlugin = require(\"./TryNextPlugin\");\n\nconst ModuleKindPlugin = require(\"./ModuleKindPlugin\");\n\nconst FileKindPlugin = require(\"./FileKindPlugin\");\n\nconst JoinRequestPlugin = require(\"./JoinRequestPlugin\");\n\nconst ModulesInHierachicDirectoriesPlugin = require(\"./ModulesInHierachicDirectoriesPlugin\");\n\nconst ModulesInRootPlugin = require(\"./ModulesInRootPlugin\");\n\nconst AliasPlugin = require(\"./AliasPlugin\");\n\nconst AliasFieldPlugin = require(\"./AliasFieldPlugin\");\n\nconst ConcordExtensionsPlugin = require(\"./ConcordExtensionsPlugin\");\n\nconst ConcordMainPlugin = require(\"./ConcordMainPlugin\");\n\nconst ConcordModulesPlugin = require(\"./ConcordModulesPlugin\");\n\nconst DirectoryExistsPlugin = require(\"./DirectoryExistsPlugin\");\n\nconst FileExistsPlugin = require(\"./FileExistsPlugin\");\n\nconst SymlinkPlugin = require(\"./SymlinkPlugin\");\n\nconst MainFieldPlugin = require(\"./MainFieldPlugin\");\n\nconst UseFilePlugin = require(\"./UseFilePlugin\");\n\nconst AppendPlugin = require(\"./AppendPlugin\");\n\nconst ResultPlugin = require(\"./ResultPlugin\");\n\nconst ModuleAppendPlugin = require(\"./ModuleAppendPlugin\");\n\nconst UnsafeCachePlugin = require(\"./UnsafeCachePlugin\");\n\nexports.createResolver = function (options) {\n  //// OPTIONS ////\n  // A list of directories to resolve modules from, can be absolute path or folder name\n  let modules = options.modules || [\"node_modules\"]; // A list of description files to read from\n\n  const descriptionFiles = options.descriptionFiles || [\"package.json\"]; // A list of additional resolve plugins which should be applied\n  // The slice is there to create a copy, because otherwise pushing into plugins\n  // changes the original options.plugins array, causing duplicate plugins\n\n  const plugins = options.plugins && options.plugins.slice() || []; // A list of main fields in description files\n\n  let mainFields = options.mainFields || [\"main\"]; // A list of alias fields in description files\n\n  const aliasFields = options.aliasFields || []; // A list of main files in directories\n\n  const mainFiles = options.mainFiles || [\"index\"]; // A list of extensions which should be tried for files\n\n  let extensions = options.extensions || [\".js\", \".json\", \".node\"]; // Enforce that a extension from extensions must be used\n\n  const enforceExtension = options.enforceExtension || false; // A list of module extensions which should be tried for modules\n\n  let moduleExtensions = options.moduleExtensions || []; // Enforce that a extension from moduleExtensions must be used\n\n  const enforceModuleExtension = options.enforceModuleExtension || false; // A list of module alias configurations or an object which maps key to value\n\n  let alias = options.alias || []; // Resolve symlinks to their symlinked location\n\n  const symlinks = typeof options.symlinks !== \"undefined\" ? options.symlinks : true; // Resolve to a context instead of a file\n\n  const resolveToContext = options.resolveToContext || false; // Use this cache object to unsafely cache the successful requests\n\n  let unsafeCache = options.unsafeCache || false; // Whether or not the unsafeCache should include request context as part of the cache key.\n\n  const cacheWithContext = typeof options.cacheWithContext !== \"undefined\" ? options.cacheWithContext : true; // Enable concord description file instructions\n\n  const enableConcord = options.concord || false; // A function which decides whether a request should be cached or not.\n  // an object is passed with `path` and `request` properties.\n\n  const cachePredicate = options.cachePredicate || function () {\n    return true;\n  }; // The file system which should be used\n\n\n  const fileSystem = options.fileSystem; // Use only the sync constiants of the file system calls\n\n  const useSyncFileSystemCalls = options.useSyncFileSystemCalls; // A prepared Resolver to which the plugins are attached\n\n  let resolver = options.resolver; //// options processing ////\n\n  if (!resolver) {\n    resolver = new Resolver(useSyncFileSystemCalls ? new SyncAsyncFileSystemDecorator(fileSystem) : fileSystem);\n  }\n\n  extensions = [].concat(extensions);\n  moduleExtensions = [].concat(moduleExtensions);\n  modules = mergeFilteredToArray([].concat(modules), item => {\n    return !isAbsolutePath(item);\n  });\n  mainFields = mainFields.map(item => {\n    if (typeof item === \"string\" || Array.isArray(item)) {\n      item = {\n        name: item,\n        forceRelative: true\n      };\n    }\n\n    return item;\n  });\n\n  if (typeof alias === \"object\" && !Array.isArray(alias)) {\n    alias = Object.keys(alias).map(key => {\n      let onlyModule = false;\n      let obj = alias[key];\n\n      if (/\\$$/.test(key)) {\n        onlyModule = true;\n        key = key.substr(0, key.length - 1);\n      }\n\n      if (typeof obj === \"string\") {\n        obj = {\n          alias: obj\n        };\n      }\n\n      obj = Object.assign({\n        name: key,\n        onlyModule: onlyModule\n      }, obj);\n      return obj;\n    });\n  }\n\n  if (unsafeCache && typeof unsafeCache !== \"object\") {\n    unsafeCache = {};\n  } //// pipeline ////\n\n\n  resolver.ensureHook(\"resolve\");\n  resolver.ensureHook(\"parsedResolve\");\n  resolver.ensureHook(\"describedResolve\");\n  resolver.ensureHook(\"rawModule\");\n  resolver.ensureHook(\"module\");\n  resolver.ensureHook(\"relative\");\n  resolver.ensureHook(\"describedRelative\");\n  resolver.ensureHook(\"directory\");\n  resolver.ensureHook(\"existingDirectory\");\n  resolver.ensureHook(\"undescribedRawFile\");\n  resolver.ensureHook(\"rawFile\");\n  resolver.ensureHook(\"file\");\n  resolver.ensureHook(\"existingFile\");\n  resolver.ensureHook(\"resolved\"); // resolve\n\n  if (unsafeCache) {\n    plugins.push(new UnsafeCachePlugin(\"resolve\", cachePredicate, unsafeCache, cacheWithContext, \"new-resolve\"));\n    plugins.push(new ParsePlugin(\"new-resolve\", \"parsed-resolve\"));\n  } else {\n    plugins.push(new ParsePlugin(\"resolve\", \"parsed-resolve\"));\n  } // parsed-resolve\n\n\n  plugins.push(new DescriptionFilePlugin(\"parsed-resolve\", descriptionFiles, \"described-resolve\"));\n  plugins.push(new NextPlugin(\"after-parsed-resolve\", \"described-resolve\")); // described-resolve\n\n  if (alias.length > 0) plugins.push(new AliasPlugin(\"described-resolve\", alias, \"resolve\"));\n\n  if (enableConcord) {\n    plugins.push(new ConcordModulesPlugin(\"described-resolve\", {}, \"resolve\"));\n  }\n\n  aliasFields.forEach(item => {\n    plugins.push(new AliasFieldPlugin(\"described-resolve\", item, \"resolve\"));\n  });\n  plugins.push(new ModuleKindPlugin(\"after-described-resolve\", \"raw-module\"));\n  plugins.push(new JoinRequestPlugin(\"after-described-resolve\", \"relative\")); // raw-module\n\n  moduleExtensions.forEach(item => {\n    plugins.push(new ModuleAppendPlugin(\"raw-module\", item, \"module\"));\n  });\n  if (!enforceModuleExtension) plugins.push(new TryNextPlugin(\"raw-module\", null, \"module\")); // module\n\n  modules.forEach(item => {\n    if (Array.isArray(item)) plugins.push(new ModulesInHierachicDirectoriesPlugin(\"module\", item, \"resolve\"));else plugins.push(new ModulesInRootPlugin(\"module\", item, \"resolve\"));\n  }); // relative\n\n  plugins.push(new DescriptionFilePlugin(\"relative\", descriptionFiles, \"described-relative\"));\n  plugins.push(new NextPlugin(\"after-relative\", \"described-relative\")); // described-relative\n\n  plugins.push(new FileKindPlugin(\"described-relative\", \"raw-file\"));\n  plugins.push(new TryNextPlugin(\"described-relative\", \"as directory\", \"directory\")); // directory\n\n  plugins.push(new DirectoryExistsPlugin(\"directory\", \"existing-directory\"));\n\n  if (resolveToContext) {\n    // existing-directory\n    plugins.push(new NextPlugin(\"existing-directory\", \"resolved\"));\n  } else {\n    // existing-directory\n    if (enableConcord) {\n      plugins.push(new ConcordMainPlugin(\"existing-directory\", {}, \"resolve\"));\n    }\n\n    mainFields.forEach(item => {\n      plugins.push(new MainFieldPlugin(\"existing-directory\", item, \"resolve\"));\n    });\n    mainFiles.forEach(item => {\n      plugins.push(new UseFilePlugin(\"existing-directory\", item, \"undescribed-raw-file\"));\n    }); // undescribed-raw-file\n\n    plugins.push(new DescriptionFilePlugin(\"undescribed-raw-file\", descriptionFiles, \"raw-file\"));\n    plugins.push(new NextPlugin(\"after-undescribed-raw-file\", \"raw-file\")); // raw-file\n\n    if (!enforceExtension) {\n      plugins.push(new TryNextPlugin(\"raw-file\", \"no extension\", \"file\"));\n    }\n\n    if (enableConcord) {\n      plugins.push(new ConcordExtensionsPlugin(\"raw-file\", {}, \"file\"));\n    }\n\n    extensions.forEach(item => {\n      plugins.push(new AppendPlugin(\"raw-file\", item, \"file\"));\n    }); // file\n\n    if (alias.length > 0) plugins.push(new AliasPlugin(\"file\", alias, \"resolve\"));\n\n    if (enableConcord) {\n      plugins.push(new ConcordModulesPlugin(\"file\", {}, \"resolve\"));\n    }\n\n    aliasFields.forEach(item => {\n      plugins.push(new AliasFieldPlugin(\"file\", item, \"resolve\"));\n    });\n    if (symlinks) plugins.push(new SymlinkPlugin(\"file\", \"relative\"));\n    plugins.push(new FileExistsPlugin(\"file\", \"existing-file\")); // existing-file\n\n    plugins.push(new NextPlugin(\"existing-file\", \"resolved\"));\n  } // resolved\n\n\n  plugins.push(new ResultPlugin(resolver.hooks.resolved)); //// RESOLVER ////\n\n  plugins.forEach(plugin => {\n    plugin.apply(resolver);\n  });\n  return resolver;\n};\n\nfunction mergeFilteredToArray(array, filter) {\n  return array.reduce((array, item) => {\n    if (filter(item)) {\n      const lastElement = array[array.length - 1];\n\n      if (Array.isArray(lastElement)) {\n        lastElement.push(item);\n      } else {\n        array.push([item]);\n      }\n\n      return array;\n    } else {\n      array.push(item);\n      return array;\n    }\n  }, []);\n}\n\nfunction isAbsolutePath(path) {\n  return /^[A-Z]:|^\\//.test(path);\n}","map":null,"metadata":{},"sourceType":"script"}