{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ModuleTemplate\")} ModuleTemplate */\n\n/** @typedef {import(\"webpack-sources\").ConcatSource} ConcatSource */\nconst _require = require(\"webpack-sources\"),\n      ConcatSource = _require.ConcatSource;\n\nconst HotUpdateChunk = require(\"./HotUpdateChunk\");\n\nconst START_LOWERCASE_ALPHABET_CODE = \"a\".charCodeAt(0);\nconst START_UPPERCASE_ALPHABET_CODE = \"A\".charCodeAt(0);\nconst DELTA_A_TO_Z = \"z\".charCodeAt(0) - START_LOWERCASE_ALPHABET_CODE + 1;\nconst FUNCTION_CONTENT_REGEX = /^function\\s?\\(\\)\\s?\\{\\r?\\n?|\\r?\\n?\\}$/g;\nconst INDENT_MULTILINE_REGEX = /^\\t/gm;\nconst LINE_SEPARATOR_REGEX = /\\r?\\n/g;\nconst IDENTIFIER_NAME_REPLACE_REGEX = /^([^a-zA-Z$_])/;\nconst IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX = /[^a-zA-Z0-9$]+/g;\nconst COMMENT_END_REGEX = /\\*\\//g;\nconst PATH_NAME_NORMALIZE_REPLACE_REGEX = /[^a-zA-Z0-9_!§$()=\\-^°]+/g;\nconst MATCH_PADDED_HYPHENS_REPLACE_REGEX = /^-|-$/g;\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/**\n * @typedef {Object} HasId\n * @property {number | string} id\n */\n\n/**\n * @typedef {function(Module, number): boolean} ModuleFilterPredicate\n */\n\n/**\n * @param {HasId} a first id object to be sorted\n * @param {HasId} b second id object to be sorted against\n * @returns {-1|0|1} the sort value\n */\n\nconst stringifyIdSortPredicate = (a, b) => {\n  const aId = a.id + \"\";\n  const bId = b.id + \"\";\n  if (aId < bId) return -1;\n  if (aId > bId) return 1;\n  return 0;\n};\n\nclass Template {\n  /**\n   *\n   * @param {Function} fn a runtime function (.runtime.js) \"template\"\n   * @returns {string} the updated and normalized function string\n   */\n  static getFunctionContent(fn) {\n    return fn.toString().replace(FUNCTION_CONTENT_REGEX, \"\").replace(INDENT_MULTILINE_REGEX, \"\").replace(LINE_SEPARATOR_REGEX, \"\\n\");\n  }\n  /**\n   * @param {string} str the string converted to identifier\n   * @returns {string} created identifier\n   */\n\n\n  static toIdentifier(str) {\n    if (typeof str !== \"string\") return \"\";\n    return str.replace(IDENTIFIER_NAME_REPLACE_REGEX, \"_$1\").replace(IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX, \"_\");\n  }\n  /**\n   *\n   * @param {string} str string to be converted to commented in bundle code\n   * @returns {string} returns a commented version of string\n   */\n\n\n  static toComment(str) {\n    if (!str) return \"\";\n    return \"/*! \".concat(str.replace(COMMENT_END_REGEX, \"* /\"), \" */\");\n  }\n  /**\n   *\n   * @param {string} str string to be converted to \"normal comment\"\n   * @returns {string} returns a commented version of string\n   */\n\n\n  static toNormalComment(str) {\n    if (!str) return \"\";\n    return \"/* \".concat(str.replace(COMMENT_END_REGEX, \"* /\"), \" */\");\n  }\n  /**\n   * @param {string} str string path to be normalized\n   * @returns {string} normalized bundle-safe path\n   */\n\n\n  static toPath(str) {\n    if (typeof str !== \"string\") return \"\";\n    return str.replace(PATH_NAME_NORMALIZE_REPLACE_REGEX, \"-\").replace(MATCH_PADDED_HYPHENS_REPLACE_REGEX, \"\");\n  } // map number to a single character a-z, A-Z or <_ + number> if number is too big\n\n  /**\n   *\n   * @param {number} n number to convert to ident\n   * @returns {string} returns single character ident\n   */\n\n\n  static numberToIdentifer(n) {\n    // lower case\n    if (n < DELTA_A_TO_Z) {\n      return String.fromCharCode(START_LOWERCASE_ALPHABET_CODE + n);\n    } // upper case\n\n\n    if (n < DELTA_A_TO_Z * 2) {\n      return String.fromCharCode(START_UPPERCASE_ALPHABET_CODE + n - DELTA_A_TO_Z);\n    } // use multiple letters\n\n\n    return Template.numberToIdentifer(n % (2 * DELTA_A_TO_Z)) + Template.numberToIdentifer(Math.floor(n / (2 * DELTA_A_TO_Z)));\n  }\n  /**\n   *\n   * @param {string | string[]} s string to convert to identity\n   * @returns {string} converted identity\n   */\n\n\n  static indent(s) {\n    if (Array.isArray(s)) {\n      return s.map(Template.indent).join(\"\\n\");\n    } else {\n      const str = s.trimRight();\n      if (!str) return \"\";\n      const ind = str[0] === \"\\n\" ? \"\" : \"\\t\";\n      return ind + str.replace(/\\n([^\\n])/g, \"\\n\\t$1\");\n    }\n  }\n  /**\n   *\n   * @param {string|string[]} s string to create prefix for\n   * @param {string} prefix prefix to compose\n   * @returns {string} returns new prefix string\n   */\n\n\n  static prefix(s, prefix) {\n    const str = Template.asString(s).trim();\n    if (!str) return \"\";\n    const ind = str[0] === \"\\n\" ? \"\" : prefix;\n    return ind + str.replace(/\\n([^\\n])/g, \"\\n\" + prefix + \"$1\");\n  }\n  /**\n   *\n   * @param {string|string[]} str string or string collection\n   * @returns {string} returns a single string from array\n   */\n\n\n  static asString(str) {\n    if (Array.isArray(str)) {\n      return str.join(\"\\n\");\n    }\n\n    return str;\n  }\n  /**\n   * @typedef {Object} WithId\n   * @property {string|number} id\n   */\n\n  /**\n   * @param {WithId[]} modules a collection of modules to get array bounds for\n   * @returns {[number, number] | false} returns the upper and lower array bounds\n   * or false if not every module has a number based id\n   */\n\n\n  static getModulesArrayBounds(modules) {\n    let maxId = -Infinity;\n    let minId = Infinity;\n\n    for (const module of modules) {\n      if (typeof module.id !== \"number\") return false;\n      if (maxId < module.id) maxId =\n      /** @type {number} */\n      module.id;\n      if (minId > module.id) minId =\n      /** @type {number} */\n      module.id;\n    }\n\n    if (minId < 16 + (\"\" + minId).length) {\n      // add minId x ',' instead of 'Array(minId).concat(…)'\n      minId = 0;\n    }\n\n    const objectOverhead = modules.map(module => (module.id + \"\").length + 2).reduce((a, b) => a + b, -1);\n    const arrayOverhead = minId === 0 ? maxId : 16 + (\"\" + minId).length + maxId;\n    return arrayOverhead < objectOverhead ? [minId, maxId] : false;\n  }\n  /**\n   * @param {Chunk} chunk chunk whose modules will be rendered\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules from chunk to render\n   * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance used to render modules\n   * @param {TODO | TODO[]} dependencyTemplates templates needed for each module to render dependencies\n   * @param {string=} prefix applying prefix strings\n   * @returns {ConcatSource} rendered chunk modules in a Source object\n   */\n\n\n  static renderChunkModules(chunk, filterFn, moduleTemplate, dependencyTemplates, prefix = \"\") {\n    const source = new ConcatSource();\n    const modules = chunk.getModules().filter(filterFn);\n    let removedModules;\n\n    if (chunk instanceof HotUpdateChunk) {\n      removedModules = chunk.removedModules;\n    }\n\n    if (modules.length === 0 && (!removedModules || removedModules.length === 0)) {\n      source.add(\"[]\");\n      return source;\n    }\n    /** @type {{id: string|number, source: Source|string}[]} */\n\n\n    const allModules = modules.map(module => {\n      return {\n        id: module.id,\n        source: moduleTemplate.render(module, dependencyTemplates, {\n          chunk\n        })\n      };\n    });\n\n    if (removedModules && removedModules.length > 0) {\n      for (const id of removedModules) {\n        allModules.push({\n          id,\n          source: \"false\"\n        });\n      }\n    }\n\n    const bounds = Template.getModulesArrayBounds(allModules);\n\n    if (bounds) {\n      // Render a spare array\n      const minId = bounds[0];\n      const maxId = bounds[1];\n\n      if (minId !== 0) {\n        source.add(\"Array(\".concat(minId, \").concat(\"));\n      }\n\n      source.add(\"[\\n\");\n      /** @type {Map<string|number, {id: string|number, source: Source|string}>} */\n\n      const modules = new Map();\n\n      for (const module of allModules) {\n        modules.set(module.id, module);\n      }\n\n      for (let idx = minId; idx <= maxId; idx++) {\n        const module = modules.get(idx);\n\n        if (idx !== minId) {\n          source.add(\",\\n\");\n        }\n\n        source.add(\"/* \".concat(idx, \" */\"));\n\n        if (module) {\n          source.add(\"\\n\");\n          source.add(module.source);\n        }\n      }\n\n      source.add(\"\\n\" + prefix + \"]\");\n\n      if (minId !== 0) {\n        source.add(\")\");\n      }\n    } else {\n      // Render an object\n      source.add(\"{\\n\");\n      allModules.sort(stringifyIdSortPredicate).forEach((module, idx) => {\n        if (idx !== 0) {\n          source.add(\",\\n\");\n        }\n\n        source.add(\"\\n/***/ \".concat(JSON.stringify(module.id), \":\\n\"));\n        source.add(module.source);\n      });\n      source.add(\"\\n\\n\".concat(prefix, \"}\"));\n    }\n\n    return source;\n  }\n\n}\n\nmodule.exports = Template;","map":null,"metadata":{},"sourceType":"script"}