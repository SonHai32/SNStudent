{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\n\nconst ModuleHotAcceptDependency = require(\"../dependencies/ModuleHotAcceptDependency\");\n\nconst ModuleHotDeclineDependency = require(\"../dependencies/ModuleHotDeclineDependency\");\n\nconst ConcatenatedModule = require(\"./ConcatenatedModule\");\n\nconst HarmonyCompatibilityDependency = require(\"../dependencies/HarmonyCompatibilityDependency\");\n\nconst StackedSetMap = require(\"../util/StackedSetMap\");\n\nconst formatBailoutReason = msg => {\n  return \"ModuleConcatenation bailout: \" + msg;\n};\n\nclass ModuleConcatenationPlugin {\n  constructor(options) {\n    if (typeof options !== \"object\") options = {};\n    this.options = options;\n  }\n\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"ModuleConcatenationPlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      const handler = (parser, parserOptions) => {\n        parser.hooks.call.for(\"eval\").tap(\"ModuleConcatenationPlugin\", () => {\n          // Because of variable renaming we can't use modules with eval.\n          parser.state.module.buildMeta.moduleConcatenationBailout = \"eval()\";\n        });\n      };\n\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"ModuleConcatenationPlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"ModuleConcatenationPlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"ModuleConcatenationPlugin\", handler);\n      const bailoutReasonMap = new Map();\n\n      const setBailoutReason = (module, reason) => {\n        bailoutReasonMap.set(module, reason);\n        module.optimizationBailout.push(typeof reason === \"function\" ? rs => formatBailoutReason(reason(rs)) : formatBailoutReason(reason));\n      };\n\n      const getBailoutReason = (module, requestShortener) => {\n        const reason = bailoutReasonMap.get(module);\n        if (typeof reason === \"function\") return reason(requestShortener);\n        return reason;\n      };\n\n      compilation.hooks.optimizeChunkModules.tap(\"ModuleConcatenationPlugin\", (allChunks, modules) => {\n        const relevantModules = [];\n        const possibleInners = new Set();\n\n        for (const module of modules) {\n          // Only harmony modules are valid for optimization\n          if (!module.buildMeta || module.buildMeta.exportsType !== \"namespace\" || !module.dependencies.some(d => d instanceof HarmonyCompatibilityDependency)) {\n            setBailoutReason(module, \"Module is not an ECMAScript module\");\n            continue;\n          } // Some expressions are not compatible with module concatenation\n          // because they may produce unexpected results. The plugin bails out\n          // if some were detected upfront.\n\n\n          if (module.buildMeta && module.buildMeta.moduleConcatenationBailout) {\n            setBailoutReason(module, \"Module uses \".concat(module.buildMeta.moduleConcatenationBailout));\n            continue;\n          } // Exports must be known (and not dynamic)\n\n\n          if (!Array.isArray(module.buildMeta.providedExports)) {\n            setBailoutReason(module, \"Module exports are unknown\");\n            continue;\n          } // Using dependency variables is not possible as this wraps the code in a function\n\n\n          if (module.variables.length > 0) {\n            setBailoutReason(module, \"Module uses injected variables (\".concat(module.variables.map(v => v.name).join(\", \"), \")\"));\n            continue;\n          } // Hot Module Replacement need it's own module to work correctly\n\n\n          if (module.dependencies.some(dep => dep instanceof ModuleHotAcceptDependency || dep instanceof ModuleHotDeclineDependency)) {\n            setBailoutReason(module, \"Module uses Hot Module Replacement\");\n            continue;\n          }\n\n          relevantModules.push(module); // Module must not be the entry points\n\n          if (module.isEntryModule()) {\n            setBailoutReason(module, \"Module is an entry point\");\n            continue;\n          } // Module must be in any chunk (we don't want to do useless work)\n\n\n          if (module.getNumberOfChunks() === 0) {\n            setBailoutReason(module, \"Module is not in any chunk\");\n            continue;\n          } // Module must only be used by Harmony Imports\n\n\n          const nonHarmonyReasons = module.reasons.filter(reason => !reason.dependency || !(reason.dependency instanceof HarmonyImportDependency));\n\n          if (nonHarmonyReasons.length > 0) {\n            const importingModules = new Set(nonHarmonyReasons.map(r => r.module).filter(Boolean));\n            const importingExplanations = new Set(nonHarmonyReasons.map(r => r.explanation).filter(Boolean));\n            const importingModuleTypes = new Map(Array.from(importingModules).map(m =>\n            /** @type {[string, Set]} */\n            [m, new Set(nonHarmonyReasons.filter(r => r.module === m).map(r => r.dependency.type).sort())]));\n            setBailoutReason(module, requestShortener => {\n              const names = Array.from(importingModules).map(m => \"\".concat(m.readableIdentifier(requestShortener), \" (referenced with \").concat(Array.from(importingModuleTypes.get(m)).join(\", \"), \")\")).sort();\n              const explanations = Array.from(importingExplanations).sort();\n\n              if (names.length > 0 && explanations.length === 0) {\n                return \"Module is referenced from these modules with unsupported syntax: \".concat(names.join(\", \"));\n              } else if (names.length === 0 && explanations.length > 0) {\n                return \"Module is referenced by: \".concat(explanations.join(\", \"));\n              } else if (names.length > 0 && explanations.length > 0) {\n                return \"Module is referenced from these modules with unsupported syntax: \".concat(names.join(\", \"), \" and by: \").concat(explanations.join(\", \"));\n              } else {\n                return \"Module is referenced in a unsupported way\";\n              }\n            });\n            continue;\n          }\n\n          possibleInners.add(module);\n        } // sort by depth\n        // modules with lower depth are more likely suited as roots\n        // this improves performance, because modules already selected as inner are skipped\n\n\n        relevantModules.sort((a, b) => {\n          return a.depth - b.depth;\n        });\n        const concatConfigurations = [];\n        const usedAsInner = new Set();\n\n        for (const currentRoot of relevantModules) {\n          // when used by another configuration as inner:\n          // the other configuration is better and we can skip this one\n          if (usedAsInner.has(currentRoot)) continue; // create a configuration with the root\n\n          const currentConfiguration = new ConcatConfiguration(currentRoot); // cache failures to add modules\n\n          const failureCache = new Map(); // try to add all imports\n\n          for (const imp of this._getImports(compilation, currentRoot)) {\n            const problem = this._tryToAdd(compilation, currentConfiguration, imp, possibleInners, failureCache);\n\n            if (problem) {\n              failureCache.set(imp, problem);\n              currentConfiguration.addWarning(imp, problem);\n            }\n          }\n\n          if (!currentConfiguration.isEmpty()) {\n            concatConfigurations.push(currentConfiguration);\n\n            for (const module of currentConfiguration.getModules()) {\n              if (module !== currentConfiguration.rootModule) {\n                usedAsInner.add(module);\n              }\n            }\n          }\n        } // HACK: Sort configurations by length and start with the longest one\n        // to get the biggers groups possible. Used modules are marked with usedModules\n        // TODO: Allow to reuse existing configuration while trying to add dependencies.\n        // This would improve performance. O(n^2) -> O(n)\n\n\n        concatConfigurations.sort((a, b) => {\n          return b.modules.size - a.modules.size;\n        });\n        const usedModules = new Set();\n\n        for (const concatConfiguration of concatConfigurations) {\n          if (usedModules.has(concatConfiguration.rootModule)) continue;\n          const modules = concatConfiguration.getModules();\n          const rootModule = concatConfiguration.rootModule;\n          const newModule = new ConcatenatedModule(rootModule, Array.from(modules), ConcatenatedModule.createConcatenationList(rootModule, modules, compilation));\n\n          for (const warning of concatConfiguration.getWarningsSorted()) {\n            newModule.optimizationBailout.push(requestShortener => {\n              const reason = getBailoutReason(warning[0], requestShortener);\n              const reasonWithPrefix = reason ? \" (<- \".concat(reason, \")\") : \"\";\n\n              if (warning[0] === warning[1]) {\n                return formatBailoutReason(\"Cannot concat with \".concat(warning[0].readableIdentifier(requestShortener)).concat(reasonWithPrefix));\n              } else {\n                return formatBailoutReason(\"Cannot concat with \".concat(warning[0].readableIdentifier(requestShortener), \" because of \").concat(warning[1].readableIdentifier(requestShortener)).concat(reasonWithPrefix));\n              }\n            });\n          }\n\n          const chunks = concatConfiguration.rootModule.getChunks();\n\n          for (const m of modules) {\n            usedModules.add(m);\n\n            for (const chunk of chunks) {\n              chunk.removeModule(m);\n            }\n          }\n\n          for (const chunk of chunks) {\n            chunk.addModule(newModule);\n            newModule.addChunk(chunk);\n          }\n\n          for (const chunk of allChunks) {\n            if (chunk.entryModule === concatConfiguration.rootModule) {\n              chunk.entryModule = newModule;\n            }\n          }\n\n          compilation.modules.push(newModule);\n\n          for (const reason of newModule.reasons) {\n            if (reason.dependency.module === concatConfiguration.rootModule) reason.dependency.module = newModule;\n            if (reason.dependency.redirectedModule === concatConfiguration.rootModule) reason.dependency.redirectedModule = newModule;\n          } // TODO: remove when LTS node version contains fixed v8 version\n          // @see https://github.com/webpack/webpack/pull/6613\n          // Turbofan does not correctly inline for-of loops with polymorphic input arrays.\n          // Work around issue by using a standard for loop and assigning dep.module.reasons\n\n\n          for (let i = 0; i < newModule.dependencies.length; i++) {\n            let dep = newModule.dependencies[i];\n\n            if (dep.module) {\n              let reasons = dep.module.reasons;\n\n              for (let j = 0; j < reasons.length; j++) {\n                let reason = reasons[j];\n\n                if (reason.dependency === dep) {\n                  reason.module = newModule;\n                }\n              }\n            }\n          }\n        }\n\n        compilation.modules = compilation.modules.filter(m => !usedModules.has(m));\n      });\n    });\n  }\n\n  _getImports(compilation, module) {\n    return new Set(module.dependencies // Get reference info only for harmony Dependencies\n    .map(dep => {\n      if (!(dep instanceof HarmonyImportDependency)) return null;\n      if (!compilation) return dep.getReference();\n      return compilation.getDependencyReference(module, dep);\n    }) // Reference is valid and has a module\n    // Dependencies are simple enough to concat them\n    .filter(ref => ref && ref.module && (Array.isArray(ref.importedNames) || Array.isArray(ref.module.buildMeta.providedExports))) // Take the imported module\n    .map(ref => ref.module));\n  }\n\n  _tryToAdd(compilation, config, module, possibleModules, failureCache) {\n    const cacheEntry = failureCache.get(module);\n\n    if (cacheEntry) {\n      return cacheEntry;\n    } // Already added?\n\n\n    if (config.has(module)) {\n      return null;\n    } // Not possible to add?\n\n\n    if (!possibleModules.has(module)) {\n      failureCache.set(module, module); // cache failures for performance\n\n      return module;\n    } // module must be in the same chunks\n\n\n    if (!config.rootModule.hasEqualsChunks(module)) {\n      failureCache.set(module, module); // cache failures for performance\n\n      return module;\n    } // Clone config to make experimental changes\n\n\n    const testConfig = config.clone(); // Add the module\n\n    testConfig.add(module); // Every module which depends on the added module must be in the configuration too.\n\n    for (const reason of module.reasons) {\n      // Modules that are not used can be ignored\n      if (reason.module.factoryMeta.sideEffectFree && reason.module.used === false) continue;\n\n      const problem = this._tryToAdd(compilation, testConfig, reason.module, possibleModules, failureCache);\n\n      if (problem) {\n        failureCache.set(module, problem); // cache failures for performance\n\n        return problem;\n      }\n    } // Commit experimental changes\n\n\n    config.set(testConfig); // Eagerly try to add imports too if possible\n\n    for (const imp of this._getImports(compilation, module)) {\n      const problem = this._tryToAdd(compilation, config, imp, possibleModules, failureCache);\n\n      if (problem) {\n        config.addWarning(imp, problem);\n      }\n    }\n\n    return null;\n  }\n\n}\n\nclass ConcatConfiguration {\n  constructor(rootModule, cloneFrom) {\n    this.rootModule = rootModule;\n\n    if (cloneFrom) {\n      this.modules = cloneFrom.modules.createChild(5);\n      this.warnings = cloneFrom.warnings.createChild(5);\n    } else {\n      this.modules = new StackedSetMap();\n      this.modules.add(rootModule);\n      this.warnings = new StackedSetMap();\n    }\n  }\n\n  add(module) {\n    this.modules.add(module);\n  }\n\n  has(module) {\n    return this.modules.has(module);\n  }\n\n  isEmpty() {\n    return this.modules.size === 1;\n  }\n\n  addWarning(module, problem) {\n    this.warnings.set(module, problem);\n  }\n\n  getWarningsSorted() {\n    return new Map(this.warnings.asPairArray().sort((a, b) => {\n      const ai = a[0].identifier();\n      const bi = b[0].identifier();\n      if (ai < bi) return -1;\n      if (ai > bi) return 1;\n      return 0;\n    }));\n  }\n\n  getModules() {\n    return this.modules.asSet();\n  }\n\n  clone() {\n    return new ConcatConfiguration(this.rootModule, this);\n  }\n\n  set(config) {\n    this.rootModule = config.rootModule;\n    this.modules = config.modules;\n    this.warnings = config.warnings;\n  }\n\n}\n\nmodule.exports = ModuleConcatenationPlugin;","map":null,"metadata":{},"sourceType":"script"}