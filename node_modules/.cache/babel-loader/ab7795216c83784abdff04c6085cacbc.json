{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar Source = require(\"./Source\");\n\nvar SourceNode = require(\"source-map\").SourceNode;\n\nclass Replacement {\n  constructor(start, end, content, insertIndex, name) {\n    this.start = start;\n    this.end = end;\n    this.content = content;\n    this.insertIndex = insertIndex;\n    this.name = name;\n  }\n\n}\n\nclass ReplaceSource extends Source {\n  constructor(source, name) {\n    super();\n    this._source = source;\n    this._name = name;\n    /** @type {Replacement[]} */\n\n    this.replacements = [];\n  }\n\n  replace(start, end, newValue, name) {\n    if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue);\n    this.replacements.push(new Replacement(start, end, newValue, this.replacements.length, name));\n  }\n\n  insert(pos, newValue, name) {\n    if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue + \": \" + newValue);\n    this.replacements.push(new Replacement(pos, pos - 1, newValue, this.replacements.length, name));\n  }\n\n  source(options) {\n    return this._replaceString(this._source.source());\n  }\n\n  original() {\n    return this._source;\n  }\n\n  _sortReplacements() {\n    this.replacements.sort(function (a, b) {\n      var diff = b.end - a.end;\n      if (diff !== 0) return diff;\n      diff = b.start - a.start;\n      if (diff !== 0) return diff;\n      return b.insertIndex - a.insertIndex;\n    });\n  }\n\n  _replaceString(str) {\n    if (typeof str !== \"string\") throw new Error(\"str must be a string, but is a \" + typeof str + \": \" + str);\n\n    this._sortReplacements();\n\n    var result = [str];\n    this.replacements.forEach(function (repl) {\n      var remSource = result.pop();\n\n      var splitted1 = this._splitString(remSource, Math.floor(repl.end + 1));\n\n      var splitted2 = this._splitString(splitted1[0], Math.floor(repl.start));\n\n      result.push(splitted1[1], repl.content, splitted2[0]);\n    }, this); // write out result array in reverse order\n\n    let resultStr = \"\";\n\n    for (let i = result.length - 1; i >= 0; --i) {\n      resultStr += result[i];\n    }\n\n    return resultStr;\n  }\n\n  node(options) {\n    var node = this._source.node(options);\n\n    if (this.replacements.length === 0) {\n      return node;\n    }\n\n    this._sortReplacements();\n\n    var replace = new ReplacementEnumerator(this.replacements);\n    var output = [];\n    var position = 0;\n    var sources = Object.create(null);\n    var sourcesInLines = Object.create(null); // We build a new list of SourceNodes in \"output\"\n    // from the original mapping data\n\n    var result = new SourceNode(); // We need to add source contents manually\n    // because \"walk\" will not handle it\n\n    node.walkSourceContents(function (sourceFile, sourceContent) {\n      result.setSourceContent(sourceFile, sourceContent);\n      sources[\"$\" + sourceFile] = sourceContent;\n    });\n\n    var replaceInStringNode = this._replaceInStringNode.bind(this, output, replace, function getOriginalSource(mapping) {\n      var key = \"$\" + mapping.source;\n      var lines = sourcesInLines[key];\n\n      if (!lines) {\n        var source = sources[key];\n        if (!source) return null;\n        lines = source.split(\"\\n\").map(function (line) {\n          return line + \"\\n\";\n        });\n        sourcesInLines[key] = lines;\n      } // line is 1-based\n\n\n      if (mapping.line > lines.length) return null;\n      var line = lines[mapping.line - 1];\n      return line.substr(mapping.column);\n    });\n\n    node.walk(function (chunk, mapping) {\n      position = replaceInStringNode(chunk, position, mapping);\n    }); // If any replacements occur after the end of the original file, then we append them\n    // directly to the end of the output\n\n    var remaining = replace.footer();\n\n    if (remaining) {\n      output.push(remaining);\n    }\n\n    result.add(output);\n    return result;\n  }\n\n  listMap(options) {\n    this._sortReplacements();\n\n    var map = this._source.listMap(options);\n\n    var currentIndex = 0;\n    var replacements = this.replacements;\n    var idxReplacement = replacements.length - 1;\n    var removeChars = 0;\n    map = map.mapGeneratedCode(function (str) {\n      var newCurrentIndex = currentIndex + str.length;\n\n      if (removeChars > str.length) {\n        removeChars -= str.length;\n        str = \"\";\n      } else {\n        if (removeChars > 0) {\n          str = str.substr(removeChars);\n          currentIndex += removeChars;\n          removeChars = 0;\n        }\n\n        var finalStr = \"\";\n\n        while (idxReplacement >= 0 && replacements[idxReplacement].start < newCurrentIndex) {\n          var repl = replacements[idxReplacement];\n          var start = Math.floor(repl.start);\n          var end = Math.floor(repl.end + 1);\n          var before = str.substr(0, Math.max(0, start - currentIndex));\n\n          if (end <= newCurrentIndex) {\n            var after = str.substr(Math.max(0, end - currentIndex));\n            finalStr += before + repl.content;\n            str = after;\n            currentIndex = Math.max(currentIndex, end);\n          } else {\n            finalStr += before + repl.content;\n            str = \"\";\n            removeChars = end - newCurrentIndex;\n          }\n\n          idxReplacement--;\n        }\n\n        str = finalStr + str;\n      }\n\n      currentIndex = newCurrentIndex;\n      return str;\n    });\n    var extraCode = \"\";\n\n    while (idxReplacement >= 0) {\n      extraCode += replacements[idxReplacement].content;\n      idxReplacement--;\n    }\n\n    if (extraCode) {\n      map.add(extraCode);\n    }\n\n    return map;\n  }\n\n  _splitString(str, position) {\n    return position <= 0 ? [\"\", str] : [str.substr(0, position), str.substr(position)];\n  }\n\n  _replaceInStringNode(output, replace, getOriginalSource, node, position, mapping) {\n    var original = undefined;\n\n    do {\n      var splitPosition = replace.position - position; // If multiple replaces occur in the same location then the splitPosition may be\n      // before the current position for the subsequent splits. Ensure it is >= 0\n\n      if (splitPosition < 0) {\n        splitPosition = 0;\n      }\n\n      if (splitPosition >= node.length || replace.done) {\n        if (replace.emit) {\n          var nodeEnd = new SourceNode(mapping.line, mapping.column, mapping.source, node, mapping.name);\n          output.push(nodeEnd);\n        }\n\n        return position + node.length;\n      }\n\n      var originalColumn = mapping.column; // Try to figure out if generated code matches original code of this segement\n      // If this is the case we assume that it's allowed to move mapping.column\n      // Because getOriginalSource can be expensive we only do it when neccessary\n\n      var nodePart;\n\n      if (splitPosition > 0) {\n        nodePart = node.slice(0, splitPosition);\n\n        if (original === undefined) {\n          original = getOriginalSource(mapping);\n        }\n\n        if (original && original.length >= splitPosition && original.startsWith(nodePart)) {\n          mapping.column += splitPosition;\n          original = original.substr(splitPosition);\n        }\n      }\n\n      var emit = replace.next();\n\n      if (!emit) {\n        // Stop emitting when we have found the beginning of the string to replace.\n        // Emit the part of the string before splitPosition\n        if (splitPosition > 0) {\n          var nodeStart = new SourceNode(mapping.line, originalColumn, mapping.source, nodePart, mapping.name);\n          output.push(nodeStart);\n        } // Emit the replacement value\n\n\n        if (replace.value) {\n          output.push(new SourceNode(mapping.line, mapping.column, mapping.source, replace.value, mapping.name || replace.name));\n        }\n      } // Recurse with remainder of the string as there may be multiple replaces within a single node\n\n\n      node = node.substr(splitPosition);\n      position += splitPosition;\n    } while (true);\n  }\n\n}\n\nclass ReplacementEnumerator {\n  /**\n   * @param {Replacement[]} replacements list of replacements\n   */\n  constructor(replacements) {\n    this.replacements = replacements || [];\n    this.index = this.replacements.length;\n    this.done = false;\n    this.emit = false; // Set initial start position\n\n    this.next();\n  }\n\n  next() {\n    if (this.done) return true;\n\n    if (this.emit) {\n      // Start point found. stop emitting. set position to find end\n      var repl = this.replacements[this.index];\n      var end = Math.floor(repl.end + 1);\n      this.position = end;\n      this.value = repl.content;\n      this.name = repl.name;\n    } else {\n      // End point found. start emitting. set position to find next start\n      this.index--;\n\n      if (this.index < 0) {\n        this.done = true;\n      } else {\n        var nextRepl = this.replacements[this.index];\n        var start = Math.floor(nextRepl.start);\n        this.position = start;\n      }\n    }\n\n    if (this.position < 0) this.position = 0;\n    this.emit = !this.emit;\n    return this.emit;\n  }\n\n  footer() {\n    if (!this.done && !this.emit) this.next(); // If we finished _replaceInNode mid emit we advance to next entry\n\n    if (this.done) {\n      return [];\n    } else {\n      var resultStr = \"\";\n\n      for (var i = this.index; i >= 0; i--) {\n        var repl = this.replacements[i]; // this doesn't need to handle repl.name, because in SourceMaps generated code\n        // without pointer to original source can't have a name\n\n        resultStr += repl.content;\n      }\n\n      return resultStr;\n    }\n  }\n\n}\n\nrequire(\"./SourceAndMapMixin\")(ReplaceSource.prototype);\n\nmodule.exports = ReplaceSource;","map":null,"metadata":{},"sourceType":"script"}