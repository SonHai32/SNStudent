{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst NativeModule = require(\"module\");\n\nconst _require = require(\"webpack-sources\"),\n      CachedSource = _require.CachedSource,\n      LineToLineMappedSource = _require.LineToLineMappedSource,\n      OriginalSource = _require.OriginalSource,\n      RawSource = _require.RawSource,\n      SourceMapSource = _require.SourceMapSource;\n\nconst _require2 = require(\"loader-runner\"),\n      getContext = _require2.getContext,\n      runLoaders = _require2.runLoaders;\n\nconst WebpackError = require(\"./WebpackError\");\n\nconst Module = require(\"./Module\");\n\nconst ModuleParseError = require(\"./ModuleParseError\");\n\nconst ModuleBuildError = require(\"./ModuleBuildError\");\n\nconst ModuleError = require(\"./ModuleError\");\n\nconst ModuleWarning = require(\"./ModuleWarning\");\n\nconst createHash = require(\"./util/createHash\");\n\nconst contextify = require(\"./util/identifier\").contextify;\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n\nconst asString = buf => {\n  if (Buffer.isBuffer(buf)) {\n    return buf.toString(\"utf-8\");\n  }\n\n  return buf;\n};\n\nconst asBuffer = str => {\n  if (!Buffer.isBuffer(str)) {\n    return Buffer.from(str, \"utf-8\");\n  }\n\n  return str;\n};\n\nclass NonErrorEmittedError extends WebpackError {\n  constructor(error) {\n    super();\n    this.name = \"NonErrorEmittedError\";\n    this.message = \"(Emitted value instead of an instance of Error) \" + error;\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n}\n/**\n * @typedef {Object} CachedSourceEntry\n * @property {TODO} source the generated source\n * @property {string} hash the hash value\n */\n\n\nclass NormalModule extends Module {\n  constructor({\n    type,\n    request,\n    userRequest,\n    rawRequest,\n    loaders,\n    resource,\n    matchResource,\n    parser,\n    generator,\n    resolveOptions\n  }) {\n    super(type, getContext(resource)); // Info from Factory\n\n    this.request = request;\n    this.userRequest = userRequest;\n    this.rawRequest = rawRequest;\n    this.binary = type.startsWith(\"webassembly\");\n    this.parser = parser;\n    this.generator = generator;\n    this.resource = resource;\n    this.matchResource = matchResource;\n    this.loaders = loaders;\n    if (resolveOptions !== undefined) this.resolveOptions = resolveOptions; // Info from Build\n\n    this.error = null;\n    this._source = null;\n    this._buildHash = \"\";\n    this.buildTimestamp = undefined;\n    /** @private @type {Map<string, CachedSourceEntry>} */\n\n    this._cachedSources = new Map(); // Options for the NormalModule set by plugins\n    // TODO refactor this -> options object filled from Factory\n\n    this.useSourceMap = false;\n    this.lineToLine = false; // Cache\n\n    this._lastSuccessfulBuildMeta = {};\n  }\n\n  identifier() {\n    return this.request;\n  }\n\n  readableIdentifier(requestShortener) {\n    return requestShortener.shorten(this.userRequest);\n  }\n\n  libIdent(options) {\n    return contextify(options.context, this.userRequest);\n  }\n\n  nameForCondition() {\n    const resource = this.matchResource || this.resource;\n    const idx = resource.indexOf(\"?\");\n    if (idx >= 0) return resource.substr(0, idx);\n    return resource;\n  }\n\n  updateCacheModule(module) {\n    this.type = module.type;\n    this.request = module.request;\n    this.userRequest = module.userRequest;\n    this.rawRequest = module.rawRequest;\n    this.parser = module.parser;\n    this.generator = module.generator;\n    this.resource = module.resource;\n    this.matchResource = module.matchResource;\n    this.loaders = module.loaders;\n    this.resolveOptions = module.resolveOptions;\n  }\n\n  createSourceForAsset(name, content, sourceMap) {\n    if (!sourceMap) {\n      return new RawSource(content);\n    }\n\n    if (typeof sourceMap === \"string\") {\n      return new OriginalSource(content, sourceMap);\n    }\n\n    return new SourceMapSource(content, name, sourceMap);\n  }\n\n  createLoaderContext(resolver, options, compilation, fs) {\n    const requestShortener = compilation.runtimeTemplate.requestShortener;\n\n    const getCurrentLoaderName = () => {\n      const currentLoader = this.getCurrentLoader(loaderContext);\n      if (!currentLoader) return \"(not in loader scope)\";\n      return requestShortener.shorten(currentLoader.loader);\n    };\n\n    const loaderContext = {\n      version: 2,\n      emitWarning: warning => {\n        if (!(warning instanceof Error)) {\n          warning = new NonErrorEmittedError(warning);\n        }\n\n        this.warnings.push(new ModuleWarning(this, warning, {\n          from: getCurrentLoaderName()\n        }));\n      },\n      emitError: error => {\n        if (!(error instanceof Error)) {\n          error = new NonErrorEmittedError(error);\n        }\n\n        this.errors.push(new ModuleError(this, error, {\n          from: getCurrentLoaderName()\n        }));\n      },\n      getLogger: name => {\n        const currentLoader = this.getCurrentLoader(loaderContext);\n        return compilation.getLogger(() => [currentLoader && currentLoader.loader, name, this.identifier()].filter(Boolean).join(\"|\"));\n      },\n      // TODO remove in webpack 5\n      exec: (code, filename) => {\n        // @ts-ignore Argument of type 'this' is not assignable to parameter of type 'Module'.\n        const module = new NativeModule(filename, this); // @ts-ignore _nodeModulePaths is deprecated and undocumented Node.js API\n\n        module.paths = NativeModule._nodeModulePaths(this.context);\n        module.filename = filename;\n\n        module._compile(code, filename);\n\n        return module.exports;\n      },\n\n      resolve(context, request, callback) {\n        resolver.resolve({}, context, request, {}, callback);\n      },\n\n      getResolve(options) {\n        const child = options ? resolver.withOptions(options) : resolver;\n        return (context, request, callback) => {\n          if (callback) {\n            child.resolve({}, context, request, {}, callback);\n          } else {\n            return new Promise((resolve, reject) => {\n              child.resolve({}, context, request, {}, (err, result) => {\n                if (err) reject(err);else resolve(result);\n              });\n            });\n          }\n        };\n      },\n\n      emitFile: (name, content, sourceMap) => {\n        if (!this.buildInfo.assets) {\n          this.buildInfo.assets = Object.create(null);\n        }\n\n        this.buildInfo.assets[name] = this.createSourceForAsset(name, content, sourceMap);\n      },\n      rootContext: options.context,\n      webpack: true,\n      sourceMap: !!this.useSourceMap,\n      mode: options.mode || \"production\",\n      _module: this,\n      _compilation: compilation,\n      _compiler: compilation.compiler,\n      fs: fs\n    };\n    compilation.hooks.normalModuleLoader.call(loaderContext, this);\n\n    if (options.loader) {\n      Object.assign(loaderContext, options.loader);\n    }\n\n    return loaderContext;\n  }\n\n  getCurrentLoader(loaderContext, index = loaderContext.loaderIndex) {\n    if (this.loaders && this.loaders.length && index < this.loaders.length && index >= 0 && this.loaders[index]) {\n      return this.loaders[index];\n    }\n\n    return null;\n  }\n\n  createSource(source, resourceBuffer, sourceMap) {\n    // if there is no identifier return raw source\n    if (!this.identifier) {\n      return new RawSource(source);\n    } // from here on we assume we have an identifier\n\n\n    const identifier = this.identifier();\n\n    if (this.lineToLine && resourceBuffer) {\n      return new LineToLineMappedSource(source, identifier, asString(resourceBuffer));\n    }\n\n    if (this.useSourceMap && sourceMap) {\n      return new SourceMapSource(source, identifier, sourceMap);\n    }\n\n    if (Buffer.isBuffer(source)) {\n      // @ts-ignore\n      // TODO We need to fix @types/webpack-sources to allow RawSource to take a Buffer | string\n      return new RawSource(source);\n    }\n\n    return new OriginalSource(source, identifier);\n  }\n\n  doBuild(options, compilation, resolver, fs, callback) {\n    const loaderContext = this.createLoaderContext(resolver, options, compilation, fs);\n    runLoaders({\n      resource: this.resource,\n      loaders: this.loaders,\n      context: loaderContext,\n      readResource: fs.readFile.bind(fs)\n    }, (err, result) => {\n      if (result) {\n        this.buildInfo.cacheable = result.cacheable;\n        this.buildInfo.fileDependencies = new Set(result.fileDependencies);\n        this.buildInfo.contextDependencies = new Set(result.contextDependencies);\n      }\n\n      if (err) {\n        if (!(err instanceof Error)) {\n          err = new NonErrorEmittedError(err);\n        }\n\n        const currentLoader = this.getCurrentLoader(loaderContext);\n        const error = new ModuleBuildError(this, err, {\n          from: currentLoader && compilation.runtimeTemplate.requestShortener.shorten(currentLoader.loader)\n        });\n        return callback(error);\n      }\n\n      const resourceBuffer = result.resourceBuffer;\n      const source = result.result[0];\n      const sourceMap = result.result.length >= 1 ? result.result[1] : null;\n      const extraInfo = result.result.length >= 2 ? result.result[2] : null;\n\n      if (!Buffer.isBuffer(source) && typeof source !== \"string\") {\n        const currentLoader = this.getCurrentLoader(loaderContext, 0);\n        const err = new Error(\"Final loader (\".concat(currentLoader ? compilation.runtimeTemplate.requestShortener.shorten(currentLoader.loader) : \"unknown\", \") didn't return a Buffer or String\"));\n        const error = new ModuleBuildError(this, err);\n        return callback(error);\n      }\n\n      this._source = this.createSource(this.binary ? asBuffer(source) : asString(source), resourceBuffer, sourceMap);\n      this._ast = typeof extraInfo === \"object\" && extraInfo !== null && extraInfo.webpackAST !== undefined ? extraInfo.webpackAST : null;\n      return callback();\n    });\n  }\n\n  markModuleAsErrored(error) {\n    // Restore build meta from successful build to keep importing state\n    this.buildMeta = Object.assign({}, this._lastSuccessfulBuildMeta);\n    this.error = error;\n    this.errors.push(this.error);\n    this._source = new RawSource(\"throw new Error(\" + JSON.stringify(this.error.message) + \");\");\n    this._ast = null;\n  }\n\n  applyNoParseRule(rule, content) {\n    // must start with \"rule\" if rule is a string\n    if (typeof rule === \"string\") {\n      return content.indexOf(rule) === 0;\n    }\n\n    if (typeof rule === \"function\") {\n      return rule(content);\n    } // we assume rule is a regexp\n\n\n    return rule.test(content);\n  } // check if module should not be parsed\n  // returns \"true\" if the module should !not! be parsed\n  // returns \"false\" if the module !must! be parsed\n\n\n  shouldPreventParsing(noParseRule, request) {\n    // if no noParseRule exists, return false\n    // the module !must! be parsed.\n    if (!noParseRule) {\n      return false;\n    } // we only have one rule to check\n\n\n    if (!Array.isArray(noParseRule)) {\n      // returns \"true\" if the module is !not! to be parsed\n      return this.applyNoParseRule(noParseRule, request);\n    }\n\n    for (let i = 0; i < noParseRule.length; i++) {\n      const rule = noParseRule[i]; // early exit on first truthy match\n      // this module is !not! to be parsed\n\n      if (this.applyNoParseRule(rule, request)) {\n        return true;\n      }\n    } // no match found, so this module !should! be parsed\n\n\n    return false;\n  }\n\n  _initBuildHash(compilation) {\n    const hash = createHash(compilation.outputOptions.hashFunction);\n\n    if (this._source) {\n      hash.update(\"source\");\n\n      this._source.updateHash(hash);\n    }\n\n    hash.update(\"meta\");\n    hash.update(JSON.stringify(this.buildMeta));\n    this._buildHash =\n    /** @type {string} */\n    hash.digest(\"hex\");\n  }\n\n  build(options, compilation, resolver, fs, callback) {\n    this.buildTimestamp = Date.now();\n    this.built = true;\n    this._source = null;\n    this._ast = null;\n    this._buildHash = \"\";\n    this.error = null;\n    this.errors.length = 0;\n    this.warnings.length = 0;\n    this.buildMeta = {};\n    this.buildInfo = {\n      cacheable: false,\n      fileDependencies: new Set(),\n      contextDependencies: new Set()\n    };\n    return this.doBuild(options, compilation, resolver, fs, err => {\n      this._cachedSources.clear(); // if we have an error mark module as failed and exit\n\n\n      if (err) {\n        this.markModuleAsErrored(err);\n\n        this._initBuildHash(compilation);\n\n        return callback();\n      } // check if this module should !not! be parsed.\n      // if so, exit here;\n\n\n      const noParseRule = options.module && options.module.noParse;\n\n      if (this.shouldPreventParsing(noParseRule, this.request)) {\n        this._initBuildHash(compilation);\n\n        return callback();\n      }\n\n      const handleParseError = e => {\n        const source = this._source.source();\n\n        const loaders = this.loaders.map(item => contextify(options.context, item.loader));\n        const error = new ModuleParseError(this, source, e, loaders);\n        this.markModuleAsErrored(error);\n\n        this._initBuildHash(compilation);\n\n        return callback();\n      };\n\n      const handleParseResult = result => {\n        this._lastSuccessfulBuildMeta = this.buildMeta;\n\n        this._initBuildHash(compilation);\n\n        return callback();\n      };\n\n      try {\n        const result = this.parser.parse(this._ast || this._source.source(), {\n          current: this,\n          module: this,\n          compilation: compilation,\n          options: options\n        }, (err, result) => {\n          if (err) {\n            handleParseError(err);\n          } else {\n            handleParseResult(result);\n          }\n        });\n\n        if (result !== undefined) {\n          // parse is sync\n          handleParseResult(result);\n        }\n      } catch (e) {\n        handleParseError(e);\n      }\n    });\n  }\n\n  getHashDigest(dependencyTemplates) {\n    // TODO webpack 5 refactor\n    let dtHash = dependencyTemplates.get(\"hash\");\n    return \"\".concat(this.hash, \"-\").concat(dtHash);\n  }\n\n  source(dependencyTemplates, runtimeTemplate, type = \"javascript\") {\n    const hashDigest = this.getHashDigest(dependencyTemplates);\n\n    const cacheEntry = this._cachedSources.get(type);\n\n    if (cacheEntry !== undefined && cacheEntry.hash === hashDigest) {\n      // We can reuse the cached source\n      return cacheEntry.source;\n    }\n\n    const source = this.generator.generate(this, dependencyTemplates, runtimeTemplate, type);\n    const cachedSource = new CachedSource(source);\n\n    this._cachedSources.set(type, {\n      source: cachedSource,\n      hash: hashDigest\n    });\n\n    return cachedSource;\n  }\n\n  originalSource() {\n    return this._source;\n  }\n\n  needRebuild(fileTimestamps, contextTimestamps) {\n    // always try to rebuild in case of an error\n    if (this.error) return true; // always rebuild when module is not cacheable\n\n    if (!this.buildInfo.cacheable) return true; // Check timestamps of all dependencies\n    // Missing timestamp -> need rebuild\n    // Timestamp bigger than buildTimestamp -> need rebuild\n\n    for (const file of this.buildInfo.fileDependencies) {\n      const timestamp = fileTimestamps.get(file);\n      if (!timestamp) return true;\n      if (timestamp >= this.buildTimestamp) return true;\n    }\n\n    for (const file of this.buildInfo.contextDependencies) {\n      const timestamp = contextTimestamps.get(file);\n      if (!timestamp) return true;\n      if (timestamp >= this.buildTimestamp) return true;\n    } // elsewise -> no rebuild needed\n\n\n    return false;\n  }\n\n  size() {\n    return this._source ? this._source.size() : -1;\n  }\n  /**\n   * @param {Hash} hash the hash used to track dependencies\n   * @returns {void}\n   */\n\n\n  updateHash(hash) {\n    hash.update(this._buildHash);\n    super.updateHash(hash);\n  }\n\n}\n\nmodule.exports = NormalModule;","map":null,"metadata":{},"sourceType":"script"}