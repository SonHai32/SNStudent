{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _os = _interopRequireDefault(require(\"os\"));\n\nvar _cacache = _interopRequireDefault(require(\"cacache\"));\n\nvar _findCacheDir = _interopRequireDefault(require(\"find-cache-dir\"));\n\nvar _workerFarm = _interopRequireDefault(require(\"worker-farm\"));\n\nvar _serializeJavascript = _interopRequireDefault(require(\"serialize-javascript\"));\n\nvar _isWsl = _interopRequireDefault(require(\"is-wsl\"));\n\nvar _minify = _interopRequireDefault(require(\"./minify\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst worker = require.resolve('./worker');\n\nclass TaskRunner {\n  constructor(options = {}) {\n    const cache = options.cache,\n          parallel = options.parallel;\n    this.cacheDir = cache === true ? (0, _findCacheDir.default)({\n      name: 'terser-webpack-plugin'\n    }) || _os.default.tmpdir() : cache; // In some cases cpus() returns undefined\n    // https://github.com/nodejs/node/issues/19022\n\n    const cpus = _os.default.cpus() || {\n      length: 1\n    }; // WSL sometimes freezes, error seems to be on the WSL side\n    // https://github.com/webpack-contrib/terser-webpack-plugin/issues/21\n\n    this.maxConcurrentWorkers = _isWsl.default ? 1 : parallel === true ? cpus.length - 1 : Math.min(Number(parallel) || 0, cpus.length - 1);\n  }\n\n  run(tasks, callback) {\n    /* istanbul ignore if */\n    if (!tasks.length) {\n      callback(null, []);\n      return;\n    }\n\n    if (this.maxConcurrentWorkers > 1) {\n      const workerOptions = process.platform === 'win32' ? {\n        maxConcurrentWorkers: this.maxConcurrentWorkers,\n        maxConcurrentCallsPerWorker: 1\n      } : {\n        maxConcurrentWorkers: this.maxConcurrentWorkers\n      };\n      this.workers = (0, _workerFarm.default)(workerOptions, worker);\n\n      this.boundWorkers = (options, cb) => {\n        try {\n          this.workers((0, _serializeJavascript.default)(options), cb);\n        } catch (error) {\n          // worker-farm can fail with ENOMEM or something else\n          cb(error);\n        }\n      };\n    } else {\n      this.boundWorkers = (options, cb) => {\n        try {\n          cb(null, (0, _minify.default)(options));\n        } catch (error) {\n          cb(error);\n        }\n      };\n    }\n\n    let toRun = tasks.length;\n    const results = [];\n\n    const step = (index, data) => {\n      toRun -= 1;\n      results[index] = data;\n\n      if (!toRun) {\n        callback(null, results);\n      }\n    };\n\n    tasks.forEach((task, index) => {\n      const enqueue = () => {\n        this.boundWorkers(task, (error, data) => {\n          const result = error ? {\n            error\n          } : data;\n\n          const done = () => step(index, result);\n\n          if (this.cacheDir && !result.error) {\n            _cacache.default.put(this.cacheDir, (0, _serializeJavascript.default)(task.cacheKeys), JSON.stringify(data)).then(done, done);\n          } else {\n            done();\n          }\n        });\n      };\n\n      if (this.cacheDir) {\n        _cacache.default.get(this.cacheDir, (0, _serializeJavascript.default)(task.cacheKeys)).then(({\n          data\n        }) => step(index, JSON.parse(data)), enqueue);\n      } else {\n        enqueue();\n      }\n    });\n  }\n\n  exit() {\n    if (this.workers) {\n      _workerFarm.default.end(this.workers);\n    }\n  }\n\n}\n\nexports.default = TaskRunner;","map":null,"metadata":{},"sourceType":"script"}