{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n/*\n<rules>: <rule>\n<rules>: [<rule>]\n<rule>: {\n\tresource: {\n\t\ttest: <condition>,\n\t\tinclude: <condition>,\n\t\texclude: <condition>,\n\t},\n\tresource: <condition>, -> resource.test\n\ttest: <condition>, -> resource.test\n\tinclude: <condition>, -> resource.include\n\texclude: <condition>, -> resource.exclude\n\tresourceQuery: <condition>,\n\tcompiler: <condition>,\n\tissuer: <condition>,\n\tuse: \"loader\", -> use[0].loader\n\tloader: <>, -> use[0].loader\n\tloaders: <>, -> use\n\toptions: {}, -> use[0].options,\n\tquery: {}, -> options\n\tparser: {},\n\tuse: [\n\t\t\"loader\" -> use[x].loader\n\t],\n\tuse: [\n\t\t{\n\t\t\tloader: \"loader\",\n\t\t\toptions: {}\n\t\t}\n\t],\n\trules: [\n\t\t<rule>\n\t],\n\toneOf: [\n\t\t<rule>\n\t]\n}\n\n<condition>: /regExp/\n<condition>: function(arg) {}\n<condition>: \"starting\"\n<condition>: [<condition>] // or\n<condition>: { and: [<condition>] }\n<condition>: { or: [<condition>] }\n<condition>: { not: [<condition>] }\n<condition>: { test: <condition>, include: <condition>, exclude: <condition> }\n\n\nnormalized:\n\n{\n\tresource: function(),\n\tresourceQuery: function(),\n\tcompiler: function(),\n\tissuer: function(),\n\tuse: [\n\t\t{\n\t\t\tloader: string,\n\t\t\toptions: string,\n\t\t\t<any>: <any>\n\t\t}\n\t],\n\trules: [<rule>],\n\toneOf: [<rule>],\n\t<any>: <any>,\n}\n\n*/\n\"use strict\";\n\nconst notMatcher = matcher => {\n  return str => {\n    return !matcher(str);\n  };\n};\n\nconst orMatcher = items => {\n  return str => {\n    for (let i = 0; i < items.length; i++) {\n      if (items[i](str)) return true;\n    }\n\n    return false;\n  };\n};\n\nconst andMatcher = items => {\n  return str => {\n    for (let i = 0; i < items.length; i++) {\n      if (!items[i](str)) return false;\n    }\n\n    return true;\n  };\n};\n\nmodule.exports = class RuleSet {\n  constructor(rules) {\n    this.references = Object.create(null);\n    this.rules = RuleSet.normalizeRules(rules, this.references, \"ref-\");\n  }\n\n  static normalizeRules(rules, refs, ident) {\n    if (Array.isArray(rules)) {\n      return rules.map((rule, idx) => {\n        return RuleSet.normalizeRule(rule, refs, \"\".concat(ident, \"-\").concat(idx));\n      });\n    } else if (rules) {\n      return [RuleSet.normalizeRule(rules, refs, ident)];\n    } else {\n      return [];\n    }\n  }\n\n  static normalizeRule(rule, refs, ident) {\n    if (typeof rule === \"string\") {\n      return {\n        use: [{\n          loader: rule\n        }]\n      };\n    }\n\n    if (!rule) {\n      throw new Error(\"Unexcepted null when object was expected as rule\");\n    }\n\n    if (typeof rule !== \"object\") {\n      throw new Error(\"Unexcepted \" + typeof rule + \" when object was expected as rule (\" + rule + \")\");\n    }\n\n    const newRule = {};\n    let useSource;\n    let resourceSource;\n    let condition;\n\n    const checkUseSource = newSource => {\n      if (useSource && useSource !== newSource) {\n        throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Rule can only have one result source (provided \" + newSource + \" and \" + useSource + \")\")));\n      }\n\n      useSource = newSource;\n    };\n\n    const checkResourceSource = newSource => {\n      if (resourceSource && resourceSource !== newSource) {\n        throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Rule can only have one resource source (provided \" + newSource + \" and \" + resourceSource + \")\")));\n      }\n\n      resourceSource = newSource;\n    };\n\n    if (rule.test || rule.include || rule.exclude) {\n      checkResourceSource(\"test + include + exclude\");\n      condition = {\n        test: rule.test,\n        include: rule.include,\n        exclude: rule.exclude\n      };\n\n      try {\n        newRule.resource = RuleSet.normalizeCondition(condition);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(condition, error));\n      }\n    }\n\n    if (rule.resource) {\n      checkResourceSource(\"resource\");\n\n      try {\n        newRule.resource = RuleSet.normalizeCondition(rule.resource);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.resource, error));\n      }\n    }\n\n    if (rule.realResource) {\n      try {\n        newRule.realResource = RuleSet.normalizeCondition(rule.realResource);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.realResource, error));\n      }\n    }\n\n    if (rule.resourceQuery) {\n      try {\n        newRule.resourceQuery = RuleSet.normalizeCondition(rule.resourceQuery);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.resourceQuery, error));\n      }\n    }\n\n    if (rule.compiler) {\n      try {\n        newRule.compiler = RuleSet.normalizeCondition(rule.compiler);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.compiler, error));\n      }\n    }\n\n    if (rule.issuer) {\n      try {\n        newRule.issuer = RuleSet.normalizeCondition(rule.issuer);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.issuer, error));\n      }\n    }\n\n    if (rule.loader && rule.loaders) {\n      throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Provided loader and loaders for rule (use only one of them)\")));\n    }\n\n    const loader = rule.loaders || rule.loader;\n\n    if (typeof loader === \"string\" && !rule.options && !rule.query) {\n      checkUseSource(\"loader\");\n      newRule.use = RuleSet.normalizeUse(loader.split(\"!\"), ident);\n    } else if (typeof loader === \"string\" && (rule.options || rule.query)) {\n      checkUseSource(\"loader + options/query\");\n      newRule.use = RuleSet.normalizeUse({\n        loader: loader,\n        options: rule.options,\n        query: rule.query\n      }, ident);\n    } else if (loader && (rule.options || rule.query)) {\n      throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"options/query cannot be used with loaders (use options for each array item)\")));\n    } else if (loader) {\n      checkUseSource(\"loaders\");\n      newRule.use = RuleSet.normalizeUse(loader, ident);\n    } else if (rule.options || rule.query) {\n      throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"options/query provided without loader (use loader + options)\")));\n    }\n\n    if (rule.use) {\n      checkUseSource(\"use\");\n      newRule.use = RuleSet.normalizeUse(rule.use, ident);\n    }\n\n    if (rule.rules) {\n      newRule.rules = RuleSet.normalizeRules(rule.rules, refs, \"\".concat(ident, \"-rules\"));\n    }\n\n    if (rule.oneOf) {\n      newRule.oneOf = RuleSet.normalizeRules(rule.oneOf, refs, \"\".concat(ident, \"-oneOf\"));\n    }\n\n    const keys = Object.keys(rule).filter(key => {\n      return ![\"resource\", \"resourceQuery\", \"compiler\", \"test\", \"include\", \"exclude\", \"issuer\", \"loader\", \"options\", \"query\", \"loaders\", \"use\", \"rules\", \"oneOf\"].includes(key);\n    });\n\n    for (const key of keys) {\n      newRule[key] = rule[key];\n    }\n\n    if (Array.isArray(newRule.use)) {\n      for (const item of newRule.use) {\n        if (item.ident) {\n          refs[item.ident] = item.options;\n        }\n      }\n    }\n\n    return newRule;\n  }\n\n  static buildErrorMessage(condition, error) {\n    const conditionAsText = JSON.stringify(condition, (key, value) => {\n      return value === undefined ? \"undefined\" : value;\n    }, 2);\n    return error.message + \" in \" + conditionAsText;\n  }\n\n  static normalizeUse(use, ident) {\n    if (typeof use === \"function\") {\n      return data => RuleSet.normalizeUse(use(data), ident);\n    }\n\n    if (Array.isArray(use)) {\n      return use.map((item, idx) => RuleSet.normalizeUse(item, \"\".concat(ident, \"-\").concat(idx))).reduce((arr, items) => arr.concat(items), []);\n    }\n\n    return [RuleSet.normalizeUseItem(use, ident)];\n  }\n\n  static normalizeUseItemString(useItemString) {\n    const idx = useItemString.indexOf(\"?\");\n\n    if (idx >= 0) {\n      return {\n        loader: useItemString.substr(0, idx),\n        options: useItemString.substr(idx + 1)\n      };\n    }\n\n    return {\n      loader: useItemString,\n      options: undefined\n    };\n  }\n\n  static normalizeUseItem(item, ident) {\n    if (typeof item === \"string\") {\n      return RuleSet.normalizeUseItemString(item);\n    }\n\n    const newItem = {};\n\n    if (item.options && item.query) {\n      throw new Error(\"Provided options and query in use\");\n    }\n\n    if (!item.loader) {\n      throw new Error(\"No loader specified\");\n    }\n\n    newItem.options = item.options || item.query;\n\n    if (typeof newItem.options === \"object\" && newItem.options) {\n      if (newItem.options.ident) {\n        newItem.ident = newItem.options.ident;\n      } else {\n        newItem.ident = ident;\n      }\n    }\n\n    const keys = Object.keys(item).filter(function (key) {\n      return ![\"options\", \"query\"].includes(key);\n    });\n\n    for (const key of keys) {\n      newItem[key] = item[key];\n    }\n\n    return newItem;\n  }\n\n  static normalizeCondition(condition) {\n    if (!condition) throw new Error(\"Expected condition but got falsy value\");\n\n    if (typeof condition === \"string\") {\n      return str => str.indexOf(condition) === 0;\n    }\n\n    if (typeof condition === \"function\") {\n      return condition;\n    }\n\n    if (condition instanceof RegExp) {\n      return condition.test.bind(condition);\n    }\n\n    if (Array.isArray(condition)) {\n      const items = condition.map(c => RuleSet.normalizeCondition(c));\n      return orMatcher(items);\n    }\n\n    if (typeof condition !== \"object\") {\n      throw Error(\"Unexcepted \" + typeof condition + \" when condition was expected (\" + condition + \")\");\n    }\n\n    const matchers = [];\n    Object.keys(condition).forEach(key => {\n      const value = condition[key];\n\n      switch (key) {\n        case \"or\":\n        case \"include\":\n        case \"test\":\n          if (value) matchers.push(RuleSet.normalizeCondition(value));\n          break;\n\n        case \"and\":\n          if (value) {\n            const items = value.map(c => RuleSet.normalizeCondition(c));\n            matchers.push(andMatcher(items));\n          }\n\n          break;\n\n        case \"not\":\n        case \"exclude\":\n          if (value) {\n            const matcher = RuleSet.normalizeCondition(value);\n            matchers.push(notMatcher(matcher));\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unexcepted property \" + key + \" in condition\");\n      }\n    });\n\n    if (matchers.length === 0) {\n      throw new Error(\"Excepted condition but got \" + condition);\n    }\n\n    if (matchers.length === 1) {\n      return matchers[0];\n    }\n\n    return andMatcher(matchers);\n  }\n\n  exec(data) {\n    const result = [];\n\n    this._run(data, {\n      rules: this.rules\n    }, result);\n\n    return result;\n  }\n\n  _run(data, rule, result) {\n    // test conditions\n    if (rule.resource && !data.resource) return false;\n    if (rule.realResource && !data.realResource) return false;\n    if (rule.resourceQuery && !data.resourceQuery) return false;\n    if (rule.compiler && !data.compiler) return false;\n    if (rule.issuer && !data.issuer) return false;\n    if (rule.resource && !rule.resource(data.resource)) return false;\n    if (rule.realResource && !rule.realResource(data.realResource)) return false;\n    if (data.issuer && rule.issuer && !rule.issuer(data.issuer)) return false;\n\n    if (data.resourceQuery && rule.resourceQuery && !rule.resourceQuery(data.resourceQuery)) {\n      return false;\n    }\n\n    if (data.compiler && rule.compiler && !rule.compiler(data.compiler)) {\n      return false;\n    } // apply\n\n\n    const keys = Object.keys(rule).filter(key => {\n      return ![\"resource\", \"realResource\", \"resourceQuery\", \"compiler\", \"issuer\", \"rules\", \"oneOf\", \"use\", \"enforce\"].includes(key);\n    });\n\n    for (const key of keys) {\n      result.push({\n        type: key,\n        value: rule[key]\n      });\n    }\n\n    if (rule.use) {\n      const process = use => {\n        if (typeof use === \"function\") {\n          process(use(data));\n        } else if (Array.isArray(use)) {\n          use.forEach(process);\n        } else {\n          result.push({\n            type: \"use\",\n            value: use,\n            enforce: rule.enforce\n          });\n        }\n      };\n\n      process(rule.use);\n    }\n\n    if (rule.rules) {\n      for (let i = 0; i < rule.rules.length; i++) {\n        this._run(data, rule.rules[i], result);\n      }\n    }\n\n    if (rule.oneOf) {\n      for (let i = 0; i < rule.oneOf.length; i++) {\n        if (this._run(data, rule.oneOf[i], result)) break;\n      }\n    }\n\n    return true;\n  }\n\n  findOptionsByIdent(ident) {\n    const options = this.references[ident];\n\n    if (!options) {\n      throw new Error(\"Can't find options with ident '\" + ident + \"'\");\n    }\n\n    return options;\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}