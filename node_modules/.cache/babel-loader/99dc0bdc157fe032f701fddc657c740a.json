{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nconst DependenciesBlockVariable = require(\"./DependenciesBlockVariable\");\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./DependenciesBlockVariable\")} DependenciesBlockVariable */\n\n/** @typedef {(d: Dependency) => boolean} DependencyFilterFunction */\n\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n\nclass DependenciesBlock {\n  constructor() {\n    /** @type {Dependency[]} */\n    this.dependencies = [];\n    /** @type {AsyncDependenciesBlock[]} */\n\n    this.blocks = [];\n    /** @type {DependenciesBlockVariable[]} */\n\n    this.variables = [];\n  }\n  /**\n   * Adds a DependencyBlock to DependencyBlock relationship.\n   * This is used for when a Module has a AsyncDependencyBlock tie (for code-splitting)\n   *\n   * @param {AsyncDependenciesBlock} block block being added\n   * @returns {void}\n   */\n\n\n  addBlock(block) {\n    this.blocks.push(block);\n    block.parent = this;\n  }\n  /**\n   * @param {string} name name of dependency\n   * @param {string} expression expression string for variable\n   * @param {Dependency[]} dependencies dependency instances tied to variable\n   * @returns {void}\n   */\n\n\n  addVariable(name, expression, dependencies) {\n    for (let v of this.variables) {\n      if (v.name === name && v.expression === expression) {\n        return;\n      }\n    }\n\n    this.variables.push(new DependenciesBlockVariable(name, expression, dependencies));\n  }\n  /**\n   * @param {Dependency} dependency dependency being tied to block.\n   * This is an \"edge\" pointing to another \"node\" on module graph.\n   * @returns {void}\n   */\n\n\n  addDependency(dependency) {\n    this.dependencies.push(dependency);\n  }\n  /**\n   * @param {Dependency} dependency dependency being removed\n   * @returns {void}\n   */\n\n\n  removeDependency(dependency) {\n    const idx = this.dependencies.indexOf(dependency);\n\n    if (idx >= 0) {\n      this.dependencies.splice(idx, 1);\n    }\n  }\n  /**\n   * @param {Hash} hash the hash used to track dependencies\n   * @returns {void}\n   */\n\n\n  updateHash(hash) {\n    for (const dep of this.dependencies) dep.updateHash(hash);\n\n    for (const block of this.blocks) block.updateHash(hash);\n\n    for (const variable of this.variables) variable.updateHash(hash);\n  }\n\n  disconnect() {\n    for (const dep of this.dependencies) dep.disconnect();\n\n    for (const block of this.blocks) block.disconnect();\n\n    for (const variable of this.variables) variable.disconnect();\n  }\n\n  unseal() {\n    for (const block of this.blocks) block.unseal();\n  }\n  /**\n   * @param {DependencyFilterFunction} filter filter function for dependencies, gets passed all dependency ties from current instance\n   * @returns {boolean} returns boolean for filter\n   */\n\n\n  hasDependencies(filter) {\n    if (filter) {\n      for (const dep of this.dependencies) {\n        if (filter(dep)) return true;\n      }\n    } else {\n      if (this.dependencies.length > 0) {\n        return true;\n      }\n    }\n\n    for (const block of this.blocks) {\n      if (block.hasDependencies(filter)) return true;\n    }\n\n    for (const variable of this.variables) {\n      if (variable.hasDependencies(filter)) return true;\n    }\n\n    return false;\n  }\n\n  sortItems() {\n    for (const block of this.blocks) block.sortItems();\n  }\n\n}\n\nmodule.exports = DependenciesBlock;","map":null,"metadata":{},"sourceType":"script"}