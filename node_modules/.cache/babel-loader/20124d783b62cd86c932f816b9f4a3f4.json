{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst _require = require(\"tapable\"),\n      SyncBailHook = _require.SyncBailHook;\n\nconst _require2 = require(\"webpack-sources\"),\n      RawSource = _require2.RawSource;\n\nconst Template = require(\"./Template\");\n\nconst ModuleHotAcceptDependency = require(\"./dependencies/ModuleHotAcceptDependency\");\n\nconst ModuleHotDeclineDependency = require(\"./dependencies/ModuleHotDeclineDependency\");\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\n\nconst NullFactory = require(\"./NullFactory\");\n\nconst ParserHelpers = require(\"./ParserHelpers\");\n\nmodule.exports = class HotModuleReplacementPlugin {\n  constructor(options) {\n    this.options = options || {};\n    this.multiStep = this.options.multiStep;\n    this.fullBuildTimeout = this.options.fullBuildTimeout || 200;\n    this.requestTimeout = this.options.requestTimeout || 10000;\n  }\n\n  apply(compiler) {\n    const multiStep = this.multiStep;\n    const fullBuildTimeout = this.fullBuildTimeout;\n    const requestTimeout = this.requestTimeout;\n    const hotUpdateChunkFilename = compiler.options.output.hotUpdateChunkFilename;\n    const hotUpdateMainFilename = compiler.options.output.hotUpdateMainFilename;\n    compiler.hooks.additionalPass.tapAsync(\"HotModuleReplacementPlugin\", callback => {\n      if (multiStep) return setTimeout(callback, fullBuildTimeout);\n      return callback();\n    });\n\n    const addParserPlugins = (parser, parserOptions) => {\n      parser.hooks.expression.for(\"__webpack_hash__\").tap(\"HotModuleReplacementPlugin\", ParserHelpers.toConstantDependencyWithWebpackRequire(parser, \"__webpack_require__.h()\"));\n      parser.hooks.evaluateTypeof.for(\"__webpack_hash__\").tap(\"HotModuleReplacementPlugin\", ParserHelpers.evaluateToString(\"string\"));\n      parser.hooks.evaluateIdentifier.for(\"module.hot\").tap({\n        name: \"HotModuleReplacementPlugin\",\n        before: \"NodeStuffPlugin\"\n      }, expr => {\n        return ParserHelpers.evaluateToIdentifier(\"module.hot\", !!parser.state.compilation.hotUpdateChunkTemplate)(expr);\n      }); // TODO webpack 5: refactor this, no custom hooks\n\n      if (!parser.hooks.hotAcceptCallback) {\n        parser.hooks.hotAcceptCallback = new SyncBailHook([\"expression\", \"requests\"]);\n      }\n\n      if (!parser.hooks.hotAcceptWithoutCallback) {\n        parser.hooks.hotAcceptWithoutCallback = new SyncBailHook([\"expression\", \"requests\"]);\n      }\n\n      parser.hooks.call.for(\"module.hot.accept\").tap(\"HotModuleReplacementPlugin\", expr => {\n        if (!parser.state.compilation.hotUpdateChunkTemplate) {\n          return false;\n        }\n\n        if (expr.arguments.length >= 1) {\n          const arg = parser.evaluateExpression(expr.arguments[0]);\n          let params = [];\n          let requests = [];\n\n          if (arg.isString()) {\n            params = [arg];\n          } else if (arg.isArray()) {\n            params = arg.items.filter(param => param.isString());\n          }\n\n          if (params.length > 0) {\n            params.forEach((param, idx) => {\n              const request = param.string;\n              const dep = new ModuleHotAcceptDependency(request, param.range);\n              dep.optional = true;\n              dep.loc = Object.create(expr.loc);\n              dep.loc.index = idx;\n              parser.state.module.addDependency(dep);\n              requests.push(request);\n            });\n\n            if (expr.arguments.length > 1) {\n              parser.hooks.hotAcceptCallback.call(expr.arguments[1], requests);\n              parser.walkExpression(expr.arguments[1]); // other args are ignored\n\n              return true;\n            } else {\n              parser.hooks.hotAcceptWithoutCallback.call(expr, requests);\n              return true;\n            }\n          }\n        }\n      });\n      parser.hooks.call.for(\"module.hot.decline\").tap(\"HotModuleReplacementPlugin\", expr => {\n        if (!parser.state.compilation.hotUpdateChunkTemplate) {\n          return false;\n        }\n\n        if (expr.arguments.length === 1) {\n          const arg = parser.evaluateExpression(expr.arguments[0]);\n          let params = [];\n\n          if (arg.isString()) {\n            params = [arg];\n          } else if (arg.isArray()) {\n            params = arg.items.filter(param => param.isString());\n          }\n\n          params.forEach((param, idx) => {\n            const dep = new ModuleHotDeclineDependency(param.string, param.range);\n            dep.optional = true;\n            dep.loc = Object.create(expr.loc);\n            dep.loc.index = idx;\n            parser.state.module.addDependency(dep);\n          });\n        }\n      });\n      parser.hooks.expression.for(\"module.hot\").tap(\"HotModuleReplacementPlugin\", ParserHelpers.skipTraversal);\n    };\n\n    compiler.hooks.compilation.tap(\"HotModuleReplacementPlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      const hotUpdateChunkTemplate = compilation.hotUpdateChunkTemplate;\n      if (!hotUpdateChunkTemplate) return;\n      compilation.dependencyFactories.set(ConstDependency, new NullFactory());\n      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n      compilation.dependencyFactories.set(ModuleHotAcceptDependency, normalModuleFactory);\n      compilation.dependencyTemplates.set(ModuleHotAcceptDependency, new ModuleHotAcceptDependency.Template());\n      compilation.dependencyFactories.set(ModuleHotDeclineDependency, normalModuleFactory);\n      compilation.dependencyTemplates.set(ModuleHotDeclineDependency, new ModuleHotDeclineDependency.Template());\n      compilation.hooks.record.tap(\"HotModuleReplacementPlugin\", (compilation, records) => {\n        if (records.hash === compilation.hash) return;\n        records.hash = compilation.hash;\n        records.moduleHashs = {};\n\n        for (const module of compilation.modules) {\n          const identifier = module.identifier();\n          records.moduleHashs[identifier] = module.hash;\n        }\n\n        records.chunkHashs = {};\n\n        for (const chunk of compilation.chunks) {\n          records.chunkHashs[chunk.id] = chunk.hash;\n        }\n\n        records.chunkModuleIds = {};\n\n        for (const chunk of compilation.chunks) {\n          records.chunkModuleIds[chunk.id] = Array.from(chunk.modulesIterable, m => m.id);\n        }\n      });\n      let initialPass = false;\n      let recompilation = false;\n      compilation.hooks.afterHash.tap(\"HotModuleReplacementPlugin\", () => {\n        let records = compilation.records;\n\n        if (!records) {\n          initialPass = true;\n          return;\n        }\n\n        if (!records.hash) initialPass = true;\n        const preHash = records.preHash || \"x\";\n        const prepreHash = records.prepreHash || \"x\";\n\n        if (preHash === compilation.hash) {\n          recompilation = true;\n          compilation.modifyHash(prepreHash);\n          return;\n        }\n\n        records.prepreHash = records.hash || \"x\";\n        records.preHash = compilation.hash;\n        compilation.modifyHash(records.prepreHash);\n      });\n      compilation.hooks.shouldGenerateChunkAssets.tap(\"HotModuleReplacementPlugin\", () => {\n        if (multiStep && !recompilation && !initialPass) return false;\n      });\n      compilation.hooks.needAdditionalPass.tap(\"HotModuleReplacementPlugin\", () => {\n        if (multiStep && !recompilation && !initialPass) return true;\n      });\n      compilation.hooks.additionalChunkAssets.tap(\"HotModuleReplacementPlugin\", () => {\n        const records = compilation.records;\n        if (records.hash === compilation.hash) return;\n        if (!records.moduleHashs || !records.chunkHashs || !records.chunkModuleIds) return;\n\n        for (const module of compilation.modules) {\n          const identifier = module.identifier();\n          let hash = module.hash;\n          module.hotUpdate = records.moduleHashs[identifier] !== hash;\n        }\n\n        const hotUpdateMainContent = {\n          h: compilation.hash,\n          c: {}\n        };\n\n        for (const key of Object.keys(records.chunkHashs)) {\n          const chunkId = isNaN(+key) ? key : +key;\n          const currentChunk = compilation.chunks.find(chunk => \"\".concat(chunk.id) === key);\n\n          if (currentChunk) {\n            const newModules = currentChunk.getModules().filter(module => module.hotUpdate);\n            const allModules = new Set();\n\n            for (const module of currentChunk.modulesIterable) {\n              allModules.add(module.id);\n            }\n\n            const removedModules = records.chunkModuleIds[chunkId].filter(id => !allModules.has(id));\n\n            if (newModules.length > 0 || removedModules.length > 0) {\n              const source = hotUpdateChunkTemplate.render(chunkId, newModules, removedModules, compilation.hash, compilation.moduleTemplates.javascript, compilation.dependencyTemplates);\n              const filename = compilation.getPath(hotUpdateChunkFilename, {\n                hash: records.hash,\n                chunk: currentChunk\n              });\n              compilation.additionalChunkAssets.push(filename);\n              compilation.assets[filename] = source;\n              hotUpdateMainContent.c[chunkId] = true;\n              currentChunk.files.push(filename);\n              compilation.hooks.chunkAsset.call(currentChunk, filename);\n            }\n          } else {\n            hotUpdateMainContent.c[chunkId] = false;\n          }\n        }\n\n        const source = new RawSource(JSON.stringify(hotUpdateMainContent));\n        const filename = compilation.getPath(hotUpdateMainFilename, {\n          hash: records.hash\n        });\n        compilation.assets[filename] = source;\n      });\n      const mainTemplate = compilation.mainTemplate;\n      mainTemplate.hooks.hash.tap(\"HotModuleReplacementPlugin\", hash => {\n        hash.update(\"HotMainTemplateDecorator\");\n      });\n      mainTemplate.hooks.moduleRequire.tap(\"HotModuleReplacementPlugin\", (_, chunk, hash, varModuleId) => {\n        return \"hotCreateRequire(\".concat(varModuleId, \")\");\n      });\n      mainTemplate.hooks.requireExtensions.tap(\"HotModuleReplacementPlugin\", source => {\n        const buf = [source];\n        buf.push(\"\");\n        buf.push(\"// __webpack_hash__\");\n        buf.push(mainTemplate.requireFn + \".h = function() { return hotCurrentHash; };\");\n        return Template.asString(buf);\n      });\n\n      const needChunkLoadingCode = chunk => {\n        for (const chunkGroup of chunk.groupsIterable) {\n          if (chunkGroup.chunks.length > 1) return true;\n          if (chunkGroup.getNumberOfChildren() > 0) return true;\n        }\n\n        return false;\n      };\n\n      mainTemplate.hooks.bootstrap.tap(\"HotModuleReplacementPlugin\", (source, chunk, hash) => {\n        source = mainTemplate.hooks.hotBootstrap.call(source, chunk, hash);\n        return Template.asString([source, \"\", hotInitCode.replace(/\\$require\\$/g, mainTemplate.requireFn).replace(/\\$hash\\$/g, JSON.stringify(hash)).replace(/\\$requestTimeout\\$/g, requestTimeout).replace(/\\/\\*foreachInstalledChunks\\*\\//g, needChunkLoadingCode(chunk) ? \"for(var chunkId in installedChunks)\" : \"var chunkId = \".concat(JSON.stringify(chunk.id), \";\"))]);\n      });\n      mainTemplate.hooks.globalHash.tap(\"HotModuleReplacementPlugin\", () => true);\n      mainTemplate.hooks.currentHash.tap(\"HotModuleReplacementPlugin\", (_, length) => {\n        if (isFinite(length)) {\n          return \"hotCurrentHash.substr(0, \".concat(length, \")\");\n        } else {\n          return \"hotCurrentHash\";\n        }\n      });\n      mainTemplate.hooks.moduleObj.tap(\"HotModuleReplacementPlugin\", (source, chunk, hash, varModuleId) => {\n        return Template.asString([\"\".concat(source, \",\"), \"hot: hotCreateModule(\".concat(varModuleId, \"),\"), \"parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),\", \"children: []\"]);\n      }); // TODO add HMR support for javascript/esm\n\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"HotModuleReplacementPlugin\", addParserPlugins);\n      normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"HotModuleReplacementPlugin\", addParserPlugins);\n      compilation.hooks.normalModuleLoader.tap(\"HotModuleReplacementPlugin\", context => {\n        context.hot = true;\n      });\n    });\n  }\n\n};\nconst hotInitCode = Template.getFunctionContent(require(\"./HotModuleReplacement.runtime\"));","map":null,"metadata":{},"sourceType":"script"}