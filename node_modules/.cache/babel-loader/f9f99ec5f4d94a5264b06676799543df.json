{"ast":null,"code":"'use strict';\n\nconst BB = require('bluebird');\n\nconst figgyPudding = require('figgy-pudding');\n\nconst fs = require('fs');\n\nconst index = require('./lib/entry-index');\n\nconst memo = require('./lib/memoization');\n\nconst pipe = require('mississippi').pipe;\n\nconst pipeline = require('mississippi').pipeline;\n\nconst read = require('./lib/content/read');\n\nconst through = require('mississippi').through;\n\nconst GetOpts = figgyPudding({\n  integrity: {},\n  memoize: {},\n  size: {}\n});\n\nmodule.exports = function get(cache, key, opts) {\n  return getData(false, cache, key, opts);\n};\n\nmodule.exports.byDigest = function getByDigest(cache, digest, opts) {\n  return getData(true, cache, digest, opts);\n};\n\nfunction getData(byDigest, cache, key, opts) {\n  opts = GetOpts(opts);\n  const memoized = byDigest ? memo.get.byDigest(cache, key, opts) : memo.get(cache, key, opts);\n\n  if (memoized && opts.memoize !== false) {\n    return BB.resolve(byDigest ? memoized : {\n      metadata: memoized.entry.metadata,\n      data: memoized.data,\n      integrity: memoized.entry.integrity,\n      size: memoized.entry.size\n    });\n  }\n\n  return (byDigest ? BB.resolve(null) : index.find(cache, key, opts)).then(entry => {\n    if (!entry && !byDigest) {\n      throw new index.NotFoundError(cache, key);\n    }\n\n    return read(cache, byDigest ? key : entry.integrity, {\n      integrity: opts.integrity,\n      size: opts.size\n    }).then(data => byDigest ? data : {\n      metadata: entry.metadata,\n      data: data,\n      size: entry.size,\n      integrity: entry.integrity\n    }).then(res => {\n      if (opts.memoize && byDigest) {\n        memo.put.byDigest(cache, key, res, opts);\n      } else if (opts.memoize) {\n        memo.put(cache, entry, res.data, opts);\n      }\n\n      return res;\n    });\n  });\n}\n\nmodule.exports.sync = function get(cache, key, opts) {\n  return getDataSync(false, cache, key, opts);\n};\n\nmodule.exports.sync.byDigest = function getByDigest(cache, digest, opts) {\n  return getDataSync(true, cache, digest, opts);\n};\n\nfunction getDataSync(byDigest, cache, key, opts) {\n  opts = GetOpts(opts);\n  const memoized = byDigest ? memo.get.byDigest(cache, key, opts) : memo.get(cache, key, opts);\n\n  if (memoized && opts.memoize !== false) {\n    return byDigest ? memoized : {\n      metadata: memoized.entry.metadata,\n      data: memoized.data,\n      integrity: memoized.entry.integrity,\n      size: memoized.entry.size\n    };\n  }\n\n  const entry = !byDigest && index.find.sync(cache, key, opts);\n\n  if (!entry && !byDigest) {\n    throw new index.NotFoundError(cache, key);\n  }\n\n  const data = read.sync(cache, byDigest ? key : entry.integrity, {\n    integrity: opts.integrity,\n    size: opts.size\n  });\n  const res = byDigest ? data : {\n    metadata: entry.metadata,\n    data: data,\n    size: entry.size,\n    integrity: entry.integrity\n  };\n\n  if (opts.memoize && byDigest) {\n    memo.put.byDigest(cache, key, res, opts);\n  } else if (opts.memoize) {\n    memo.put(cache, entry, res.data, opts);\n  }\n\n  return res;\n}\n\nmodule.exports.stream = getStream;\n\nfunction getStream(cache, key, opts) {\n  opts = GetOpts(opts);\n  let stream = through();\n  const memoized = memo.get(cache, key, opts);\n\n  if (memoized && opts.memoize !== false) {\n    stream.on('newListener', function (ev, cb) {\n      ev === 'metadata' && cb(memoized.entry.metadata);\n      ev === 'integrity' && cb(memoized.entry.integrity);\n      ev === 'size' && cb(memoized.entry.size);\n    });\n    stream.write(memoized.data, () => stream.end());\n    return stream;\n  }\n\n  index.find(cache, key).then(entry => {\n    if (!entry) {\n      return stream.emit('error', new index.NotFoundError(cache, key));\n    }\n\n    let memoStream;\n\n    if (opts.memoize) {\n      let memoData = [];\n      let memoLength = 0;\n      memoStream = through((c, en, cb) => {\n        memoData && memoData.push(c);\n        memoLength += c.length;\n        cb(null, c, en);\n      }, cb => {\n        memoData && memo.put(cache, entry, Buffer.concat(memoData, memoLength), opts);\n        cb();\n      });\n    } else {\n      memoStream = through();\n    }\n\n    stream.emit('metadata', entry.metadata);\n    stream.emit('integrity', entry.integrity);\n    stream.emit('size', entry.size);\n    stream.on('newListener', function (ev, cb) {\n      ev === 'metadata' && cb(entry.metadata);\n      ev === 'integrity' && cb(entry.integrity);\n      ev === 'size' && cb(entry.size);\n    });\n    pipe(read.readStream(cache, entry.integrity, opts.concat({\n      size: opts.size == null ? entry.size : opts.size\n    })), memoStream, stream);\n  }).catch(err => stream.emit('error', err));\n  return stream;\n}\n\nmodule.exports.stream.byDigest = getStreamDigest;\n\nfunction getStreamDigest(cache, integrity, opts) {\n  opts = GetOpts(opts);\n  const memoized = memo.get.byDigest(cache, integrity, opts);\n\n  if (memoized && opts.memoize !== false) {\n    const stream = through();\n    stream.write(memoized, () => stream.end());\n    return stream;\n  } else {\n    let stream = read.readStream(cache, integrity, opts);\n\n    if (opts.memoize) {\n      let memoData = [];\n      let memoLength = 0;\n      const memoStream = through((c, en, cb) => {\n        memoData && memoData.push(c);\n        memoLength += c.length;\n        cb(null, c, en);\n      }, cb => {\n        memoData && memo.put.byDigest(cache, integrity, Buffer.concat(memoData, memoLength), opts);\n        cb();\n      });\n      stream = pipeline(stream, memoStream);\n    }\n\n    return stream;\n  }\n}\n\nmodule.exports.info = info;\n\nfunction info(cache, key, opts) {\n  opts = GetOpts(opts);\n  const memoized = memo.get(cache, key, opts);\n\n  if (memoized && opts.memoize !== false) {\n    return BB.resolve(memoized.entry);\n  } else {\n    return index.find(cache, key);\n  }\n}\n\nmodule.exports.hasContent = read.hasContent;\n\nmodule.exports.copy = function cp(cache, key, dest, opts) {\n  return copy(false, cache, key, dest, opts);\n};\n\nmodule.exports.copy.byDigest = function cpDigest(cache, digest, dest, opts) {\n  return copy(true, cache, digest, dest, opts);\n};\n\nfunction copy(byDigest, cache, key, dest, opts) {\n  opts = GetOpts(opts);\n\n  if (read.copy) {\n    return (byDigest ? BB.resolve(null) : index.find(cache, key, opts)).then(entry => {\n      if (!entry && !byDigest) {\n        throw new index.NotFoundError(cache, key);\n      }\n\n      return read.copy(cache, byDigest ? key : entry.integrity, dest, opts).then(() => byDigest ? key : {\n        metadata: entry.metadata,\n        size: entry.size,\n        integrity: entry.integrity\n      });\n    });\n  } else {\n    return getData(byDigest, cache, key, opts).then(res => {\n      return fs.writeFileAsync(dest, byDigest ? res : res.data).then(() => byDigest ? key : {\n        metadata: res.metadata,\n        size: res.size,\n        integrity: res.integrity\n      });\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"script"}