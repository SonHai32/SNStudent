{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst _require = require(\"tapable\"),\n      Tapable = _require.Tapable,\n      SyncHook = _require.SyncHook,\n      MultiHook = _require.MultiHook;\n\nconst asyncLib = require(\"neo-async\");\n\nconst MultiWatching = require(\"./MultiWatching\");\n\nconst MultiStats = require(\"./MultiStats\");\n\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nmodule.exports = class MultiCompiler extends Tapable {\n  constructor(compilers) {\n    super();\n    this.hooks = {\n      done: new SyncHook([\"stats\"]),\n      invalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n      run: new MultiHook(compilers.map(c => c.hooks.run)),\n      watchClose: new SyncHook([]),\n      watchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n      infrastructureLog: new MultiHook(compilers.map(c => c.hooks.infrastructureLog))\n    };\n\n    if (!Array.isArray(compilers)) {\n      compilers = Object.keys(compilers).map(name => {\n        compilers[name].name = name;\n        return compilers[name];\n      });\n    }\n\n    this.compilers = compilers;\n    let doneCompilers = 0;\n    let compilerStats = [];\n    let index = 0;\n\n    for (const compiler of this.compilers) {\n      let compilerDone = false;\n      const compilerIndex = index++; // eslint-disable-next-line no-loop-func\n\n      compiler.hooks.done.tap(\"MultiCompiler\", stats => {\n        if (!compilerDone) {\n          compilerDone = true;\n          doneCompilers++;\n        }\n\n        compilerStats[compilerIndex] = stats;\n\n        if (doneCompilers === this.compilers.length) {\n          this.hooks.done.call(new MultiStats(compilerStats));\n        }\n      }); // eslint-disable-next-line no-loop-func\n\n      compiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n        if (compilerDone) {\n          compilerDone = false;\n          doneCompilers--;\n        }\n      });\n    }\n\n    this.running = false;\n  }\n\n  get outputPath() {\n    let commonPath = this.compilers[0].outputPath;\n\n    for (const compiler of this.compilers) {\n      while (compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\\\]/.test(commonPath)) {\n        commonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n      }\n    }\n\n    if (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n    return commonPath;\n  }\n\n  get inputFileSystem() {\n    throw new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n  }\n\n  get outputFileSystem() {\n    throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n  }\n\n  set inputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.inputFileSystem = value;\n    }\n  }\n\n  set outputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.outputFileSystem = value;\n    }\n  }\n\n  getInfrastructureLogger(name) {\n    return this.compilers[0].getInfrastructureLogger(name);\n  }\n\n  validateDependencies(callback) {\n    const edges = new Set();\n    const missing = [];\n\n    const targetFound = compiler => {\n      for (const edge of edges) {\n        if (edge.target === compiler) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    const sortEdges = (e1, e2) => {\n      return e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);\n    };\n\n    for (const source of this.compilers) {\n      if (source.dependencies) {\n        for (const dep of source.dependencies) {\n          const target = this.compilers.find(c => c.name === dep);\n\n          if (!target) {\n            missing.push(dep);\n          } else {\n            edges.add({\n              source,\n              target\n            });\n          }\n        }\n      }\n    }\n\n    const errors = missing.map(m => \"Compiler dependency `\".concat(m, \"` not found.\"));\n    const stack = this.compilers.filter(c => !targetFound(c));\n\n    while (stack.length > 0) {\n      const current = stack.pop();\n\n      for (const edge of edges) {\n        if (edge.source === current) {\n          edges.delete(edge);\n          const target = edge.target;\n\n          if (!targetFound(target)) {\n            stack.push(target);\n          }\n        }\n      }\n    }\n\n    if (edges.size > 0) {\n      const lines = Array.from(edges).sort(sortEdges).map(edge => \"\".concat(edge.source.name, \" -> \").concat(edge.target.name));\n      lines.unshift(\"Circular dependency found in compiler dependencies.\");\n      errors.unshift(lines.join(\"\\n\"));\n    }\n\n    if (errors.length > 0) {\n      const message = errors.join(\"\\n\");\n      callback(new Error(message));\n      return false;\n    }\n\n    return true;\n  }\n\n  runWithDependencies(compilers, fn, callback) {\n    const fulfilledNames = new Set();\n    let remainingCompilers = compilers;\n\n    const isDependencyFulfilled = d => fulfilledNames.has(d);\n\n    const getReadyCompilers = () => {\n      let readyCompilers = [];\n      let list = remainingCompilers;\n      remainingCompilers = [];\n\n      for (const c of list) {\n        const ready = !c.dependencies || c.dependencies.every(isDependencyFulfilled);\n\n        if (ready) {\n          readyCompilers.push(c);\n        } else {\n          remainingCompilers.push(c);\n        }\n      }\n\n      return readyCompilers;\n    };\n\n    const runCompilers = callback => {\n      if (remainingCompilers.length === 0) return callback();\n      asyncLib.map(getReadyCompilers(), (compiler, callback) => {\n        fn(compiler, err => {\n          if (err) return callback(err);\n          fulfilledNames.add(compiler.name);\n          runCompilers(callback);\n        });\n      }, callback);\n    };\n\n    runCompilers(callback);\n  }\n\n  watch(watchOptions, handler) {\n    if (this.running) return handler(new ConcurrentCompilationError());\n    let watchings = [];\n    let allStats = this.compilers.map(() => null);\n    let compilerStatus = this.compilers.map(() => false);\n\n    if (this.validateDependencies(handler)) {\n      this.running = true;\n      this.runWithDependencies(this.compilers, (compiler, callback) => {\n        const compilerIdx = this.compilers.indexOf(compiler);\n        let firstRun = true;\n        let watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[compilerIdx] : watchOptions, (err, stats) => {\n          if (err) handler(err);\n\n          if (stats) {\n            allStats[compilerIdx] = stats;\n            compilerStatus[compilerIdx] = \"new\";\n\n            if (compilerStatus.every(Boolean)) {\n              const freshStats = allStats.filter((s, idx) => {\n                return compilerStatus[idx] === \"new\";\n              });\n              compilerStatus.fill(true);\n              const multiStats = new MultiStats(freshStats);\n              handler(null, multiStats);\n            }\n          }\n\n          if (firstRun && !err) {\n            firstRun = false;\n            callback();\n          }\n        });\n        watchings.push(watching);\n      }, () => {// ignore\n      });\n    }\n\n    return new MultiWatching(watchings, this);\n  }\n\n  run(callback) {\n    if (this.running) {\n      return callback(new ConcurrentCompilationError());\n    }\n\n    const finalCallback = (err, stats) => {\n      this.running = false;\n\n      if (callback !== undefined) {\n        return callback(err, stats);\n      }\n    };\n\n    const allStats = this.compilers.map(() => null);\n\n    if (this.validateDependencies(callback)) {\n      this.running = true;\n      this.runWithDependencies(this.compilers, (compiler, callback) => {\n        const compilerIdx = this.compilers.indexOf(compiler);\n        compiler.run((err, stats) => {\n          if (err) {\n            return callback(err);\n          }\n\n          allStats[compilerIdx] = stats;\n          callback();\n        });\n      }, err => {\n        if (err) {\n          return finalCallback(err);\n        }\n\n        finalCallback(null, new MultiStats(allStats));\n      });\n    }\n  }\n\n  purgeInputFileSystem() {\n    for (const compiler of this.compilers) {\n      if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n        compiler.inputFileSystem.purge();\n      }\n    }\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}