{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Queue = require(\"../util/Queue\");\n\nconst _require = require(\"../util/SetHelpers\"),\n      intersect = _require.intersect;\n\nconst getParentChunksWithModule = (currentChunk, module) => {\n  const chunks = [];\n  const stack = new Set(currentChunk.parentsIterable);\n\n  for (const chunk of stack) {\n    if (chunk.containsModule(module)) {\n      chunks.push(chunk);\n    } else {\n      for (const parent of chunk.parentsIterable) {\n        stack.add(parent);\n      }\n    }\n  }\n\n  return chunks;\n};\n\nclass RemoveParentModulesPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n      const handler = (chunks, chunkGroups) => {\n        const queue = new Queue();\n        const availableModulesMap = new WeakMap();\n\n        for (const chunkGroup of compilation.entrypoints.values()) {\n          // initialize available modules for chunks without parents\n          availableModulesMap.set(chunkGroup, new Set());\n\n          for (const child of chunkGroup.childrenIterable) {\n            queue.enqueue(child);\n          }\n        }\n\n        while (queue.length > 0) {\n          const chunkGroup = queue.dequeue();\n          let availableModules = availableModulesMap.get(chunkGroup);\n          let changed = false;\n\n          for (const parent of chunkGroup.parentsIterable) {\n            const availableModulesInParent = availableModulesMap.get(parent);\n\n            if (availableModulesInParent !== undefined) {\n              // If we know the available modules in parent: process these\n              if (availableModules === undefined) {\n                // if we have not own info yet: create new entry\n                availableModules = new Set(availableModulesInParent);\n\n                for (const chunk of parent.chunks) {\n                  for (const m of chunk.modulesIterable) {\n                    availableModules.add(m);\n                  }\n                }\n\n                availableModulesMap.set(chunkGroup, availableModules);\n                changed = true;\n              } else {\n                for (const m of availableModules) {\n                  if (!parent.containsModule(m) && !availableModulesInParent.has(m)) {\n                    availableModules.delete(m);\n                    changed = true;\n                  }\n                }\n              }\n            }\n          }\n\n          if (changed) {\n            // if something changed: enqueue our children\n            for (const child of chunkGroup.childrenIterable) {\n              queue.enqueue(child);\n            }\n          }\n        } // now we have available modules for every chunk\n\n\n        for (const chunk of chunks) {\n          const availableModulesSets = Array.from(chunk.groupsIterable, chunkGroup => availableModulesMap.get(chunkGroup));\n          if (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n\n          const availableModules = availableModulesSets.length === 1 ? availableModulesSets[0] : intersect(availableModulesSets);\n          const numberOfModules = chunk.getNumberOfModules();\n          const toRemove = new Set();\n\n          if (numberOfModules < availableModules.size) {\n            for (const m of chunk.modulesIterable) {\n              if (availableModules.has(m)) {\n                toRemove.add(m);\n              }\n            }\n          } else {\n            for (const m of availableModules) {\n              if (chunk.containsModule(m)) {\n                toRemove.add(m);\n              }\n            }\n          }\n\n          for (const module of toRemove) {\n            module.rewriteChunkInReasons(chunk, getParentChunksWithModule(chunk, module));\n            chunk.removeModule(module);\n          }\n        }\n      };\n\n      compilation.hooks.optimizeChunksBasic.tap(\"RemoveParentModulesPlugin\", handler);\n      compilation.hooks.optimizeExtractedChunksBasic.tap(\"RemoveParentModulesPlugin\", handler);\n    });\n  }\n\n}\n\nmodule.exports = RemoveParentModulesPlugin;","map":null,"metadata":{},"sourceType":"script"}