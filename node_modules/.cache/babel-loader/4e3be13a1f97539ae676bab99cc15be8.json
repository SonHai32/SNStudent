{"ast":null,"code":"\"use strict\"; // Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\n\nconst similarity = (a, b) => {\n  const l = Math.min(a.length, b.length);\n  let dist = 0;\n\n  for (let i = 0; i < l; i++) {\n    const ca = a.charCodeAt(i);\n    const cb = b.charCodeAt(i);\n    dist += Math.max(0, 10 - Math.abs(ca - cb));\n  }\n\n  return dist;\n};\n/**\n * @param {string} a key\n * @param {string} b key\n * @returns {string} the common part and a single char for the difference\n */\n\n\nconst getName = (a, b) => {\n  const l = Math.min(a.length, b.length);\n  let r = \"\";\n\n  for (let i = 0; i < l; i++) {\n    const ca = a.charAt(i);\n    const cb = b.charAt(i);\n    r += ca;\n\n    if (ca === cb) {\n      continue;\n    }\n\n    return r;\n  }\n\n  return a;\n};\n/**\n * @template T\n */\n\n\nclass Node {\n  /**\n   * @param {T} item item\n   * @param {string} key key\n   * @param {number} size size\n   */\n  constructor(item, key, size) {\n    this.item = item;\n    this.key = key;\n    this.size = size;\n  }\n\n}\n/**\n * @template T\n */\n\n\nclass Group {\n  /**\n   * @param {Node<T>[]} nodes nodes\n   * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n   */\n  constructor(nodes, similarities) {\n    this.nodes = nodes;\n    this.similarities = similarities;\n    this.size = nodes.reduce((size, node) => size + node.size, 0);\n    /** @type {string} */\n\n    this.key = undefined;\n  }\n\n}\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {number} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {number} maxSize maximum size of a group\n * @property {number} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): number} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\n\n\nmodule.exports = ({\n  maxSize,\n  minSize,\n  items,\n  getSize,\n  getKey\n}) => {\n  /** @type {Group<T>[]} */\n  const result = [];\n  const nodes = Array.from(items, item => new Node(item, getKey(item), getSize(item)));\n  /** @type {Node<T>[]} */\n\n  const initialNodes = []; // lexically ordering of keys\n\n  nodes.sort((a, b) => {\n    if (a.key < b.key) return -1;\n    if (a.key > b.key) return 1;\n    return 0;\n  }); // return nodes bigger than maxSize directly as group\n\n  for (const node of nodes) {\n    if (node.size >= maxSize) {\n      result.push(new Group([node], []));\n    } else {\n      initialNodes.push(node);\n    }\n  }\n\n  if (initialNodes.length > 0) {\n    // calculate similarities between lexically adjacent nodes\n\n    /** @type {number[]} */\n    const similarities = [];\n\n    for (let i = 1; i < initialNodes.length; i++) {\n      const a = initialNodes[i - 1];\n      const b = initialNodes[i];\n      similarities.push(similarity(a.key, b.key));\n    }\n\n    const initialGroup = new Group(initialNodes, similarities);\n\n    if (initialGroup.size < minSize) {\n      // We hit an edgecase where the working set is already smaller than minSize\n      // We merge it with the smallest result node to keep minSize intact\n      if (result.length > 0) {\n        const smallestGroup = result.reduce((min, group) => min.size > group.size ? group : min);\n\n        for (const node of initialGroup.nodes) smallestGroup.nodes.push(node);\n\n        smallestGroup.nodes.sort((a, b) => {\n          if (a.key < b.key) return -1;\n          if (a.key > b.key) return 1;\n          return 0;\n        });\n      } else {\n        // There are no other nodes\n        // We use all nodes and have to accept that it's smaller than minSize\n        result.push(initialGroup);\n      }\n    } else {\n      const queue = [initialGroup];\n\n      while (queue.length) {\n        const group = queue.pop(); // only groups bigger than maxSize need to be splitted\n\n        if (group.size < maxSize) {\n          result.push(group);\n          continue;\n        } // find unsplittable area from left and right\n        // going minSize from left and right\n        // at least one node need to be included otherwise we get stuck\n\n\n        let left = 0;\n        let leftSize = 0;\n\n        while (leftSize <= minSize) {\n          leftSize += group.nodes[left].size;\n          left++;\n        }\n\n        let right = group.nodes.length - 1;\n        let rightSize = 0;\n\n        while (rightSize <= minSize) {\n          rightSize += group.nodes[right].size;\n          right--;\n        }\n\n        if (left - 1 > right) {\n          // can't split group while holding minSize\n          // because minSize is preferred of maxSize we return\n          // the group here even while it's too big\n          // To avoid this make sure maxSize > minSize * 3\n          result.push(group);\n          continue;\n        }\n\n        if (left <= right) {\n          // when there is a area between left and right\n          // we look for best split point\n          // we split at the minimum similarity\n          // here key space is separated the most\n          let best = left - 1;\n          let bestSimilarity = group.similarities[best];\n\n          for (let i = left; i <= right; i++) {\n            const similarity = group.similarities[i];\n\n            if (similarity < bestSimilarity) {\n              best = i;\n              bestSimilarity = similarity;\n            }\n          }\n\n          left = best + 1;\n          right = best;\n        } // create two new groups for left and right area\n        // and queue them up\n\n\n        const rightNodes = [group.nodes[right + 1]];\n        /** @type {number[]} */\n\n        const rightSimilaries = [];\n\n        for (let i = right + 2; i < group.nodes.length; i++) {\n          rightSimilaries.push(group.similarities[i - 1]);\n          rightNodes.push(group.nodes[i]);\n        }\n\n        queue.push(new Group(rightNodes, rightSimilaries));\n        const leftNodes = [group.nodes[0]];\n        /** @type {number[]} */\n\n        const leftSimilaries = [];\n\n        for (let i = 1; i < left; i++) {\n          leftSimilaries.push(group.similarities[i - 1]);\n          leftNodes.push(group.nodes[i]);\n        }\n\n        queue.push(new Group(leftNodes, leftSimilaries));\n      }\n    }\n  } // lexically ordering\n\n\n  result.sort((a, b) => {\n    if (a.nodes[0].key < b.nodes[0].key) return -1;\n    if (a.nodes[0].key > b.nodes[0].key) return 1;\n    return 0;\n  }); // give every group a name\n\n  for (let i = 0; i < result.length; i++) {\n    const group = result[i];\n    const first = group.nodes[0];\n    const last = group.nodes[group.nodes.length - 1];\n    let name = getName(first.key, last.key);\n    group.key = name;\n  } // return the results\n\n\n  return result.map(group => {\n    /** @type {GroupedItems} */\n    return {\n      key: group.key,\n      items: group.nodes.map(node => node.item),\n      size: group.size\n    };\n  });\n};","map":null,"metadata":{},"sourceType":"script"}