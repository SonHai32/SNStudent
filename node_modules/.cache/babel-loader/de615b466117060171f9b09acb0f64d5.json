{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/home/hari/Desktop/web-dev/React/cstudy/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\n\nconst GraphHelpers = require(\"./GraphHelpers\");\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Compilation\")} Compilation */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group\n */\n\n/**\n * @typedef {Object} ChunkGroupDep\n * @property {AsyncDependenciesBlock} block referencing block\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\n\n\nconst bySetSize = (a, b) => {\n  return b.size - a.size;\n};\n/**\n * Extracts simplified info from the modules and their dependencies\n * @param {Compilation} compilation the compilation\n * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks\n */\n\n\nconst extraceBlockInfoMap = compilation => {\n  /** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */\n  const blockInfoMap = new Map();\n  /**\n   * @param {Dependency} d dependency to iterate over\n   * @returns {void}\n   */\n\n  const iteratorDependency = d => {\n    // We skip Dependencies without Reference\n    const ref = compilation.getDependencyReference(currentModule, d);\n\n    if (!ref) {\n      return;\n    } // We skip Dependencies without Module pointer\n\n\n    const refModule = ref.module;\n\n    if (!refModule) {\n      return;\n    } // We skip weak Dependencies\n\n\n    if (ref.weak) {\n      return;\n    }\n\n    blockInfoModules.add(refModule);\n  };\n  /**\n   * @param {AsyncDependenciesBlock} b blocks to prepare\n   * @returns {void}\n   */\n\n\n  const iteratorBlockPrepare = b => {\n    blockInfoBlocks.push(b);\n    blockQueue.push(b);\n  };\n  /** @type {Module} */\n\n\n  let currentModule;\n  /** @type {DependenciesBlock} */\n\n  let block;\n  /** @type {DependenciesBlock[]} */\n\n  let blockQueue;\n  /** @type {Set<Module>} */\n\n  let blockInfoModules;\n  /** @type {AsyncDependenciesBlock[]} */\n\n  let blockInfoBlocks;\n\n  for (const module of compilation.modules) {\n    blockQueue = [module];\n    currentModule = module;\n\n    while (blockQueue.length > 0) {\n      block = blockQueue.pop();\n      blockInfoModules = new Set();\n      blockInfoBlocks = [];\n\n      if (block.variables) {\n        for (const variable of block.variables) {\n          for (const dep of variable.dependencies) iteratorDependency(dep);\n        }\n      }\n\n      if (block.dependencies) {\n        for (const dep of block.dependencies) iteratorDependency(dep);\n      }\n\n      if (block.blocks) {\n        for (const b of block.blocks) iteratorBlockPrepare(b);\n      }\n\n      const blockInfo = {\n        modules: blockInfoModules,\n        blocks: blockInfoBlocks\n      };\n      blockInfoMap.set(block, blockInfo);\n    }\n  }\n\n  return blockInfoMap;\n};\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups input groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<ChunkGroup, ChunkGroupDep[]>} chunkDependencies dependencies for chunk groups\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\n\n\nconst visitModules = (compilation, inputChunkGroups, chunkGroupInfoMap, chunkDependencies, blocksWithNestedBlocks, allCreatedChunkGroups) => {\n  const logger = compilation.getLogger(\"webpack.buildChunkGraph.visitModules\");\n  const namedChunkGroups = compilation.namedChunkGroups;\n  logger.time(\"prepare\");\n  const blockInfoMap = extraceBlockInfoMap(compilation);\n  /** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n\n  const chunkGroupCounters = new Map();\n\n  for (const chunkGroup of inputChunkGroups) {\n    chunkGroupCounters.set(chunkGroup, {\n      index: 0,\n      index2: 0\n    });\n  }\n\n  let nextFreeModuleIndex = 0;\n  let nextFreeModuleIndex2 = 0;\n  /** @type {Map<DependenciesBlock, ChunkGroup>} */\n\n  const blockChunkGroups = new Map();\n  const ADD_AND_ENTER_MODULE = 0;\n  const ENTER_MODULE = 1;\n  const PROCESS_BLOCK = 2;\n  const LEAVE_MODULE = 3;\n  /**\n   * @param {QueueItem[]} queue the queue array (will be mutated)\n   * @param {ChunkGroup} chunkGroup chunk group\n   * @returns {QueueItem[]} the queue array again\n   */\n\n  const reduceChunkGroupToQueueItem = (queue, chunkGroup) => {\n    for (const chunk of chunkGroup.chunks) {\n      const module = chunk.entryModule;\n      queue.push({\n        action: ENTER_MODULE,\n        block: module,\n        module,\n        chunk,\n        chunkGroup\n      });\n    }\n\n    chunkGroupInfoMap.set(chunkGroup, {\n      minAvailableModules: new Set(),\n      minAvailableModulesOwned: true,\n      availableModulesToBeMerged: [],\n      skippedItems: [],\n      resultingAvailableModules: undefined\n    });\n    return queue;\n  }; // Start with the provided modules/chunks\n\n  /** @type {QueueItem[]} */\n\n\n  let queue = inputChunkGroups.reduce(reduceChunkGroupToQueueItem, []).reverse();\n  /** @type {Map<ChunkGroup, Set<ChunkGroup>>} */\n\n  const queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n\n  const outdatedChunkGroupInfo = new Set();\n  /** @type {QueueItem[]} */\n\n  let queueDelayed = [];\n  logger.timeEnd(\"prepare\");\n  /** @type {Module} */\n\n  let module;\n  /** @type {Chunk} */\n\n  let chunk;\n  /** @type {ChunkGroup} */\n\n  let chunkGroup;\n  /** @type {DependenciesBlock} */\n\n  let block;\n  /** @type {Set<Module>} */\n\n  let minAvailableModules;\n  /** @type {QueueItem[]} */\n\n  let skippedItems; // For each async Block in graph\n\n  /**\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n   * @returns {void}\n   */\n\n  const iteratorBlock = b => {\n    // 1. We create a chunk for this Block\n    // but only once (blockChunkGroups map)\n    let c = blockChunkGroups.get(b);\n\n    if (c === undefined) {\n      c = namedChunkGroups.get(b.chunkName);\n\n      if (c && c.isInitial()) {\n        compilation.errors.push(new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc));\n        c = chunkGroup;\n      } else {\n        c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n        chunkGroupCounters.set(c, {\n          index: 0,\n          index2: 0\n        });\n        blockChunkGroups.set(b, c);\n        allCreatedChunkGroups.add(c);\n      }\n    } else {\n      // TODO webpack 5 remove addOptions check\n      if (c.addOptions) c.addOptions(b.groupOptions);\n      c.addOrigin(module, b.loc, b.request);\n    } // 2. We store the Block+Chunk mapping as dependency for the chunk\n\n\n    let deps = chunkDependencies.get(chunkGroup);\n    if (!deps) chunkDependencies.set(chunkGroup, deps = []);\n    deps.push({\n      block: b,\n      chunkGroup: c\n    }); // 3. We create/update the chunk group info\n\n    let connectList = queueConnect.get(chunkGroup);\n\n    if (connectList === undefined) {\n      connectList = new Set();\n      queueConnect.set(chunkGroup, connectList);\n    }\n\n    connectList.add(c); // 4. We enqueue the DependenciesBlock for traversal\n\n    queueDelayed.push({\n      action: PROCESS_BLOCK,\n      block: b,\n      module: module,\n      chunk: c.chunks[0],\n      chunkGroup: c\n    });\n  }; // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n\n\n  while (queue.length) {\n    logger.time(\"visiting\");\n\n    while (queue.length) {\n      const queueItem = queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n\n      if (chunkGroup !== queueItem.chunkGroup) {\n        chunkGroup = queueItem.chunkGroup;\n        const chunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);\n        minAvailableModules = chunkGroupInfo.minAvailableModules;\n        skippedItems = chunkGroupInfo.skippedItems;\n      }\n\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_MODULE:\n          {\n            if (minAvailableModules.has(module)) {\n              // already in parent chunks\n              // skip it for now, but enqueue for rechecking when minAvailableModules shrinks\n              skippedItems.push(queueItem);\n              break;\n            } // We connect Module and Chunk when not already done\n\n\n            if (chunk.addModule(module)) {\n              module.addChunk(chunk);\n            } else {\n              // already connected, skip it\n              break;\n            }\n          }\n        // fallthrough\n\n        case ENTER_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              const index = chunkGroup.getModuleIndex(module);\n\n              if (index === undefined) {\n                chunkGroup.setModuleIndex(module, chunkGroupCounters.get(chunkGroup).index++);\n              }\n            }\n\n            if (module.index === null) {\n              module.index = nextFreeModuleIndex++;\n            }\n\n            queue.push({\n              action: LEAVE_MODULE,\n              block,\n              module,\n              chunk,\n              chunkGroup\n            });\n          }\n        // fallthrough\n\n        case PROCESS_BLOCK:\n          {\n            // get prepared block info\n            const blockInfo = blockInfoMap.get(block); // Buffer items because order need to be reverse to get indicies correct\n\n            const skipBuffer = [];\n            const queueBuffer = []; // Traverse all referenced modules\n\n            for (const refModule of blockInfo.modules) {\n              if (chunk.containsModule(refModule)) {\n                // skip early if already connected\n                continue;\n              }\n\n              if (minAvailableModules.has(refModule)) {\n                // already in parent chunks, skip it for now\n                skipBuffer.push({\n                  action: ADD_AND_ENTER_MODULE,\n                  block: refModule,\n                  module: refModule,\n                  chunk,\n                  chunkGroup\n                });\n                continue;\n              } // enqueue the add and enter to enter in the correct order\n              // this is relevant with circular dependencies\n\n\n              queueBuffer.push({\n                action: ADD_AND_ENTER_MODULE,\n                block: refModule,\n                module: refModule,\n                chunk,\n                chunkGroup\n              });\n            } // Add buffered items in reversed order\n\n\n            for (let i = skipBuffer.length - 1; i >= 0; i--) {\n              skippedItems.push(skipBuffer[i]);\n            }\n\n            for (let i = queueBuffer.length - 1; i >= 0; i--) {\n              queue.push(queueBuffer[i]);\n            } // Traverse all Blocks\n\n\n            for (const block of blockInfo.blocks) iteratorBlock(block);\n\n            if (blockInfo.blocks.length > 0 && module !== block) {\n              blocksWithNestedBlocks.add(block);\n            }\n\n            break;\n          }\n\n        case LEAVE_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              const index = chunkGroup.getModuleIndex2(module);\n\n              if (index === undefined) {\n                chunkGroup.setModuleIndex2(module, chunkGroupCounters.get(chunkGroup).index2++);\n              }\n            }\n\n            if (module.index2 === null) {\n              module.index2 = nextFreeModuleIndex2++;\n            }\n\n            break;\n          }\n      }\n    }\n\n    logger.timeEnd(\"visiting\");\n\n    if (queueConnect.size > 0) {\n      logger.time(\"calculating available modules\"); // Figure out new parents for chunk groups\n      // to get new available modules for these children\n\n      for (const _ref of queueConnect) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        const chunkGroup = _ref2[0];\n        const targets = _ref2[1];\n        const info = chunkGroupInfoMap.get(chunkGroup);\n        let minAvailableModules = info.minAvailableModules; // 1. Create a new Set of available modules at this points\n\n        const resultingAvailableModules = new Set(minAvailableModules);\n\n        for (const chunk of chunkGroup.chunks) {\n          for (const m of chunk.modulesIterable) {\n            resultingAvailableModules.add(m);\n          }\n        }\n\n        info.resultingAvailableModules = resultingAvailableModules; // 2. Update chunk group info\n\n        for (const target of targets) {\n          let chunkGroupInfo = chunkGroupInfoMap.get(target);\n\n          if (chunkGroupInfo === undefined) {\n            chunkGroupInfo = {\n              minAvailableModules: undefined,\n              minAvailableModulesOwned: undefined,\n              availableModulesToBeMerged: [],\n              skippedItems: [],\n              resultingAvailableModules: undefined\n            };\n            chunkGroupInfoMap.set(target, chunkGroupInfo);\n          }\n\n          chunkGroupInfo.availableModulesToBeMerged.push(resultingAvailableModules);\n          outdatedChunkGroupInfo.add(chunkGroupInfo);\n        }\n      }\n\n      queueConnect.clear();\n      logger.timeEnd(\"calculating available modules\");\n\n      if (outdatedChunkGroupInfo.size > 0) {\n        logger.time(\"merging available modules\"); // Execute the merge\n\n        for (const info of outdatedChunkGroupInfo) {\n          const availableModulesToBeMerged = info.availableModulesToBeMerged;\n          let minAvailableModules = info.minAvailableModules; // 1. Get minimal available modules\n          // It doesn't make sense to traverse a chunk again with more available modules.\n          // This step calculates the minimal available modules and skips traversal when\n          // the list didn't shrink.\n\n          if (availableModulesToBeMerged.length > 1) {\n            availableModulesToBeMerged.sort(bySetSize);\n          }\n\n          let changed = false;\n\n          for (const availableModules of availableModulesToBeMerged) {\n            if (minAvailableModules === undefined) {\n              minAvailableModules = availableModules;\n              info.minAvailableModules = minAvailableModules;\n              info.minAvailableModulesOwned = false;\n              changed = true;\n            } else {\n              if (info.minAvailableModulesOwned) {\n                // We own it and can modify it\n                for (const m of minAvailableModules) {\n                  if (!availableModules.has(m)) {\n                    minAvailableModules.delete(m);\n                    changed = true;\n                  }\n                }\n              } else {\n                for (const m of minAvailableModules) {\n                  if (!availableModules.has(m)) {\n                    // minAvailableModules need to be modified\n                    // but we don't own it\n                    // construct a new Set as intersection of minAvailableModules and availableModules\n\n                    /** @type {Set<Module>} */\n                    const newSet = new Set();\n                    const iterator = minAvailableModules[Symbol.iterator]();\n                    /** @type {IteratorResult<Module>} */\n\n                    let it;\n\n                    while (!(it = iterator.next()).done) {\n                      const module = it.value;\n                      if (module === m) break;\n                      newSet.add(module);\n                    }\n\n                    while (!(it = iterator.next()).done) {\n                      const module = it.value;\n\n                      if (availableModules.has(module)) {\n                        newSet.add(module);\n                      }\n                    }\n\n                    minAvailableModules = newSet;\n                    info.minAvailableModulesOwned = true;\n                    info.minAvailableModules = newSet;\n                    changed = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          availableModulesToBeMerged.length = 0;\n          if (!changed) continue; // 2. Reconsider skipped items\n\n          for (const queueItem of info.skippedItems) {\n            queue.push(queueItem);\n          }\n\n          info.skippedItems.length = 0;\n        }\n\n        outdatedChunkGroupInfo.clear();\n        logger.timeEnd(\"merging available modules\");\n      }\n    } // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indicing correct\n    // Async blocks should be processed after all sync blocks are processed\n\n\n    if (queue.length === 0) {\n      const tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n};\n/**\n *\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<ChunkGroup, ChunkGroupDep[]>} chunkDependencies dependencies for chunk groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\n\n\nconst connectChunkGroups = (blocksWithNestedBlocks, chunkDependencies, chunkGroupInfoMap) => {\n  /** @type {Set<Module>} */\n  let resultingAvailableModules;\n  /**\n   * Helper function to check if all modules of a chunk are available\n   *\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n   * @param {Set<Module>} availableModules the comparitor set\n   * @returns {boolean} return true if all modules of a chunk are available\n   */\n\n  const areModulesAvailable = (chunkGroup, availableModules) => {\n    for (const chunk of chunkGroup.chunks) {\n      for (const module of chunk.modulesIterable) {\n        if (!availableModules.has(module)) return false;\n      }\n    }\n\n    return true;\n  }; // For each edge in the basic chunk graph\n\n  /**\n   * @param {ChunkGroupDep} dep the dependency used for filtering\n   * @returns {boolean} used to filter \"edges\" (aka Dependencies) that were pointing\n   * to modules that are already available. Also filters circular dependencies in the chunks graph\n   */\n\n\n  const filterFn = dep => {\n    const depChunkGroup = dep.chunkGroup; // TODO is this needed?\n\n    if (blocksWithNestedBlocks.has(dep.block)) return true;\n\n    if (areModulesAvailable(depChunkGroup, resultingAvailableModules)) {\n      return false; // break all modules are already available\n    }\n\n    return true;\n  }; // For all deps, check if chunk groups need to be connected\n\n\n  for (const _ref3 of chunkDependencies) {\n    var _ref4 = _slicedToArray(_ref3, 2);\n\n    const chunkGroup = _ref4[0];\n    const deps = _ref4[1];\n    if (deps.length === 0) continue; // 1. Get info from chunk group info map\n\n    const info = chunkGroupInfoMap.get(chunkGroup);\n    resultingAvailableModules = info.resultingAvailableModules; // 2. Foreach edge\n\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i]; // Filter inline, rather than creating a new array from `.filter()`\n      // TODO check if inlining filterFn makes sense here\n\n      if (!filterFn(dep)) {\n        continue;\n      }\n\n      const depChunkGroup = dep.chunkGroup;\n      const depBlock = dep.block; // 5. Connect block with chunk\n\n      GraphHelpers.connectDependenciesBlockAndChunkGroup(depBlock, depChunkGroup); // 6. Connect chunk with parent\n\n      GraphHelpers.connectChunkGroupParentAndChild(chunkGroup, depChunkGroup);\n    }\n  }\n};\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\n\n\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n  for (const chunkGroup of allCreatedChunkGroups) {\n    if (chunkGroup.getNumberOfParents() === 0) {\n      for (const chunk of chunkGroup.chunks) {\n        const idx = compilation.chunks.indexOf(chunk);\n        if (idx >= 0) compilation.chunks.splice(idx, 1);\n        chunk.remove(\"unconnected\");\n      }\n\n      chunkGroup.remove(\"unconnected\");\n    }\n  }\n};\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed\n * @returns {void}\n */\n\n\nconst buildChunkGraph = (compilation, inputChunkGroups) => {\n  // SHARED STATE\n\n  /** @type {Map<ChunkGroup, ChunkGroupDep[]>} */\n  const chunkDependencies = new Map();\n  /** @type {Set<ChunkGroup>} */\n\n  const allCreatedChunkGroups = new Set();\n  /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\n  const chunkGroupInfoMap = new Map();\n  /** @type {Set<DependenciesBlock>} */\n\n  const blocksWithNestedBlocks = new Set(); // PART ONE\n\n  visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, chunkDependencies, blocksWithNestedBlocks, allCreatedChunkGroups); // PART TWO\n\n  connectChunkGroups(blocksWithNestedBlocks, chunkDependencies, chunkGroupInfoMap); // Cleaup work\n\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n};\n\nmodule.exports = buildChunkGraph;","map":null,"metadata":{},"sourceType":"script"}