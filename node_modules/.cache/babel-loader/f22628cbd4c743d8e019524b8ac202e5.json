{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nclass Storage {\n  constructor(duration) {\n    this.duration = duration;\n    this.running = new Map();\n    this.data = new Map();\n    this.levels = [];\n\n    if (duration > 0) {\n      this.levels.push(new Set(), new Set(), new Set(), new Set(), new Set(), new Set(), new Set(), new Set(), new Set());\n\n      for (let i = 8000; i < duration; i += 500) this.levels.push(new Set());\n    }\n\n    this.count = 0;\n    this.interval = null;\n    this.needTickCheck = false;\n    this.nextTick = null;\n    this.passive = true;\n    this.tick = this.tick.bind(this);\n  }\n\n  ensureTick() {\n    if (!this.interval && this.duration > 0 && !this.nextTick) this.interval = setInterval(this.tick, Math.floor(this.duration / this.levels.length));\n  }\n\n  finished(name, err, result) {\n    const callbacks = this.running.get(name);\n    this.running.delete(name);\n\n    if (this.duration > 0) {\n      this.data.set(name, [err, result]);\n      const levelData = this.levels[0];\n      this.count -= levelData.size;\n      levelData.add(name);\n      this.count += levelData.size;\n      this.ensureTick();\n    }\n\n    for (let i = 0; i < callbacks.length; i++) {\n      callbacks[i](err, result);\n    }\n  }\n\n  finishedSync(name, err, result) {\n    if (this.duration > 0) {\n      this.data.set(name, [err, result]);\n      const levelData = this.levels[0];\n      this.count -= levelData.size;\n      levelData.add(name);\n      this.count += levelData.size;\n      this.ensureTick();\n    }\n  }\n\n  provide(name, provider, callback) {\n    if (typeof name !== \"string\") {\n      callback(new TypeError(\"path must be a string\"));\n      return;\n    }\n\n    let running = this.running.get(name);\n\n    if (running) {\n      running.push(callback);\n      return;\n    }\n\n    if (this.duration > 0) {\n      this.checkTicks();\n      const data = this.data.get(name);\n\n      if (data) {\n        return process.nextTick(() => {\n          callback.apply(null, data);\n        });\n      }\n    }\n\n    this.running.set(name, running = [callback]);\n    provider(name, (err, result) => {\n      this.finished(name, err, result);\n    });\n  }\n\n  provideSync(name, provider) {\n    if (typeof name !== \"string\") {\n      throw new TypeError(\"path must be a string\");\n    }\n\n    if (this.duration > 0) {\n      this.checkTicks();\n      const data = this.data.get(name);\n\n      if (data) {\n        if (data[0]) throw data[0];\n        return data[1];\n      }\n    }\n\n    let result;\n\n    try {\n      result = provider(name);\n    } catch (e) {\n      this.finishedSync(name, e);\n      throw e;\n    }\n\n    this.finishedSync(name, null, result);\n    return result;\n  }\n\n  tick() {\n    const decay = this.levels.pop();\n\n    for (let item of decay) {\n      this.data.delete(item);\n    }\n\n    this.count -= decay.size;\n    decay.clear();\n    this.levels.unshift(decay);\n\n    if (this.count === 0) {\n      clearInterval(this.interval);\n      this.interval = null;\n      this.nextTick = null;\n      return true;\n    } else if (this.nextTick) {\n      this.nextTick += Math.floor(this.duration / this.levels.length);\n      const time = new Date().getTime();\n\n      if (this.nextTick > time) {\n        this.nextTick = null;\n        this.interval = setInterval(this.tick, Math.floor(this.duration / this.levels.length));\n        return true;\n      }\n    } else if (this.passive) {\n      clearInterval(this.interval);\n      this.interval = null;\n      this.nextTick = new Date().getTime() + Math.floor(this.duration / this.levels.length);\n    } else {\n      this.passive = true;\n    }\n  }\n\n  checkTicks() {\n    this.passive = false;\n\n    if (this.nextTick) {\n      while (!this.tick());\n    }\n  }\n\n  purge(what) {\n    if (!what) {\n      this.count = 0;\n      clearInterval(this.interval);\n      this.nextTick = null;\n      this.data.clear();\n      this.levels.forEach(level => {\n        level.clear();\n      });\n    } else if (typeof what === \"string\") {\n      for (let key of this.data.keys()) {\n        if (key.startsWith(what)) this.data.delete(key);\n      }\n    } else {\n      for (let i = what.length - 1; i >= 0; i--) {\n        this.purge(what[i]);\n      }\n    }\n  }\n\n}\n\nmodule.exports = class CachedInputFileSystem {\n  constructor(fileSystem, duration) {\n    this.fileSystem = fileSystem;\n    this._statStorage = new Storage(duration);\n    this._readdirStorage = new Storage(duration);\n    this._readFileStorage = new Storage(duration);\n    this._readJsonStorage = new Storage(duration);\n    this._readlinkStorage = new Storage(duration);\n    this._stat = this.fileSystem.stat ? this.fileSystem.stat.bind(this.fileSystem) : null;\n    if (!this._stat) this.stat = null;\n    this._statSync = this.fileSystem.statSync ? this.fileSystem.statSync.bind(this.fileSystem) : null;\n    if (!this._statSync) this.statSync = null;\n    this._readdir = this.fileSystem.readdir ? this.fileSystem.readdir.bind(this.fileSystem) : null;\n    if (!this._readdir) this.readdir = null;\n    this._readdirSync = this.fileSystem.readdirSync ? this.fileSystem.readdirSync.bind(this.fileSystem) : null;\n    if (!this._readdirSync) this.readdirSync = null;\n    this._readFile = this.fileSystem.readFile ? this.fileSystem.readFile.bind(this.fileSystem) : null;\n    if (!this._readFile) this.readFile = null;\n    this._readFileSync = this.fileSystem.readFileSync ? this.fileSystem.readFileSync.bind(this.fileSystem) : null;\n    if (!this._readFileSync) this.readFileSync = null;\n\n    if (this.fileSystem.readJson) {\n      this._readJson = this.fileSystem.readJson.bind(this.fileSystem);\n    } else if (this.readFile) {\n      this._readJson = (path, callback) => {\n        this.readFile(path, (err, buffer) => {\n          if (err) return callback(err);\n          let data;\n\n          try {\n            data = JSON.parse(buffer.toString(\"utf-8\"));\n          } catch (e) {\n            return callback(e);\n          }\n\n          callback(null, data);\n        });\n      };\n    } else {\n      this.readJson = null;\n    }\n\n    if (this.fileSystem.readJsonSync) {\n      this._readJsonSync = this.fileSystem.readJsonSync.bind(this.fileSystem);\n    } else if (this.readFileSync) {\n      this._readJsonSync = path => {\n        const buffer = this.readFileSync(path);\n        const data = JSON.parse(buffer.toString(\"utf-8\"));\n        return data;\n      };\n    } else {\n      this.readJsonSync = null;\n    }\n\n    this._readlink = this.fileSystem.readlink ? this.fileSystem.readlink.bind(this.fileSystem) : null;\n    if (!this._readlink) this.readlink = null;\n    this._readlinkSync = this.fileSystem.readlinkSync ? this.fileSystem.readlinkSync.bind(this.fileSystem) : null;\n    if (!this._readlinkSync) this.readlinkSync = null;\n  }\n\n  stat(path, callback) {\n    this._statStorage.provide(path, this._stat, callback);\n  }\n\n  readdir(path, callback) {\n    this._readdirStorage.provide(path, this._readdir, callback);\n  }\n\n  readFile(path, callback) {\n    this._readFileStorage.provide(path, this._readFile, callback);\n  }\n\n  readJson(path, callback) {\n    this._readJsonStorage.provide(path, this._readJson, callback);\n  }\n\n  readlink(path, callback) {\n    this._readlinkStorage.provide(path, this._readlink, callback);\n  }\n\n  statSync(path) {\n    return this._statStorage.provideSync(path, this._statSync);\n  }\n\n  readdirSync(path) {\n    return this._readdirStorage.provideSync(path, this._readdirSync);\n  }\n\n  readFileSync(path) {\n    return this._readFileStorage.provideSync(path, this._readFileSync);\n  }\n\n  readJsonSync(path) {\n    return this._readJsonStorage.provideSync(path, this._readJsonSync);\n  }\n\n  readlinkSync(path) {\n    return this._readlinkStorage.provideSync(path, this._readlinkSync);\n  }\n\n  purge(what) {\n    this._statStorage.purge(what);\n\n    this._readdirStorage.purge(what);\n\n    this._readFileStorage.purge(what);\n\n    this._readlinkStorage.purge(what);\n\n    this._readJsonStorage.purge(what);\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}