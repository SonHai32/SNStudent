{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\n\nconst schema = require(\"../../schemas/plugins/optimize/OccurrenceOrderModuleIdsPlugin.json\");\n/** @typedef {import(\"../../declarations/plugins/optimize/OccurrenceOrderModuleIdsPlugin\").OccurrenceOrderModuleIdsPluginOptions} OccurrenceOrderModuleIdsPluginOptions */\n\n\nclass OccurrenceOrderModuleIdsPlugin {\n  /**\n   * @param {OccurrenceOrderModuleIdsPluginOptions=} options options object\n   */\n  constructor(options = {}) {\n    validateOptions(schema, options, \"Occurrence Order Module Ids Plugin\");\n    this.options = options;\n  }\n\n  apply(compiler) {\n    const prioritiseInitial = this.options.prioritiseInitial;\n    compiler.hooks.compilation.tap(\"OccurrenceOrderModuleIdsPlugin\", compilation => {\n      compilation.hooks.optimizeModuleOrder.tap(\"OccurrenceOrderModuleIdsPlugin\", modules => {\n        const occursInInitialChunksMap = new Map();\n        const occursInAllChunksMap = new Map();\n        const initialChunkChunkMap = new Map();\n        const entryCountMap = new Map();\n\n        for (const m of modules) {\n          let initial = 0;\n          let entry = 0;\n\n          for (const c of m.chunksIterable) {\n            if (c.canBeInitial()) initial++;\n            if (c.entryModule === m) entry++;\n          }\n\n          initialChunkChunkMap.set(m, initial);\n          entryCountMap.set(m, entry);\n        }\n\n        const countOccursInEntry = (sum, r) => {\n          if (!r.module) {\n            return sum;\n          }\n\n          const count = initialChunkChunkMap.get(r.module);\n\n          if (!count) {\n            return sum;\n          }\n\n          return sum + count;\n        };\n\n        const countOccurs = (sum, r) => {\n          if (!r.module) {\n            return sum;\n          }\n\n          let factor = 1;\n\n          if (typeof r.dependency.getNumberOfIdOccurrences === \"function\") {\n            factor = r.dependency.getNumberOfIdOccurrences();\n          }\n\n          if (factor === 0) {\n            return sum;\n          }\n\n          return sum + factor * r.module.getNumberOfChunks();\n        };\n\n        if (prioritiseInitial) {\n          for (const m of modules) {\n            const result = m.reasons.reduce(countOccursInEntry, 0) + initialChunkChunkMap.get(m) + entryCountMap.get(m);\n            occursInInitialChunksMap.set(m, result);\n          }\n        }\n\n        const originalOrder = new Map();\n        let i = 0;\n\n        for (const m of modules) {\n          const result = m.reasons.reduce(countOccurs, 0) + m.getNumberOfChunks() + entryCountMap.get(m);\n          occursInAllChunksMap.set(m, result);\n          originalOrder.set(m, i++);\n        }\n\n        modules.sort((a, b) => {\n          if (prioritiseInitial) {\n            const aEntryOccurs = occursInInitialChunksMap.get(a);\n            const bEntryOccurs = occursInInitialChunksMap.get(b);\n            if (aEntryOccurs > bEntryOccurs) return -1;\n            if (aEntryOccurs < bEntryOccurs) return 1;\n          }\n\n          const aOccurs = occursInAllChunksMap.get(a);\n          const bOccurs = occursInAllChunksMap.get(b);\n          if (aOccurs > bOccurs) return -1;\n          if (aOccurs < bOccurs) return 1;\n          const orgA = originalOrder.get(a);\n          const orgB = originalOrder.get(b);\n          return orgA - orgB;\n        });\n      });\n    });\n  }\n\n}\n\nmodule.exports = OccurrenceOrderModuleIdsPlugin;","map":null,"metadata":{},"sourceType":"script"}