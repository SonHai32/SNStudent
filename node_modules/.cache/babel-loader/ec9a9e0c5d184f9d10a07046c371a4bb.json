{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/home/hari/Desktop/web-dev/React/cstudy/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst RequestShortener = require(\"./RequestShortener\");\n\nconst SizeFormatHelpers = require(\"./SizeFormatHelpers\");\n\nconst formatLocation = require(\"./formatLocation\");\n\nconst identifierUtils = require(\"./util/identifier\");\n\nconst compareLocations = require(\"./compareLocations\");\n\nconst _require = require(\"./logging/Logger\"),\n      LogType = _require.LogType;\n\nconst optionsOrFallback = (...args) => {\n  let optionValues = [];\n  optionValues.push(...args);\n  return optionValues.find(optionValue => optionValue !== undefined);\n};\n\nconst compareId = (a, b) => {\n  if (typeof a !== typeof b) {\n    return typeof a < typeof b ? -1 : 1;\n  }\n\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n};\n\nclass Stats {\n  constructor(compilation) {\n    this.compilation = compilation;\n    this.hash = compilation.hash;\n    this.startTime = undefined;\n    this.endTime = undefined;\n  }\n\n  static filterWarnings(warnings, warningsFilter) {\n    // we dont have anything to filter so all warnings can be shown\n    if (!warningsFilter) {\n      return warnings;\n    } // create a chain of filters\n    // if they return \"true\" a warning should be suppressed\n\n\n    const normalizedWarningsFilters = [].concat(warningsFilter).map(filter => {\n      if (typeof filter === \"string\") {\n        return warning => warning.includes(filter);\n      }\n\n      if (filter instanceof RegExp) {\n        return warning => filter.test(warning);\n      }\n\n      if (typeof filter === \"function\") {\n        return filter;\n      }\n\n      throw new Error(\"Can only filter warnings with Strings or RegExps. (Given: \".concat(filter, \")\"));\n    });\n    return warnings.filter(warning => {\n      return !normalizedWarningsFilters.some(check => check(warning));\n    });\n  }\n\n  formatFilePath(filePath) {\n    const OPTIONS_REGEXP = /^(\\s|\\S)*!/;\n    return filePath.includes(\"!\") ? \"\".concat(filePath.replace(OPTIONS_REGEXP, \"\"), \" (\").concat(filePath, \")\") : \"\".concat(filePath);\n  }\n\n  hasWarnings() {\n    return this.compilation.warnings.length > 0 || this.compilation.children.some(child => child.getStats().hasWarnings());\n  }\n\n  hasErrors() {\n    return this.compilation.errors.length > 0 || this.compilation.children.some(child => child.getStats().hasErrors());\n  } // remove a prefixed \"!\" that can be specified to reverse sort order\n\n\n  normalizeFieldKey(field) {\n    if (field[0] === \"!\") {\n      return field.substr(1);\n    }\n\n    return field;\n  } // if a field is prefixed by a \"!\" reverse sort order\n\n\n  sortOrderRegular(field) {\n    if (field[0] === \"!\") {\n      return false;\n    }\n\n    return true;\n  }\n\n  toJson(options, forToString) {\n    if (typeof options === \"boolean\" || typeof options === \"string\") {\n      options = Stats.presetToOptions(options);\n    } else if (!options) {\n      options = {};\n    }\n\n    const optionOrLocalFallback = (v, def) => v !== undefined ? v : options.all !== undefined ? options.all : def;\n\n    const testAgainstGivenOption = item => {\n      if (typeof item === \"string\") {\n        const regExp = new RegExp(\"[\\\\\\\\/]\".concat(item.replace( // eslint-disable-next-line no-useless-escape\n        /[-[\\]{}()*+?.\\\\^$|]/g, \"\\\\$&\"), \"([\\\\\\\\/]|$|!|\\\\?)\"));\n        return ident => regExp.test(ident);\n      }\n\n      if (item && typeof item === \"object\" && typeof item.test === \"function\") {\n        return ident => item.test(ident);\n      }\n\n      if (typeof item === \"function\") {\n        return item;\n      }\n\n      if (typeof item === \"boolean\") {\n        return () => item;\n      }\n    };\n\n    const compilation = this.compilation;\n    const context = optionsOrFallback(options.context, compilation.compiler.context);\n    const requestShortener = compilation.compiler.context === context ? compilation.requestShortener : new RequestShortener(context);\n    const showPerformance = optionOrLocalFallback(options.performance, true);\n    const showHash = optionOrLocalFallback(options.hash, true);\n    const showEnv = optionOrLocalFallback(options.env, false);\n    const showVersion = optionOrLocalFallback(options.version, true);\n    const showTimings = optionOrLocalFallback(options.timings, true);\n    const showBuiltAt = optionOrLocalFallback(options.builtAt, true);\n    const showAssets = optionOrLocalFallback(options.assets, true);\n    const showEntrypoints = optionOrLocalFallback(options.entrypoints, true);\n    const showChunkGroups = optionOrLocalFallback(options.chunkGroups, !forToString);\n    const showChunks = optionOrLocalFallback(options.chunks, !forToString);\n    const showChunkModules = optionOrLocalFallback(options.chunkModules, true);\n    const showChunkOrigins = optionOrLocalFallback(options.chunkOrigins, !forToString);\n    const showModules = optionOrLocalFallback(options.modules, true);\n    const showNestedModules = optionOrLocalFallback(options.nestedModules, true);\n    const showModuleAssets = optionOrLocalFallback(options.moduleAssets, !forToString);\n    const showDepth = optionOrLocalFallback(options.depth, !forToString);\n    const showCachedModules = optionOrLocalFallback(options.cached, true);\n    const showCachedAssets = optionOrLocalFallback(options.cachedAssets, true);\n    const showReasons = optionOrLocalFallback(options.reasons, !forToString);\n    const showUsedExports = optionOrLocalFallback(options.usedExports, !forToString);\n    const showProvidedExports = optionOrLocalFallback(options.providedExports, !forToString);\n    const showOptimizationBailout = optionOrLocalFallback(options.optimizationBailout, !forToString);\n    const showChildren = optionOrLocalFallback(options.children, true);\n    const showSource = optionOrLocalFallback(options.source, !forToString);\n    const showModuleTrace = optionOrLocalFallback(options.moduleTrace, true);\n    const showErrors = optionOrLocalFallback(options.errors, true);\n    const showErrorDetails = optionOrLocalFallback(options.errorDetails, !forToString);\n    const showWarnings = optionOrLocalFallback(options.warnings, true);\n    const warningsFilter = optionsOrFallback(options.warningsFilter, null);\n    const showPublicPath = optionOrLocalFallback(options.publicPath, !forToString);\n    const showLogging = optionOrLocalFallback(options.logging, forToString ? \"info\" : true);\n    const showLoggingTrace = optionOrLocalFallback(options.loggingTrace, !forToString);\n    const loggingDebug = [].concat(optionsOrFallback(options.loggingDebug, [])).map(testAgainstGivenOption);\n    const excludeModules = [].concat(optionsOrFallback(options.excludeModules, options.exclude, [])).map(testAgainstGivenOption);\n    const excludeAssets = [].concat(optionsOrFallback(options.excludeAssets, [])).map(testAgainstGivenOption);\n    const maxModules = optionsOrFallback(options.maxModules, forToString ? 15 : Infinity);\n    const sortModules = optionsOrFallback(options.modulesSort, \"id\");\n    const sortChunks = optionsOrFallback(options.chunksSort, \"id\");\n    const sortAssets = optionsOrFallback(options.assetsSort, \"\");\n    const showOutputPath = optionOrLocalFallback(options.outputPath, !forToString);\n\n    if (!showCachedModules) {\n      excludeModules.push((ident, module) => !module.built);\n    }\n\n    const createModuleFilter = () => {\n      let i = 0;\n      return module => {\n        if (excludeModules.length > 0) {\n          const ident = requestShortener.shorten(module.resource);\n          const excluded = excludeModules.some(fn => fn(ident, module));\n          if (excluded) return false;\n        }\n\n        const result = i < maxModules;\n        i++;\n        return result;\n      };\n    };\n\n    const createAssetFilter = () => {\n      return asset => {\n        if (excludeAssets.length > 0) {\n          const ident = asset.name;\n          const excluded = excludeAssets.some(fn => fn(ident, asset));\n          if (excluded) return false;\n        }\n\n        return showCachedAssets || asset.emitted;\n      };\n    };\n\n    const sortByFieldAndOrder = (fieldKey, a, b) => {\n      if (a[fieldKey] === null && b[fieldKey] === null) return 0;\n      if (a[fieldKey] === null) return 1;\n      if (b[fieldKey] === null) return -1;\n      if (a[fieldKey] === b[fieldKey]) return 0;\n      if (typeof a[fieldKey] !== typeof b[fieldKey]) return typeof a[fieldKey] < typeof b[fieldKey] ? -1 : 1;\n      return a[fieldKey] < b[fieldKey] ? -1 : 1;\n    };\n\n    const sortByField = (field, originalArray) => {\n      const originalMap = originalArray.reduce((map, v, i) => {\n        map.set(v, i);\n        return map;\n      }, new Map());\n      return (a, b) => {\n        if (field) {\n          const fieldKey = this.normalizeFieldKey(field); // if a field is prefixed with a \"!\" the sort is reversed!\n\n          const sortIsRegular = this.sortOrderRegular(field);\n          const cmp = sortByFieldAndOrder(fieldKey, sortIsRegular ? a : b, sortIsRegular ? b : a);\n          if (cmp) return cmp;\n        }\n\n        return originalMap.get(a) - originalMap.get(b);\n      };\n    };\n\n    const formatError = e => {\n      let text = \"\";\n\n      if (typeof e === \"string\") {\n        e = {\n          message: e\n        };\n      }\n\n      if (e.chunk) {\n        text += \"chunk \".concat(e.chunk.name || e.chunk.id).concat(e.chunk.hasRuntime() ? \" [entry]\" : e.chunk.canBeInitial() ? \" [initial]\" : \"\", \"\\n\");\n      }\n\n      if (e.file) {\n        text += \"\".concat(e.file, \"\\n\");\n      }\n\n      if (e.module && e.module.readableIdentifier && typeof e.module.readableIdentifier === \"function\") {\n        text += this.formatFilePath(e.module.readableIdentifier(requestShortener));\n\n        if (typeof e.loc === \"object\") {\n          const locInfo = formatLocation(e.loc);\n          if (locInfo) text += \" \".concat(locInfo);\n        }\n\n        text += \"\\n\";\n      }\n\n      text += e.message;\n\n      if (showErrorDetails && e.details) {\n        text += \"\\n\".concat(e.details);\n      }\n\n      if (showErrorDetails && e.missing) {\n        text += e.missing.map(item => \"\\n[\".concat(item, \"]\")).join(\"\");\n      }\n\n      if (showModuleTrace && e.origin) {\n        text += \"\\n @ \".concat(this.formatFilePath(e.origin.readableIdentifier(requestShortener)));\n\n        if (typeof e.originLoc === \"object\") {\n          const locInfo = formatLocation(e.originLoc);\n          if (locInfo) text += \" \".concat(locInfo);\n        }\n\n        if (e.dependencies) {\n          for (const dep of e.dependencies) {\n            if (!dep.loc) continue;\n            if (typeof dep.loc === \"string\") continue;\n            const locInfo = formatLocation(dep.loc);\n            if (!locInfo) continue;\n            text += \" \".concat(locInfo);\n          }\n        }\n\n        let current = e.origin;\n\n        while (current.issuer) {\n          current = current.issuer;\n          text += \"\\n @ \".concat(current.readableIdentifier(requestShortener));\n        }\n      }\n\n      return text;\n    };\n\n    const obj = {\n      errors: compilation.errors.map(formatError),\n      warnings: Stats.filterWarnings(compilation.warnings.map(formatError), warningsFilter)\n    }; //We just hint other renderers since actually omitting\n    //errors/warnings from the JSON would be kind of weird.\n\n    Object.defineProperty(obj, \"_showWarnings\", {\n      value: showWarnings,\n      enumerable: false\n    });\n    Object.defineProperty(obj, \"_showErrors\", {\n      value: showErrors,\n      enumerable: false\n    });\n\n    if (showVersion) {\n      obj.version = require(\"../package.json\").version;\n    }\n\n    if (showHash) obj.hash = this.hash;\n\n    if (showTimings && this.startTime && this.endTime) {\n      obj.time = this.endTime - this.startTime;\n    }\n\n    if (showBuiltAt && this.endTime) {\n      obj.builtAt = this.endTime;\n    }\n\n    if (showEnv && options._env) {\n      obj.env = options._env;\n    }\n\n    if (compilation.needAdditionalPass) {\n      obj.needAdditionalPass = true;\n    }\n\n    if (showPublicPath) {\n      obj.publicPath = this.compilation.mainTemplate.getPublicPath({\n        hash: this.compilation.hash\n      });\n    }\n\n    if (showOutputPath) {\n      obj.outputPath = this.compilation.mainTemplate.outputOptions.path;\n    }\n\n    if (showAssets) {\n      const assetsByFile = {};\n      const compilationAssets = Object.keys(compilation.assets).sort();\n      obj.assetsByChunkName = {};\n      obj.assets = compilationAssets.map(asset => {\n        const obj = {\n          name: asset,\n          size: compilation.assets[asset].size(),\n          chunks: [],\n          chunkNames: [],\n          // TODO webpack 5: remove .emitted\n          emitted: compilation.assets[asset].emitted || compilation.emittedAssets.has(asset)\n        };\n\n        if (showPerformance) {\n          obj.isOverSizeLimit = compilation.assets[asset].isOverSizeLimit;\n        }\n\n        assetsByFile[asset] = obj;\n        return obj;\n      }).filter(createAssetFilter());\n      obj.filteredAssets = compilationAssets.length - obj.assets.length;\n\n      for (const chunk of compilation.chunks) {\n        for (const asset of chunk.files) {\n          if (assetsByFile[asset]) {\n            for (const id of chunk.ids) {\n              assetsByFile[asset].chunks.push(id);\n            }\n\n            if (chunk.name) {\n              assetsByFile[asset].chunkNames.push(chunk.name);\n\n              if (obj.assetsByChunkName[chunk.name]) {\n                obj.assetsByChunkName[chunk.name] = [].concat(obj.assetsByChunkName[chunk.name]).concat([asset]);\n              } else {\n                obj.assetsByChunkName[chunk.name] = asset;\n              }\n            }\n          }\n        }\n      }\n\n      obj.assets.sort(sortByField(sortAssets, obj.assets));\n    }\n\n    const fnChunkGroup = groupMap => {\n      const obj = {};\n\n      for (const keyValuePair of groupMap) {\n        const name = keyValuePair[0];\n        const cg = keyValuePair[1];\n        const children = cg.getChildrenByOrders();\n        obj[name] = {\n          chunks: cg.chunks.map(c => c.id),\n          assets: cg.chunks.reduce((array, c) => array.concat(c.files || []), []),\n          children: Object.keys(children).reduce((obj, key) => {\n            const groups = children[key];\n            obj[key] = groups.map(group => ({\n              name: group.name,\n              chunks: group.chunks.map(c => c.id),\n              assets: group.chunks.reduce((array, c) => array.concat(c.files || []), [])\n            }));\n            return obj;\n          }, Object.create(null)),\n          childAssets: Object.keys(children).reduce((obj, key) => {\n            const groups = children[key];\n            obj[key] = Array.from(groups.reduce((set, group) => {\n              for (const chunk of group.chunks) {\n                for (const asset of chunk.files) {\n                  set.add(asset);\n                }\n              }\n\n              return set;\n            }, new Set()));\n            return obj;\n          }, Object.create(null))\n        };\n\n        if (showPerformance) {\n          obj[name].isOverSizeLimit = cg.isOverSizeLimit;\n        }\n      }\n\n      return obj;\n    };\n\n    if (showEntrypoints) {\n      obj.entrypoints = fnChunkGroup(compilation.entrypoints);\n    }\n\n    if (showChunkGroups) {\n      obj.namedChunkGroups = fnChunkGroup(compilation.namedChunkGroups);\n    }\n\n    const fnModule = module => {\n      const path = [];\n      let current = module;\n\n      while (current.issuer) {\n        path.push(current = current.issuer);\n      }\n\n      path.reverse();\n      const obj = {\n        id: module.id,\n        identifier: module.identifier(),\n        name: module.readableIdentifier(requestShortener),\n        index: module.index,\n        index2: module.index2,\n        size: module.size(),\n        cacheable: module.buildInfo.cacheable,\n        built: !!module.built,\n        optional: module.optional,\n        prefetched: module.prefetched,\n        chunks: Array.from(module.chunksIterable, chunk => chunk.id),\n        issuer: module.issuer && module.issuer.identifier(),\n        issuerId: module.issuer && module.issuer.id,\n        issuerName: module.issuer && module.issuer.readableIdentifier(requestShortener),\n        issuerPath: module.issuer && path.map(module => ({\n          id: module.id,\n          identifier: module.identifier(),\n          name: module.readableIdentifier(requestShortener),\n          profile: module.profile\n        })),\n        profile: module.profile,\n        failed: !!module.error,\n        errors: module.errors ? module.errors.length : 0,\n        warnings: module.warnings ? module.warnings.length : 0\n      };\n\n      if (showModuleAssets) {\n        obj.assets = Object.keys(module.buildInfo.assets || {});\n      }\n\n      if (showReasons) {\n        obj.reasons = module.reasons.sort((a, b) => {\n          if (a.module && !b.module) return -1;\n          if (!a.module && b.module) return 1;\n\n          if (a.module && b.module) {\n            const cmp = compareId(a.module.id, b.module.id);\n            if (cmp) return cmp;\n          }\n\n          if (a.dependency && !b.dependency) return -1;\n          if (!a.dependency && b.dependency) return 1;\n\n          if (a.dependency && b.dependency) {\n            const cmp = compareLocations(a.dependency.loc, b.dependency.loc);\n            if (cmp) return cmp;\n            if (a.dependency.type < b.dependency.type) return -1;\n            if (a.dependency.type > b.dependency.type) return 1;\n          }\n\n          return 0;\n        }).map(reason => {\n          const obj = {\n            moduleId: reason.module ? reason.module.id : null,\n            moduleIdentifier: reason.module ? reason.module.identifier() : null,\n            module: reason.module ? reason.module.readableIdentifier(requestShortener) : null,\n            moduleName: reason.module ? reason.module.readableIdentifier(requestShortener) : null,\n            type: reason.dependency ? reason.dependency.type : null,\n            explanation: reason.explanation,\n            userRequest: reason.dependency ? reason.dependency.userRequest : null\n          };\n\n          if (reason.dependency) {\n            const locInfo = formatLocation(reason.dependency.loc);\n\n            if (locInfo) {\n              obj.loc = locInfo;\n            }\n          }\n\n          return obj;\n        });\n      }\n\n      if (showUsedExports) {\n        if (module.used === true) {\n          obj.usedExports = module.usedExports;\n        } else if (module.used === false) {\n          obj.usedExports = false;\n        }\n      }\n\n      if (showProvidedExports) {\n        obj.providedExports = Array.isArray(module.buildMeta.providedExports) ? module.buildMeta.providedExports : null;\n      }\n\n      if (showOptimizationBailout) {\n        obj.optimizationBailout = module.optimizationBailout.map(item => {\n          if (typeof item === \"function\") return item(requestShortener);\n          return item;\n        });\n      }\n\n      if (showDepth) {\n        obj.depth = module.depth;\n      }\n\n      if (showNestedModules) {\n        if (module.modules) {\n          const modules = module.modules;\n          obj.modules = modules.sort(sortByField(\"depth\", modules)).filter(createModuleFilter()).map(fnModule);\n          obj.filteredModules = modules.length - obj.modules.length;\n          obj.modules.sort(sortByField(sortModules, obj.modules));\n        }\n      }\n\n      if (showSource && module._source) {\n        obj.source = module._source.source();\n      }\n\n      return obj;\n    };\n\n    if (showChunks) {\n      obj.chunks = compilation.chunks.map(chunk => {\n        const parents = new Set();\n        const children = new Set();\n        const siblings = new Set();\n        const childIdByOrder = chunk.getChildIdsByOrders();\n\n        for (const chunkGroup of chunk.groupsIterable) {\n          for (const parentGroup of chunkGroup.parentsIterable) {\n            for (const chunk of parentGroup.chunks) {\n              parents.add(chunk.id);\n            }\n          }\n\n          for (const childGroup of chunkGroup.childrenIterable) {\n            for (const chunk of childGroup.chunks) {\n              children.add(chunk.id);\n            }\n          }\n\n          for (const sibling of chunkGroup.chunks) {\n            if (sibling !== chunk) siblings.add(sibling.id);\n          }\n        }\n\n        const obj = {\n          id: chunk.id,\n          rendered: chunk.rendered,\n          initial: chunk.canBeInitial(),\n          entry: chunk.hasRuntime(),\n          recorded: chunk.recorded,\n          reason: chunk.chunkReason,\n          size: chunk.modulesSize(),\n          names: chunk.name ? [chunk.name] : [],\n          files: chunk.files.slice(),\n          hash: chunk.renderedHash,\n          siblings: Array.from(siblings).sort(compareId),\n          parents: Array.from(parents).sort(compareId),\n          children: Array.from(children).sort(compareId),\n          childrenByOrder: childIdByOrder\n        };\n\n        if (showChunkModules) {\n          const modules = chunk.getModules();\n          obj.modules = modules.slice().sort(sortByField(\"depth\", modules)).filter(createModuleFilter()).map(fnModule);\n          obj.filteredModules = chunk.getNumberOfModules() - obj.modules.length;\n          obj.modules.sort(sortByField(sortModules, obj.modules));\n        }\n\n        if (showChunkOrigins) {\n          obj.origins = Array.from(chunk.groupsIterable, g => g.origins).reduce((a, b) => a.concat(b), []).map(origin => ({\n            moduleId: origin.module ? origin.module.id : undefined,\n            module: origin.module ? origin.module.identifier() : \"\",\n            moduleIdentifier: origin.module ? origin.module.identifier() : \"\",\n            moduleName: origin.module ? origin.module.readableIdentifier(requestShortener) : \"\",\n            loc: formatLocation(origin.loc),\n            request: origin.request,\n            reasons: origin.reasons || []\n          })).sort((a, b) => {\n            const cmp1 = compareId(a.moduleId, b.moduleId);\n            if (cmp1) return cmp1;\n            const cmp2 = compareId(a.loc, b.loc);\n            if (cmp2) return cmp2;\n            const cmp3 = compareId(a.request, b.request);\n            if (cmp3) return cmp3;\n            return 0;\n          });\n        }\n\n        return obj;\n      });\n      obj.chunks.sort(sortByField(sortChunks, obj.chunks));\n    }\n\n    if (showModules) {\n      obj.modules = compilation.modules.slice().sort(sortByField(\"depth\", compilation.modules)).filter(createModuleFilter()).map(fnModule);\n      obj.filteredModules = compilation.modules.length - obj.modules.length;\n      obj.modules.sort(sortByField(sortModules, obj.modules));\n    }\n\n    if (showLogging) {\n      const util = require(\"util\");\n\n      obj.logging = {};\n      let acceptedTypes;\n      let collapsedGroups = false;\n\n      switch (showLogging) {\n        case \"none\":\n          acceptedTypes = new Set([]);\n          break;\n\n        case \"error\":\n          acceptedTypes = new Set([LogType.error]);\n          break;\n\n        case \"warn\":\n          acceptedTypes = new Set([LogType.error, LogType.warn]);\n          break;\n\n        case \"info\":\n          acceptedTypes = new Set([LogType.error, LogType.warn, LogType.info]);\n          break;\n\n        case true:\n        case \"log\":\n          acceptedTypes = new Set([LogType.error, LogType.warn, LogType.info, LogType.log, LogType.group, LogType.groupEnd, LogType.groupCollapsed, LogType.clear]);\n          break;\n\n        case \"verbose\":\n          acceptedTypes = new Set([LogType.error, LogType.warn, LogType.info, LogType.log, LogType.group, LogType.groupEnd, LogType.groupCollapsed, LogType.profile, LogType.profileEnd, LogType.time, LogType.status, LogType.clear]);\n          collapsedGroups = true;\n          break;\n      }\n\n      for (const _ref of compilation.logging) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        const origin = _ref2[0];\n        const logEntries = _ref2[1];\n        const debugMode = loggingDebug.some(fn => fn(origin));\n        let collapseCounter = 0;\n        let processedLogEntries = logEntries;\n\n        if (!debugMode) {\n          processedLogEntries = processedLogEntries.filter(entry => {\n            if (!acceptedTypes.has(entry.type)) return false;\n\n            if (!collapsedGroups) {\n              switch (entry.type) {\n                case LogType.groupCollapsed:\n                  collapseCounter++;\n                  return collapseCounter === 1;\n\n                case LogType.group:\n                  if (collapseCounter > 0) collapseCounter++;\n                  return collapseCounter === 0;\n\n                case LogType.groupEnd:\n                  if (collapseCounter > 0) {\n                    collapseCounter--;\n                    return false;\n                  }\n\n                  return true;\n\n                default:\n                  return collapseCounter === 0;\n              }\n            }\n\n            return true;\n          });\n        }\n\n        processedLogEntries = processedLogEntries.map(entry => {\n          let message = undefined;\n\n          if (entry.type === LogType.time) {\n            message = \"\".concat(entry.args[0], \": \").concat(entry.args[1] * 1000 + entry.args[2] / 1000000, \"ms\");\n          } else if (entry.args && entry.args.length > 0) {\n            message = util.format(entry.args[0], ...entry.args.slice(1));\n          }\n\n          return {\n            type: (debugMode || collapsedGroups) && entry.type === LogType.groupCollapsed ? LogType.group : entry.type,\n            message,\n            trace: showLoggingTrace && entry.trace ? entry.trace : undefined\n          };\n        });\n        let name = identifierUtils.makePathsRelative(context, origin, compilation.cache).replace(/\\|/g, \" \");\n\n        if (name in obj.logging) {\n          let i = 1;\n\n          while (\"\".concat(name, \"#\").concat(i) in obj.logging) {\n            i++;\n          }\n\n          name = \"\".concat(name, \"#\").concat(i);\n        }\n\n        obj.logging[name] = {\n          entries: processedLogEntries,\n          filteredEntries: logEntries.length - processedLogEntries.length,\n          debug: debugMode\n        };\n      }\n    }\n\n    if (showChildren) {\n      obj.children = compilation.children.map((child, idx) => {\n        const childOptions = Stats.getChildOptions(options, idx);\n        const obj = new Stats(child).toJson(childOptions, forToString);\n        delete obj.hash;\n        delete obj.version;\n\n        if (child.name) {\n          obj.name = identifierUtils.makePathsRelative(context, child.name, compilation.cache);\n        }\n\n        return obj;\n      });\n    }\n\n    return obj;\n  }\n\n  toString(options) {\n    if (typeof options === \"boolean\" || typeof options === \"string\") {\n      options = Stats.presetToOptions(options);\n    } else if (!options) {\n      options = {};\n    }\n\n    const useColors = optionsOrFallback(options.colors, false);\n    const obj = this.toJson(options, true);\n    return Stats.jsonToString(obj, useColors);\n  }\n\n  static jsonToString(obj, useColors) {\n    const buf = [];\n    const defaultColors = {\n      bold: \"\\u001b[1m\",\n      yellow: \"\\u001b[1m\\u001b[33m\",\n      red: \"\\u001b[1m\\u001b[31m\",\n      green: \"\\u001b[1m\\u001b[32m\",\n      cyan: \"\\u001b[1m\\u001b[36m\",\n      magenta: \"\\u001b[1m\\u001b[35m\"\n    };\n    const colors = Object.keys(defaultColors).reduce((obj, color) => {\n      obj[color] = str => {\n        if (useColors) {\n          buf.push(useColors === true || useColors[color] === undefined ? defaultColors[color] : useColors[color]);\n        }\n\n        buf.push(str);\n\n        if (useColors) {\n          buf.push(\"\\u001b[39m\\u001b[22m\");\n        }\n      };\n\n      return obj;\n    }, {\n      normal: str => buf.push(str)\n    });\n\n    const coloredTime = time => {\n      let times = [800, 400, 200, 100];\n\n      if (obj.time) {\n        times = [obj.time / 2, obj.time / 4, obj.time / 8, obj.time / 16];\n      }\n\n      if (time < times[3]) colors.normal(\"\".concat(time, \"ms\"));else if (time < times[2]) colors.bold(\"\".concat(time, \"ms\"));else if (time < times[1]) colors.green(\"\".concat(time, \"ms\"));else if (time < times[0]) colors.yellow(\"\".concat(time, \"ms\"));else colors.red(\"\".concat(time, \"ms\"));\n    };\n\n    const newline = () => buf.push(\"\\n\");\n\n    const getText = (arr, row, col) => {\n      return arr[row][col].value;\n    };\n\n    const table = (array, align, splitter) => {\n      const rows = array.length;\n      const cols = array[0].length;\n      const colSizes = new Array(cols);\n\n      for (let col = 0; col < cols; col++) {\n        colSizes[col] = 0;\n      }\n\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const value = \"\".concat(getText(array, row, col));\n\n          if (value.length > colSizes[col]) {\n            colSizes[col] = value.length;\n          }\n        }\n      }\n\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const format = array[row][col].color;\n          const value = \"\".concat(getText(array, row, col));\n          let l = value.length;\n\n          if (align[col] === \"l\") {\n            format(value);\n          }\n\n          for (; l < colSizes[col] && col !== cols - 1; l++) {\n            colors.normal(\" \");\n          }\n\n          if (align[col] === \"r\") {\n            format(value);\n          }\n\n          if (col + 1 < cols && colSizes[col] !== 0) {\n            colors.normal(splitter || \"  \");\n          }\n        }\n\n        newline();\n      }\n    };\n\n    const getAssetColor = (asset, defaultColor) => {\n      if (asset.isOverSizeLimit) {\n        return colors.yellow;\n      }\n\n      return defaultColor;\n    };\n\n    if (obj.hash) {\n      colors.normal(\"Hash: \");\n      colors.bold(obj.hash);\n      newline();\n    }\n\n    if (obj.version) {\n      colors.normal(\"Version: webpack \");\n      colors.bold(obj.version);\n      newline();\n    }\n\n    if (typeof obj.time === \"number\") {\n      colors.normal(\"Time: \");\n      colors.bold(obj.time);\n      colors.normal(\"ms\");\n      newline();\n    }\n\n    if (typeof obj.builtAt === \"number\") {\n      const builtAtDate = new Date(obj.builtAt);\n      colors.normal(\"Built at: \");\n      colors.normal(builtAtDate.toLocaleDateString(undefined, {\n        day: \"2-digit\",\n        month: \"2-digit\",\n        year: \"numeric\"\n      }));\n      colors.normal(\" \");\n      colors.bold(builtAtDate.toLocaleTimeString());\n      newline();\n    }\n\n    if (obj.env) {\n      colors.normal(\"Environment (--env): \");\n      colors.bold(JSON.stringify(obj.env, null, 2));\n      newline();\n    }\n\n    if (obj.publicPath) {\n      colors.normal(\"PublicPath: \");\n      colors.bold(obj.publicPath);\n      newline();\n    }\n\n    if (obj.assets && obj.assets.length > 0) {\n      const t = [[{\n        value: \"Asset\",\n        color: colors.bold\n      }, {\n        value: \"Size\",\n        color: colors.bold\n      }, {\n        value: \"Chunks\",\n        color: colors.bold\n      }, {\n        value: \"\",\n        color: colors.bold\n      }, {\n        value: \"\",\n        color: colors.bold\n      }, {\n        value: \"Chunk Names\",\n        color: colors.bold\n      }]];\n\n      for (const asset of obj.assets) {\n        t.push([{\n          value: asset.name,\n          color: getAssetColor(asset, colors.green)\n        }, {\n          value: SizeFormatHelpers.formatSize(asset.size),\n          color: getAssetColor(asset, colors.normal)\n        }, {\n          value: asset.chunks.join(\", \"),\n          color: colors.bold\n        }, {\n          value: asset.emitted ? \"[emitted]\" : \"\",\n          color: colors.green\n        }, {\n          value: asset.isOverSizeLimit ? \"[big]\" : \"\",\n          color: getAssetColor(asset, colors.normal)\n        }, {\n          value: asset.chunkNames.join(\", \"),\n          color: colors.normal\n        }]);\n      }\n\n      table(t, \"rrrlll\");\n    }\n\n    if (obj.filteredAssets > 0) {\n      colors.normal(\" \");\n      if (obj.assets.length > 0) colors.normal(\"+ \");\n      colors.normal(obj.filteredAssets);\n      if (obj.assets.length > 0) colors.normal(\" hidden\");\n      colors.normal(obj.filteredAssets !== 1 ? \" assets\" : \" asset\");\n      newline();\n    }\n\n    const processChunkGroups = (namedGroups, prefix) => {\n      for (const name of Object.keys(namedGroups)) {\n        const cg = namedGroups[name];\n        colors.normal(\"\".concat(prefix, \" \"));\n        colors.bold(name);\n\n        if (cg.isOverSizeLimit) {\n          colors.normal(\" \");\n          colors.yellow(\"[big]\");\n        }\n\n        colors.normal(\" =\");\n\n        for (const asset of cg.assets) {\n          colors.normal(\" \");\n          colors.green(asset);\n        }\n\n        for (const name of Object.keys(cg.childAssets)) {\n          const assets = cg.childAssets[name];\n\n          if (assets && assets.length > 0) {\n            colors.normal(\" \");\n            colors.magenta(\"(\".concat(name, \":\"));\n\n            for (const asset of assets) {\n              colors.normal(\" \");\n              colors.green(asset);\n            }\n\n            colors.magenta(\")\");\n          }\n        }\n\n        newline();\n      }\n    };\n\n    if (obj.entrypoints) {\n      processChunkGroups(obj.entrypoints, \"Entrypoint\");\n    }\n\n    if (obj.namedChunkGroups) {\n      let outputChunkGroups = obj.namedChunkGroups;\n\n      if (obj.entrypoints) {\n        outputChunkGroups = Object.keys(outputChunkGroups).filter(name => !obj.entrypoints[name]).reduce((result, name) => {\n          result[name] = obj.namedChunkGroups[name];\n          return result;\n        }, {});\n      }\n\n      processChunkGroups(outputChunkGroups, \"Chunk Group\");\n    }\n\n    const modulesByIdentifier = {};\n\n    if (obj.modules) {\n      for (const module of obj.modules) {\n        modulesByIdentifier[\"$\".concat(module.identifier)] = module;\n      }\n    } else if (obj.chunks) {\n      for (const chunk of obj.chunks) {\n        if (chunk.modules) {\n          for (const module of chunk.modules) {\n            modulesByIdentifier[\"$\".concat(module.identifier)] = module;\n          }\n        }\n      }\n    }\n\n    const processModuleAttributes = module => {\n      colors.normal(\" \");\n      colors.normal(SizeFormatHelpers.formatSize(module.size));\n\n      if (module.chunks) {\n        for (const chunk of module.chunks) {\n          colors.normal(\" {\");\n          colors.yellow(chunk);\n          colors.normal(\"}\");\n        }\n      }\n\n      if (typeof module.depth === \"number\") {\n        colors.normal(\" [depth \".concat(module.depth, \"]\"));\n      }\n\n      if (module.cacheable === false) {\n        colors.red(\" [not cacheable]\");\n      }\n\n      if (module.optional) {\n        colors.yellow(\" [optional]\");\n      }\n\n      if (module.built) {\n        colors.green(\" [built]\");\n      }\n\n      if (module.assets && module.assets.length) {\n        colors.magenta(\" [\".concat(module.assets.length, \" asset\").concat(module.assets.length === 1 ? \"\" : \"s\", \"]\"));\n      }\n\n      if (module.prefetched) {\n        colors.magenta(\" [prefetched]\");\n      }\n\n      if (module.failed) colors.red(\" [failed]\");\n\n      if (module.warnings) {\n        colors.yellow(\" [\".concat(module.warnings, \" warning\").concat(module.warnings === 1 ? \"\" : \"s\", \"]\"));\n      }\n\n      if (module.errors) {\n        colors.red(\" [\".concat(module.errors, \" error\").concat(module.errors === 1 ? \"\" : \"s\", \"]\"));\n      }\n    };\n\n    const processModuleContent = (module, prefix) => {\n      if (Array.isArray(module.providedExports)) {\n        colors.normal(prefix);\n\n        if (module.providedExports.length === 0) {\n          colors.cyan(\"[no exports]\");\n        } else {\n          colors.cyan(\"[exports: \".concat(module.providedExports.join(\", \"), \"]\"));\n        }\n\n        newline();\n      }\n\n      if (module.usedExports !== undefined) {\n        if (module.usedExports !== true) {\n          colors.normal(prefix);\n\n          if (module.usedExports === null) {\n            colors.cyan(\"[used exports unknown]\");\n          } else if (module.usedExports === false) {\n            colors.cyan(\"[no exports used]\");\n          } else if (Array.isArray(module.usedExports) && module.usedExports.length === 0) {\n            colors.cyan(\"[no exports used]\");\n          } else if (Array.isArray(module.usedExports)) {\n            const providedExportsCount = Array.isArray(module.providedExports) ? module.providedExports.length : null;\n\n            if (providedExportsCount !== null && providedExportsCount === module.usedExports.length) {\n              colors.cyan(\"[all exports used]\");\n            } else {\n              colors.cyan(\"[only some exports used: \".concat(module.usedExports.join(\", \"), \"]\"));\n            }\n          }\n\n          newline();\n        }\n      }\n\n      if (Array.isArray(module.optimizationBailout)) {\n        for (const item of module.optimizationBailout) {\n          colors.normal(prefix);\n          colors.yellow(item);\n          newline();\n        }\n      }\n\n      if (module.reasons) {\n        for (const reason of module.reasons) {\n          colors.normal(prefix);\n\n          if (reason.type) {\n            colors.normal(reason.type);\n            colors.normal(\" \");\n          }\n\n          if (reason.userRequest) {\n            colors.cyan(reason.userRequest);\n            colors.normal(\" \");\n          }\n\n          if (reason.moduleId !== null) {\n            colors.normal(\"[\");\n            colors.normal(reason.moduleId);\n            colors.normal(\"]\");\n          }\n\n          if (reason.module && reason.module !== reason.moduleId) {\n            colors.normal(\" \");\n            colors.magenta(reason.module);\n          }\n\n          if (reason.loc) {\n            colors.normal(\" \");\n            colors.normal(reason.loc);\n          }\n\n          if (reason.explanation) {\n            colors.normal(\" \");\n            colors.cyan(reason.explanation);\n          }\n\n          newline();\n        }\n      }\n\n      if (module.profile) {\n        colors.normal(prefix);\n        let sum = 0;\n\n        if (module.issuerPath) {\n          for (const m of module.issuerPath) {\n            colors.normal(\"[\");\n            colors.normal(m.id);\n            colors.normal(\"] \");\n\n            if (m.profile) {\n              const time = (m.profile.factory || 0) + (m.profile.building || 0);\n              coloredTime(time);\n              sum += time;\n              colors.normal(\" \");\n            }\n\n            colors.normal(\"-> \");\n          }\n        }\n\n        for (const key of Object.keys(module.profile)) {\n          colors.normal(\"\".concat(key, \":\"));\n          const time = module.profile[key];\n          coloredTime(time);\n          colors.normal(\" \");\n          sum += time;\n        }\n\n        colors.normal(\"= \");\n        coloredTime(sum);\n        newline();\n      }\n\n      if (module.modules) {\n        processModulesList(module, prefix + \"| \");\n      }\n    };\n\n    const processModulesList = (obj, prefix) => {\n      if (obj.modules) {\n        let maxModuleId = 0;\n\n        for (const module of obj.modules) {\n          if (typeof module.id === \"number\") {\n            if (maxModuleId < module.id) maxModuleId = module.id;\n          }\n        }\n\n        let contentPrefix = prefix + \"    \";\n        if (maxModuleId >= 10) contentPrefix += \" \";\n        if (maxModuleId >= 100) contentPrefix += \" \";\n        if (maxModuleId >= 1000) contentPrefix += \" \";\n\n        for (const module of obj.modules) {\n          colors.normal(prefix);\n          const name = module.name || module.identifier;\n\n          if (typeof module.id === \"string\" || typeof module.id === \"number\") {\n            if (typeof module.id === \"number\") {\n              if (module.id < 1000 && maxModuleId >= 1000) colors.normal(\" \");\n              if (module.id < 100 && maxModuleId >= 100) colors.normal(\" \");\n              if (module.id < 10 && maxModuleId >= 10) colors.normal(\" \");\n            } else {\n              if (maxModuleId >= 1000) colors.normal(\" \");\n              if (maxModuleId >= 100) colors.normal(\" \");\n              if (maxModuleId >= 10) colors.normal(\" \");\n            }\n\n            if (name !== module.id) {\n              colors.normal(\"[\");\n              colors.normal(module.id);\n              colors.normal(\"]\");\n              colors.normal(\" \");\n            } else {\n              colors.normal(\"[\");\n              colors.bold(module.id);\n              colors.normal(\"]\");\n            }\n          }\n\n          if (name !== module.id) {\n            colors.bold(name);\n          }\n\n          processModuleAttributes(module);\n          newline();\n          processModuleContent(module, contentPrefix);\n        }\n\n        if (obj.filteredModules > 0) {\n          colors.normal(prefix);\n          colors.normal(\"   \");\n          if (obj.modules.length > 0) colors.normal(\" + \");\n          colors.normal(obj.filteredModules);\n          if (obj.modules.length > 0) colors.normal(\" hidden\");\n          colors.normal(obj.filteredModules !== 1 ? \" modules\" : \" module\");\n          newline();\n        }\n      }\n    };\n\n    if (obj.chunks) {\n      for (const chunk of obj.chunks) {\n        colors.normal(\"chunk \");\n        if (chunk.id < 1000) colors.normal(\" \");\n        if (chunk.id < 100) colors.normal(\" \");\n        if (chunk.id < 10) colors.normal(\" \");\n        colors.normal(\"{\");\n        colors.yellow(chunk.id);\n        colors.normal(\"} \");\n        colors.green(chunk.files.join(\", \"));\n\n        if (chunk.names && chunk.names.length > 0) {\n          colors.normal(\" (\");\n          colors.normal(chunk.names.join(\", \"));\n          colors.normal(\")\");\n        }\n\n        colors.normal(\" \");\n        colors.normal(SizeFormatHelpers.formatSize(chunk.size));\n\n        for (const id of chunk.parents) {\n          colors.normal(\" <{\");\n          colors.yellow(id);\n          colors.normal(\"}>\");\n        }\n\n        for (const id of chunk.siblings) {\n          colors.normal(\" ={\");\n          colors.yellow(id);\n          colors.normal(\"}=\");\n        }\n\n        for (const id of chunk.children) {\n          colors.normal(\" >{\");\n          colors.yellow(id);\n          colors.normal(\"}<\");\n        }\n\n        if (chunk.childrenByOrder) {\n          for (const name of Object.keys(chunk.childrenByOrder)) {\n            const children = chunk.childrenByOrder[name];\n            colors.normal(\" \");\n            colors.magenta(\"(\".concat(name, \":\"));\n\n            for (const id of children) {\n              colors.normal(\" {\");\n              colors.yellow(id);\n              colors.normal(\"}\");\n            }\n\n            colors.magenta(\")\");\n          }\n        }\n\n        if (chunk.entry) {\n          colors.yellow(\" [entry]\");\n        } else if (chunk.initial) {\n          colors.yellow(\" [initial]\");\n        }\n\n        if (chunk.rendered) {\n          colors.green(\" [rendered]\");\n        }\n\n        if (chunk.recorded) {\n          colors.green(\" [recorded]\");\n        }\n\n        if (chunk.reason) {\n          colors.yellow(\" \".concat(chunk.reason));\n        }\n\n        newline();\n\n        if (chunk.origins) {\n          for (const origin of chunk.origins) {\n            colors.normal(\"    > \");\n\n            if (origin.reasons && origin.reasons.length) {\n              colors.yellow(origin.reasons.join(\" \"));\n              colors.normal(\" \");\n            }\n\n            if (origin.request) {\n              colors.normal(origin.request);\n              colors.normal(\" \");\n            }\n\n            if (origin.module) {\n              colors.normal(\"[\");\n              colors.normal(origin.moduleId);\n              colors.normal(\"] \");\n              const module = modulesByIdentifier[\"$\".concat(origin.module)];\n\n              if (module) {\n                colors.bold(module.name);\n                colors.normal(\" \");\n              }\n            }\n\n            if (origin.loc) {\n              colors.normal(origin.loc);\n            }\n\n            newline();\n          }\n        }\n\n        processModulesList(chunk, \" \");\n      }\n    }\n\n    processModulesList(obj, \"\");\n\n    if (obj.logging) {\n      for (const origin of Object.keys(obj.logging)) {\n        const logData = obj.logging[origin];\n\n        if (logData.entries.length > 0) {\n          newline();\n\n          if (logData.debug) {\n            colors.red(\"DEBUG \");\n          }\n\n          colors.bold(\"LOG from \" + origin);\n          newline();\n          let indent = \"\";\n\n          for (const entry of logData.entries) {\n            let color = colors.normal;\n            let prefix = \"    \";\n\n            switch (entry.type) {\n              case LogType.clear:\n                colors.normal(\"\".concat(indent, \"-------\"));\n                newline();\n                continue;\n\n              case LogType.error:\n                color = colors.red;\n                prefix = \"<e> \";\n                break;\n\n              case LogType.warn:\n                color = colors.yellow;\n                prefix = \"<w> \";\n                break;\n\n              case LogType.info:\n                color = colors.green;\n                prefix = \"<i> \";\n                break;\n\n              case LogType.log:\n                color = colors.bold;\n                break;\n\n              case LogType.trace:\n              case LogType.debug:\n                color = colors.normal;\n                break;\n\n              case LogType.status:\n                color = colors.magenta;\n                prefix = \"<s> \";\n                break;\n\n              case LogType.profile:\n                color = colors.magenta;\n                prefix = \"<p> \";\n                break;\n\n              case LogType.profileEnd:\n                color = colors.magenta;\n                prefix = \"</p> \";\n                break;\n\n              case LogType.time:\n                color = colors.magenta;\n                prefix = \"<t> \";\n                break;\n\n              case LogType.group:\n                color = colors.cyan;\n                prefix = \"<-> \";\n                break;\n\n              case LogType.groupCollapsed:\n                color = colors.cyan;\n                prefix = \"<+> \";\n                break;\n\n              case LogType.groupEnd:\n                if (indent.length >= 2) indent = indent.slice(0, indent.length - 2);\n                continue;\n            }\n\n            if (entry.message) {\n              for (const line of entry.message.split(\"\\n\")) {\n                colors.normal(\"\".concat(indent).concat(prefix));\n                color(line);\n                newline();\n              }\n            }\n\n            if (entry.trace) {\n              for (const line of entry.trace) {\n                colors.normal(\"\".concat(indent, \"| \").concat(line));\n                newline();\n              }\n            }\n\n            switch (entry.type) {\n              case LogType.group:\n                indent += \"  \";\n                break;\n            }\n          }\n\n          if (logData.filteredEntries) {\n            colors.normal(\"+ \".concat(logData.filteredEntries, \" hidden lines\"));\n            newline();\n          }\n        }\n      }\n    }\n\n    if (obj._showWarnings && obj.warnings) {\n      for (const warning of obj.warnings) {\n        newline();\n        colors.yellow(\"WARNING in \".concat(warning));\n        newline();\n      }\n    }\n\n    if (obj._showErrors && obj.errors) {\n      for (const error of obj.errors) {\n        newline();\n        colors.red(\"ERROR in \".concat(error));\n        newline();\n      }\n    }\n\n    if (obj.children) {\n      for (const child of obj.children) {\n        const childString = Stats.jsonToString(child, useColors);\n\n        if (childString) {\n          if (child.name) {\n            colors.normal(\"Child \");\n            colors.bold(child.name);\n            colors.normal(\":\");\n          } else {\n            colors.normal(\"Child\");\n          }\n\n          newline();\n          buf.push(\"    \");\n          buf.push(childString.replace(/\\n/g, \"\\n    \"));\n          newline();\n        }\n      }\n    }\n\n    if (obj.needAdditionalPass) {\n      colors.yellow(\"Compilation needs an additional pass and will compile again.\");\n    }\n\n    while (buf[buf.length - 1] === \"\\n\") {\n      buf.pop();\n    }\n\n    return buf.join(\"\");\n  }\n\n  static presetToOptions(name) {\n    // Accepted values: none, errors-only, minimal, normal, detailed, verbose\n    // Any other falsy value will behave as 'none', truthy values as 'normal'\n    const pn = typeof name === \"string\" && name.toLowerCase() || name || \"none\";\n\n    switch (pn) {\n      case \"none\":\n        return {\n          all: false\n        };\n\n      case \"verbose\":\n        return {\n          entrypoints: true,\n          chunkGroups: true,\n          modules: false,\n          chunks: true,\n          chunkModules: true,\n          chunkOrigins: true,\n          depth: true,\n          env: true,\n          reasons: true,\n          usedExports: true,\n          providedExports: true,\n          optimizationBailout: true,\n          errorDetails: true,\n          publicPath: true,\n          logging: \"verbose\",\n          exclude: false,\n          maxModules: Infinity\n        };\n\n      case \"detailed\":\n        return {\n          entrypoints: true,\n          chunkGroups: true,\n          chunks: true,\n          chunkModules: false,\n          chunkOrigins: true,\n          depth: true,\n          usedExports: true,\n          providedExports: true,\n          optimizationBailout: true,\n          errorDetails: true,\n          publicPath: true,\n          logging: true,\n          exclude: false,\n          maxModules: Infinity\n        };\n\n      case \"minimal\":\n        return {\n          all: false,\n          modules: true,\n          maxModules: 0,\n          errors: true,\n          warnings: true,\n          logging: \"warn\"\n        };\n\n      case \"errors-only\":\n        return {\n          all: false,\n          errors: true,\n          moduleTrace: true,\n          logging: \"error\"\n        };\n\n      case \"errors-warnings\":\n        return {\n          all: false,\n          errors: true,\n          warnings: true,\n          logging: \"warn\"\n        };\n\n      default:\n        return {};\n    }\n  }\n\n  static getChildOptions(options, idx) {\n    let innerOptions;\n\n    if (Array.isArray(options.children)) {\n      if (idx < options.children.length) {\n        innerOptions = options.children[idx];\n      }\n    } else if (typeof options.children === \"object\" && options.children) {\n      innerOptions = options.children;\n    }\n\n    if (typeof innerOptions === \"boolean\" || typeof innerOptions === \"string\") {\n      innerOptions = Stats.presetToOptions(innerOptions);\n    }\n\n    if (!innerOptions) {\n      return options;\n    }\n\n    const childOptions = Object.assign({}, options);\n    delete childOptions.children; // do not inherit children\n\n    return Object.assign(childOptions, innerOptions);\n  }\n\n}\n\nmodule.exports = Stats;","map":null,"metadata":{},"sourceType":"script"}