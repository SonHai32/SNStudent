{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst AMDRequireItemDependency = require(\"./AMDRequireItemDependency\");\n\nconst AMDRequireContextDependency = require(\"./AMDRequireContextDependency\");\n\nconst ConstDependency = require(\"./ConstDependency\");\n\nconst AMDDefineDependency = require(\"./AMDDefineDependency\");\n\nconst AMDRequireArrayDependency = require(\"./AMDRequireArrayDependency\");\n\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\n\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\n\nconst LocalModulesHelpers = require(\"./LocalModulesHelpers\");\n\nconst isBoundFunctionExpression = expr => {\n  if (expr.type !== \"CallExpression\") return false;\n  if (expr.callee.type !== \"MemberExpression\") return false;\n  if (expr.callee.computed) return false;\n  if (expr.callee.object.type !== \"FunctionExpression\") return false;\n  if (expr.callee.property.type !== \"Identifier\") return false;\n  if (expr.callee.property.name !== \"bind\") return false;\n  return true;\n};\n\nconst isUnboundFunctionExpression = expr => {\n  if (expr.type === \"FunctionExpression\") return true;\n  if (expr.type === \"ArrowFunctionExpression\") return true;\n  return false;\n};\n\nconst isCallable = expr => {\n  if (isUnboundFunctionExpression(expr)) return true;\n  if (isBoundFunctionExpression(expr)) return true;\n  return false;\n};\n\nclass AMDDefineDependencyParserPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n\n  apply(parser) {\n    parser.hooks.call.for(\"define\").tap(\"AMDDefineDependencyParserPlugin\", this.processCallDefine.bind(this, parser));\n  }\n\n  processArray(parser, expr, param, identifiers, namedModule) {\n    if (param.isArray()) {\n      param.items.forEach((param, idx) => {\n        if (param.isString() && [\"require\", \"module\", \"exports\"].includes(param.string)) identifiers[idx] = param.string;\n        const result = this.processItem(parser, expr, param, namedModule);\n\n        if (result === undefined) {\n          this.processContext(parser, expr, param);\n        }\n      });\n      return true;\n    } else if (param.isConstArray()) {\n      const deps = [];\n      param.array.forEach((request, idx) => {\n        let dep;\n        let localModule;\n\n        if (request === \"require\") {\n          identifiers[idx] = request;\n          dep = \"__webpack_require__\";\n        } else if ([\"exports\", \"module\"].includes(request)) {\n          identifiers[idx] = request;\n          dep = request;\n        } else if (localModule = LocalModulesHelpers.getLocalModule(parser.state, request)) {\n          dep = new LocalModuleDependency(localModule, undefined, false);\n          dep.loc = expr.loc;\n          parser.state.current.addDependency(dep);\n        } else {\n          dep = this.newRequireItemDependency(request);\n          dep.loc = expr.loc;\n          dep.optional = !!parser.scope.inTry;\n          parser.state.current.addDependency(dep);\n        }\n\n        deps.push(dep);\n      });\n      const dep = this.newRequireArrayDependency(deps, param.range);\n      dep.loc = expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    }\n  }\n\n  processItem(parser, expr, param, namedModule) {\n    if (param.isConditional()) {\n      param.options.forEach(param => {\n        const result = this.processItem(parser, expr, param);\n\n        if (result === undefined) {\n          this.processContext(parser, expr, param);\n        }\n      });\n      return true;\n    } else if (param.isString()) {\n      let dep, localModule;\n\n      if (param.string === \"require\") {\n        dep = new ConstDependency(\"__webpack_require__\", param.range);\n      } else if ([\"require\", \"exports\", \"module\"].includes(param.string)) {\n        dep = new ConstDependency(param.string, param.range);\n      } else if (localModule = LocalModulesHelpers.getLocalModule(parser.state, param.string, namedModule)) {\n        dep = new LocalModuleDependency(localModule, param.range, false);\n      } else {\n        dep = this.newRequireItemDependency(param.string, param.range);\n      }\n\n      dep.loc = expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    }\n  }\n\n  processContext(parser, expr, param) {\n    const dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {}, parser);\n    if (!dep) return;\n    dep.loc = expr.loc;\n    dep.optional = !!parser.scope.inTry;\n    parser.state.current.addDependency(dep);\n    return true;\n  }\n\n  processCallDefine(parser, expr) {\n    let array, fn, obj, namedModule;\n\n    switch (expr.arguments.length) {\n      case 1:\n        if (isCallable(expr.arguments[0])) {\n          // define(f() {…})\n          fn = expr.arguments[0];\n        } else if (expr.arguments[0].type === \"ObjectExpression\") {\n          // define({…})\n          obj = expr.arguments[0];\n        } else {\n          // define(expr)\n          // unclear if function or object\n          obj = fn = expr.arguments[0];\n        }\n\n        break;\n\n      case 2:\n        if (expr.arguments[0].type === \"Literal\") {\n          namedModule = expr.arguments[0].value; // define(\"…\", …)\n\n          if (isCallable(expr.arguments[1])) {\n            // define(\"…\", f() {…})\n            fn = expr.arguments[1];\n          } else if (expr.arguments[1].type === \"ObjectExpression\") {\n            // define(\"…\", {…})\n            obj = expr.arguments[1];\n          } else {\n            // define(\"…\", expr)\n            // unclear if function or object\n            obj = fn = expr.arguments[1];\n          }\n        } else {\n          array = expr.arguments[0];\n\n          if (isCallable(expr.arguments[1])) {\n            // define([…], f() {})\n            fn = expr.arguments[1];\n          } else if (expr.arguments[1].type === \"ObjectExpression\") {\n            // define([…], {…})\n            obj = expr.arguments[1];\n          } else {\n            // define([…], expr)\n            // unclear if function or object\n            obj = fn = expr.arguments[1];\n          }\n        }\n\n        break;\n\n      case 3:\n        // define(\"…\", […], f() {…})\n        namedModule = expr.arguments[0].value;\n        array = expr.arguments[1];\n\n        if (isCallable(expr.arguments[2])) {\n          // define(\"…\", […], f() {})\n          fn = expr.arguments[2];\n        } else if (expr.arguments[2].type === \"ObjectExpression\") {\n          // define(\"…\", […], {…})\n          obj = expr.arguments[2];\n        } else {\n          // define(\"…\", […], expr)\n          // unclear if function or object\n          obj = fn = expr.arguments[2];\n        }\n\n        break;\n\n      default:\n        return;\n    }\n\n    let fnParams = null;\n    let fnParamsOffset = 0;\n\n    if (fn) {\n      if (isUnboundFunctionExpression(fn)) {\n        fnParams = fn.params;\n      } else if (isBoundFunctionExpression(fn)) {\n        fnParams = fn.callee.object.params;\n        fnParamsOffset = fn.arguments.length - 1;\n\n        if (fnParamsOffset < 0) {\n          fnParamsOffset = 0;\n        }\n      }\n    }\n\n    let fnRenames = parser.scope.renames.createChild();\n\n    if (array) {\n      const identifiers = {};\n      const param = parser.evaluateExpression(array);\n      const result = this.processArray(parser, expr, param, identifiers, namedModule);\n      if (!result) return;\n\n      if (fnParams) {\n        fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n          if (identifiers[idx]) {\n            fnRenames.set(param.name, identifiers[idx]);\n            return false;\n          }\n\n          return true;\n        });\n      }\n    } else {\n      const identifiers = [\"require\", \"exports\", \"module\"];\n\n      if (fnParams) {\n        fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n          if (identifiers[idx]) {\n            fnRenames.set(param.name, identifiers[idx]);\n            return false;\n          }\n\n          return true;\n        });\n      }\n    }\n\n    let inTry;\n\n    if (fn && isUnboundFunctionExpression(fn)) {\n      inTry = parser.scope.inTry;\n      parser.inScope(fnParams, () => {\n        parser.scope.renames = fnRenames;\n        parser.scope.inTry = inTry;\n\n        if (fn.body.type === \"BlockStatement\") {\n          parser.walkStatement(fn.body);\n        } else {\n          parser.walkExpression(fn.body);\n        }\n      });\n    } else if (fn && isBoundFunctionExpression(fn)) {\n      inTry = parser.scope.inTry;\n      parser.inScope(fn.callee.object.params.filter(i => ![\"require\", \"module\", \"exports\"].includes(i.name)), () => {\n        parser.scope.renames = fnRenames;\n        parser.scope.inTry = inTry;\n\n        if (fn.callee.object.body.type === \"BlockStatement\") {\n          parser.walkStatement(fn.callee.object.body);\n        } else {\n          parser.walkExpression(fn.callee.object.body);\n        }\n      });\n\n      if (fn.arguments) {\n        parser.walkExpressions(fn.arguments);\n      }\n    } else if (fn || obj) {\n      parser.walkExpression(fn || obj);\n    }\n\n    const dep = this.newDefineDependency(expr.range, array ? array.range : null, fn ? fn.range : null, obj ? obj.range : null, namedModule ? namedModule : null);\n    dep.loc = expr.loc;\n\n    if (namedModule) {\n      dep.localModule = LocalModulesHelpers.addLocalModule(parser.state, namedModule);\n    }\n\n    parser.state.current.addDependency(dep);\n    return true;\n  }\n\n  newDefineDependency(range, arrayRange, functionRange, objectRange, namedModule) {\n    return new AMDDefineDependency(range, arrayRange, functionRange, objectRange, namedModule);\n  }\n\n  newRequireArrayDependency(depsArray, range) {\n    return new AMDRequireArrayDependency(depsArray, range);\n  }\n\n  newRequireItemDependency(request, range) {\n    return new AMDRequireItemDependency(request, range);\n  }\n\n}\n\nmodule.exports = AMDDefineDependencyParserPlugin;","map":null,"metadata":{},"sourceType":"script"}