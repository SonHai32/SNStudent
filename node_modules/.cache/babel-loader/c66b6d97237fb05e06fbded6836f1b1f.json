{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Template = require(\"../Template\");\n\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../MainTemplate\")} MainTemplate */\n// Get all wasm modules\n\n\nconst getAllWasmModules = chunk => {\n  const wasmModules = chunk.getAllAsyncChunks();\n  const array = [];\n\n  for (const chunk of wasmModules) {\n    for (const m of chunk.modulesIterable) {\n      if (m.type.startsWith(\"webassembly\")) {\n        array.push(m);\n      }\n    }\n  }\n\n  return array;\n};\n/**\n * generates the import object function for a module\n * @param {Module} module the module\n * @param {boolean} mangle mangle imports\n * @returns {string} source code\n */\n\n\nconst generateImportObject = (module, mangle) => {\n  const waitForInstances = new Map();\n  const properties = [];\n  const usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(module, mangle);\n\n  for (const usedDep of usedWasmDependencies) {\n    const dep = usedDep.dependency;\n    const importedModule = dep.module;\n    const exportName = dep.name;\n    const usedName = importedModule && importedModule.isUsed(exportName);\n    const description = dep.description;\n    const direct = dep.onlyDirectImport;\n    const module = usedDep.module;\n    const name = usedDep.name;\n\n    if (direct) {\n      const instanceVar = \"m\".concat(waitForInstances.size);\n      waitForInstances.set(instanceVar, importedModule.id);\n      properties.push({\n        module,\n        name,\n        value: \"\".concat(instanceVar, \"[\").concat(JSON.stringify(usedName), \"]\")\n      });\n    } else {\n      const params = description.signature.params.map((param, k) => \"p\" + k + param.valtype);\n      const mod = \"installedModules[\".concat(JSON.stringify(importedModule.id), \"]\");\n      const func = \"\".concat(mod, \".exports[\").concat(JSON.stringify(usedName), \"]\");\n      properties.push({\n        module,\n        name,\n        value: Template.asString([(importedModule.type.startsWith(\"webassembly\") ? \"\".concat(mod, \" ? \").concat(func, \" : \") : \"\") + \"function(\".concat(params, \") {\"), Template.indent([\"return \".concat(func, \"(\").concat(params, \");\")]), \"}\"])\n      });\n    }\n  }\n\n  let importObject;\n\n  if (mangle) {\n    importObject = [\"return {\", Template.indent([properties.map(p => \"\".concat(JSON.stringify(p.name), \": \").concat(p.value)).join(\",\\n\")]), \"};\"];\n  } else {\n    const propertiesByModule = new Map();\n\n    for (const p of properties) {\n      let list = propertiesByModule.get(p.module);\n\n      if (list === undefined) {\n        propertiesByModule.set(p.module, list = []);\n      }\n\n      list.push(p);\n    }\n\n    importObject = [\"return {\", Template.indent([Array.from(propertiesByModule, ([module, list]) => {\n      return Template.asString([\"\".concat(JSON.stringify(module), \": {\"), Template.indent([list.map(p => \"\".concat(JSON.stringify(p.name), \": \").concat(p.value)).join(\",\\n\")]), \"}\"]);\n    }).join(\",\\n\")]), \"};\"];\n  }\n\n  if (waitForInstances.size === 1) {\n    const moduleId = Array.from(waitForInstances.values())[0];\n    const promise = \"installedWasmModules[\".concat(JSON.stringify(moduleId), \"]\");\n    const variable = Array.from(waitForInstances.keys())[0];\n    return Template.asString([\"\".concat(JSON.stringify(module.id), \": function() {\"), Template.indent([\"return promiseResolve().then(function() { return \".concat(promise, \"; }).then(function(\").concat(variable, \") {\"), Template.indent(importObject), \"});\"]), \"},\"]);\n  } else if (waitForInstances.size > 0) {\n    const promises = Array.from(waitForInstances.values(), id => \"installedWasmModules[\".concat(JSON.stringify(id), \"]\")).join(\", \");\n    const variables = Array.from(waitForInstances.keys(), (name, i) => \"\".concat(name, \" = array[\").concat(i, \"]\")).join(\", \");\n    return Template.asString([\"\".concat(JSON.stringify(module.id), \": function() {\"), Template.indent([\"return promiseResolve().then(function() { return Promise.all([\".concat(promises, \"]); }).then(function(array) {\"), Template.indent([\"var \".concat(variables, \";\"), ...importObject]), \"});\"]), \"},\"]);\n  } else {\n    return Template.asString([\"\".concat(JSON.stringify(module.id), \": function() {\"), Template.indent(importObject), \"},\"]);\n  }\n};\n\nclass WasmMainTemplatePlugin {\n  constructor({\n    generateLoadBinaryCode,\n    supportsStreaming,\n    mangleImports\n  }) {\n    this.generateLoadBinaryCode = generateLoadBinaryCode;\n    this.supportsStreaming = supportsStreaming;\n    this.mangleImports = mangleImports;\n  }\n  /**\n   * @param {MainTemplate} mainTemplate main template\n   * @returns {void}\n   */\n\n\n  apply(mainTemplate) {\n    mainTemplate.hooks.localVars.tap(\"WasmMainTemplatePlugin\", (source, chunk) => {\n      const wasmModules = getAllWasmModules(chunk);\n      if (wasmModules.length === 0) return source;\n      const importObjects = wasmModules.map(module => {\n        return generateImportObject(module, this.mangleImports);\n      });\n      return Template.asString([source, \"\", \"// object to store loaded and loading wasm modules\", \"var installedWasmModules = {};\", \"\", // This function is used to delay reading the installed wasm module promises\n      // by a microtask. Sorting them doesn't help because there are egdecases where\n      // sorting is not possible (modules splitted into different chunks).\n      // So we not even trying and solve this by a microtask delay.\n      \"function promiseResolve() { return Promise.resolve(); }\", \"\", \"var wasmImportObjects = {\", Template.indent(importObjects), \"};\"]);\n    });\n    mainTemplate.hooks.requireEnsure.tap(\"WasmMainTemplatePlugin\", (source, chunk, hash) => {\n      const webassemblyModuleFilename = mainTemplate.outputOptions.webassemblyModuleFilename;\n      const chunkModuleMaps = chunk.getChunkModuleMaps(m => m.type.startsWith(\"webassembly\"));\n      if (Object.keys(chunkModuleMaps.id).length === 0) return source;\n      const wasmModuleSrcPath = mainTemplate.getAssetPath(JSON.stringify(webassemblyModuleFilename), {\n        hash: \"\\\" + \".concat(mainTemplate.renderCurrentHashCode(hash), \" + \\\"\"),\n        hashWithLength: length => \"\\\" + \".concat(mainTemplate.renderCurrentHashCode(hash, length), \" + \\\"\"),\n        module: {\n          id: '\" + wasmModuleId + \"',\n          hash: \"\\\" + \".concat(JSON.stringify(chunkModuleMaps.hash), \"[wasmModuleId] + \\\"\"),\n\n          hashWithLength(length) {\n            const shortChunkHashMap = Object.create(null);\n\n            for (const wasmModuleId of Object.keys(chunkModuleMaps.hash)) {\n              if (typeof chunkModuleMaps.hash[wasmModuleId] === \"string\") {\n                shortChunkHashMap[wasmModuleId] = chunkModuleMaps.hash[wasmModuleId].substr(0, length);\n              }\n            }\n\n            return \"\\\" + \".concat(JSON.stringify(shortChunkHashMap), \"[wasmModuleId] + \\\"\");\n          }\n\n        }\n      });\n\n      const createImportObject = content => this.mangleImports ? \"{ \".concat(JSON.stringify(WebAssemblyUtils.MANGLED_MODULE), \": \").concat(content, \" }\") : content;\n\n      return Template.asString([source, \"\", \"// Fetch + compile chunk loading for webassembly\", \"\", \"var wasmModules = \".concat(JSON.stringify(chunkModuleMaps.id), \"[chunkId] || [];\"), \"\", \"wasmModules.forEach(function(wasmModuleId) {\", Template.indent([\"var installedWasmModuleData = installedWasmModules[wasmModuleId];\", \"\", '// a Promise means \"currently loading\" or \"already loaded\".', \"if(installedWasmModuleData)\", Template.indent([\"promises.push(installedWasmModuleData);\"]), \"else {\", Template.indent([\"var importObject = wasmImportObjects[wasmModuleId]();\", \"var req = \".concat(this.generateLoadBinaryCode(wasmModuleSrcPath), \";\"), \"var promise;\", this.supportsStreaming ? Template.asString([\"if(importObject instanceof Promise && typeof WebAssembly.compileStreaming === 'function') {\", Template.indent([\"promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {\", Template.indent([\"return WebAssembly.instantiate(items[0], \".concat(createImportObject(\"items[1]\"), \");\")]), \"});\"]), \"} else if(typeof WebAssembly.instantiateStreaming === 'function') {\", Template.indent([\"promise = WebAssembly.instantiateStreaming(req, \".concat(createImportObject(\"importObject\"), \");\")])]) : Template.asString([\"if(importObject instanceof Promise) {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = Promise.all([\", Template.indent([\"bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),\", \"importObject\"]), \"]).then(function(items) {\", Template.indent([\"return WebAssembly.instantiate(items[0], \".concat(createImportObject(\"items[1]\"), \");\")]), \"});\"])]), \"} else {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = bytesPromise.then(function(bytes) {\", Template.indent([\"return WebAssembly.instantiate(bytes, \".concat(createImportObject(\"importObject\"), \");\")]), \"});\"]), \"}\", \"promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {\", Template.indent([\"return \".concat(mainTemplate.requireFn, \".w[wasmModuleId] = (res.instance || res).exports;\")]), \"}));\"]), \"}\"]), \"});\"]);\n    });\n    mainTemplate.hooks.requireExtensions.tap(\"WasmMainTemplatePlugin\", (source, chunk) => {\n      if (!chunk.hasModuleInGraph(m => m.type.startsWith(\"webassembly\"))) {\n        return source;\n      }\n\n      return Template.asString([source, \"\", \"// object with all WebAssembly.instance exports\", \"\".concat(mainTemplate.requireFn, \".w = {};\")]);\n    });\n    mainTemplate.hooks.hash.tap(\"WasmMainTemplatePlugin\", hash => {\n      hash.update(\"WasmMainTemplatePlugin\");\n      hash.update(\"2\");\n    });\n  }\n\n}\n\nmodule.exports = WasmMainTemplatePlugin;","map":null,"metadata":{},"sourceType":"script"}