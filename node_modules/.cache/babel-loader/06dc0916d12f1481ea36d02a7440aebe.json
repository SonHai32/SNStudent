{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst LoaderDependency = require(\"./LoaderDependency\");\n\nconst NormalModule = require(\"../NormalModule\");\n/** @typedef {import(\"../Module\")} Module */\n\n/**\n * @callback LoadModuleCallback\n * @param {Error=} err error object\n * @param {string=} source source code\n * @param {object=} map source map\n * @param {Module=} module loaded module if successful\n */\n\n\nclass LoaderPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"LoaderPlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      compilation.dependencyFactories.set(LoaderDependency, normalModuleFactory);\n    });\n    compiler.hooks.compilation.tap(\"LoaderPlugin\", compilation => {\n      compilation.hooks.normalModuleLoader.tap(\"LoaderPlugin\", (loaderContext, module) => {\n        /**\n         * @param {string} request the request string to load the module from\n         * @param {LoadModuleCallback} callback callback returning the loaded module or error\n         * @returns {void}\n         */\n        loaderContext.loadModule = (request, callback) => {\n          const dep = new LoaderDependency(request);\n          dep.loc = {\n            name: request\n          };\n          const factory = compilation.dependencyFactories.get(dep.constructor);\n\n          if (factory === undefined) {\n            return callback(new Error(\"No module factory available for dependency type: \".concat(dep.constructor.name)));\n          }\n\n          compilation.semaphore.release();\n          compilation.addModuleDependencies(module, [{\n            factory,\n            dependencies: [dep]\n          }], true, \"lm\", true, err => {\n            compilation.semaphore.acquire(() => {\n              if (err) {\n                return callback(err);\n              }\n\n              if (!dep.module) {\n                return callback(new Error(\"Cannot load the module\"));\n              } // TODO consider removing this in webpack 5\n\n\n              if (dep.module instanceof NormalModule && dep.module.error) {\n                return callback(dep.module.error);\n              }\n\n              if (!dep.module._source) {\n                throw new Error(\"The module created for a LoaderDependency must have a property _source\");\n              }\n\n              let source, map;\n              const moduleSource = dep.module._source;\n\n              if (moduleSource.sourceAndMap) {\n                const sourceAndMap = moduleSource.sourceAndMap();\n                map = sourceAndMap.map;\n                source = sourceAndMap.source;\n              } else {\n                map = moduleSource.map();\n                source = moduleSource.source();\n              }\n\n              if (dep.module.buildInfo.fileDependencies) {\n                for (const d of dep.module.buildInfo.fileDependencies) {\n                  loaderContext.addDependency(d);\n                }\n              }\n\n              if (dep.module.buildInfo.contextDependencies) {\n                for (const d of dep.module.buildInfo.contextDependencies) {\n                  loaderContext.addContextDependency(d);\n                }\n              }\n\n              return callback(null, source, map, dep.module);\n            });\n          });\n        };\n      });\n    });\n  }\n\n}\n\nmodule.exports = LoaderPlugin;","map":null,"metadata":{},"sourceType":"script"}