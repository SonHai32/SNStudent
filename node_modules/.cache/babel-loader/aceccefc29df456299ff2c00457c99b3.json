{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Jason Anderson @diurnalist\n*/\n\"use strict\";\n\nconst REGEXP_HASH = /\\[hash(?::(\\d+))?\\]/gi,\n      REGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/gi,\n      REGEXP_MODULEHASH = /\\[modulehash(?::(\\d+))?\\]/gi,\n      REGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/gi,\n      REGEXP_NAME = /\\[name\\]/gi,\n      REGEXP_ID = /\\[id\\]/gi,\n      REGEXP_MODULEID = /\\[moduleid\\]/gi,\n      REGEXP_FILE = /\\[file\\]/gi,\n      REGEXP_QUERY = /\\[query\\]/gi,\n      REGEXP_FILEBASE = /\\[filebase\\]/gi,\n      REGEXP_URL = /\\[url\\]/gi; // Using global RegExp for .test is dangerous\n// We use a normal RegExp instead of .test\n\nconst REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, \"i\"),\n      REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, \"i\"),\n      REGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, \"i\"),\n      REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, \"i\");\n\nconst withHashLength = (replacer, handlerFn) => {\n  const fn = (match, hashLength, ...args) => {\n    const length = hashLength && parseInt(hashLength, 10);\n\n    if (length && handlerFn) {\n      return handlerFn(length);\n    }\n\n    const hash = replacer(match, hashLength, ...args);\n    return length ? hash.slice(0, length) : hash;\n  };\n\n  return fn;\n};\n\nconst getReplacer = (value, allowEmpty) => {\n  const fn = (match, ...args) => {\n    // last argument in replacer is the entire input string\n    const input = args[args.length - 1];\n\n    if (value === null || value === undefined) {\n      if (!allowEmpty) {\n        throw new Error(\"Path variable \".concat(match, \" not implemented in this context: \").concat(input));\n      }\n\n      return \"\";\n    } else {\n      return \"\".concat(escapePathVariables(value));\n    }\n  };\n\n  return fn;\n};\n\nconst escapePathVariables = value => {\n  return typeof value === \"string\" ? value.replace(/\\[(\\\\*[\\w:]+\\\\*)\\]/gi, \"[\\\\$1\\\\]\") : value;\n};\n\nconst replacePathVariables = (path, data) => {\n  const chunk = data.chunk;\n  const chunkId = chunk && chunk.id;\n  const chunkName = chunk && (chunk.name || chunk.id);\n  const chunkHash = chunk && (chunk.renderedHash || chunk.hash);\n  const chunkHashWithLength = chunk && chunk.hashWithLength;\n  const contentHashType = data.contentHashType;\n  const contentHash = chunk && chunk.contentHash && chunk.contentHash[contentHashType] || data.contentHash;\n  const contentHashWithLength = chunk && chunk.contentHashWithLength && chunk.contentHashWithLength[contentHashType] || data.contentHashWithLength;\n  const module = data.module;\n  const moduleId = module && module.id;\n  const moduleHash = module && (module.renderedHash || module.hash);\n  const moduleHashWithLength = module && module.hashWithLength;\n\n  if (typeof path === \"function\") {\n    path = path(data);\n  }\n\n  if (data.noChunkHash && (REGEXP_CHUNKHASH_FOR_TEST.test(path) || REGEXP_CONTENTHASH_FOR_TEST.test(path))) {\n    throw new Error(\"Cannot use [chunkhash] or [contenthash] for chunk in '\".concat(path, \"' (use [hash] instead)\"));\n  }\n\n  return path.replace(REGEXP_HASH, withHashLength(getReplacer(data.hash), data.hashWithLength)).replace(REGEXP_CHUNKHASH, withHashLength(getReplacer(chunkHash), chunkHashWithLength)).replace(REGEXP_CONTENTHASH, withHashLength(getReplacer(contentHash), contentHashWithLength)).replace(REGEXP_MODULEHASH, withHashLength(getReplacer(moduleHash), moduleHashWithLength)).replace(REGEXP_ID, getReplacer(chunkId)).replace(REGEXP_MODULEID, getReplacer(moduleId)).replace(REGEXP_NAME, getReplacer(chunkName)).replace(REGEXP_FILE, getReplacer(data.filename)).replace(REGEXP_FILEBASE, getReplacer(data.basename)) // query is optional, it's OK if it's in a path but there's nothing to replace it with\n  .replace(REGEXP_QUERY, getReplacer(data.query, true)) // only available in sourceMappingURLComment\n  .replace(REGEXP_URL, getReplacer(data.url)).replace(/\\[\\\\(\\\\*[\\w:]+\\\\*)\\\\\\]/gi, \"[$1]\");\n};\n\nclass TemplatedPathPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"TemplatedPathPlugin\", compilation => {\n      const mainTemplate = compilation.mainTemplate;\n      mainTemplate.hooks.assetPath.tap(\"TemplatedPathPlugin\", replacePathVariables);\n      mainTemplate.hooks.globalHash.tap(\"TemplatedPathPlugin\", (chunk, paths) => {\n        const outputOptions = mainTemplate.outputOptions;\n        const publicPath = outputOptions.publicPath || \"\";\n        const filename = outputOptions.filename || \"\";\n        const chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n        if (REGEXP_HASH_FOR_TEST.test(publicPath) || REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) || REGEXP_CONTENTHASH_FOR_TEST.test(publicPath) || REGEXP_NAME_FOR_TEST.test(publicPath)) return true;\n        if (REGEXP_HASH_FOR_TEST.test(filename)) return true;\n        if (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;\n        if (REGEXP_HASH_FOR_TEST.test(paths.join(\"|\"))) return true;\n      });\n      mainTemplate.hooks.hashForChunk.tap(\"TemplatedPathPlugin\", (hash, chunk) => {\n        const outputOptions = mainTemplate.outputOptions;\n        const chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n\n        if (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n        }\n\n        if (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash.javascript || {}));\n        }\n\n        if (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = TemplatedPathPlugin;","map":null,"metadata":{},"sourceType":"script"}