{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst _require = require(\"webpack-sources\"),\n      ConcatSource = _require.ConcatSource,\n      OriginalSource = _require.OriginalSource,\n      PrefixSource = _require.PrefixSource,\n      RawSource = _require.RawSource;\n\nconst _require2 = require(\"tapable\"),\n      Tapable = _require2.Tapable,\n      SyncWaterfallHook = _require2.SyncWaterfallHook,\n      SyncHook = _require2.SyncHook,\n      SyncBailHook = _require2.SyncBailHook;\n\nconst Template = require(\"./Template\");\n/** @typedef {import(\"webpack-sources\").ConcatSource} ConcatSource */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"./ModuleTemplate\")} ModuleTemplate */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Module\")} Module} */\n\n/** @typedef {import(\"./util/createHash\").Hash} Hash} */\n\n/** @typedef {import(\"./Dependency\").DependencyTemplate} DependencyTemplate} */\n\n/**\n * @typedef {Object} RenderManifestOptions\n * @property {Chunk} chunk the chunk used to render\n * @property {string} hash\n * @property {string} fullHash\n * @property {TODO} outputOptions\n * @property {{javascript: ModuleTemplate, webassembly: ModuleTemplate}} moduleTemplates\n * @property {Map<TODO, TODO>} dependencyTemplates\n */\n// require function shortcuts:\n// __webpack_require__.s = the module id of the entry point\n// __webpack_require__.c = the module cache\n// __webpack_require__.m = the module functions\n// __webpack_require__.p = the bundle public path\n// __webpack_require__.i = the identity function used for harmony imports\n// __webpack_require__.e = the chunk ensure function\n// __webpack_require__.d = the exported property define getter function\n// __webpack_require__.o = Object.prototype.hasOwnProperty.call\n// __webpack_require__.r = define compatibility on export\n// __webpack_require__.t = create a fake namespace object\n// __webpack_require__.n = compatibility get default export\n// __webpack_require__.h = the webpack hash\n// __webpack_require__.w = an object containing all installed WebAssembly.Instance export objects keyed by module id\n// __webpack_require__.oe = the uncaught error handler for the webpack runtime\n// __webpack_require__.nc = the script nonce\n\n\nmodule.exports = class MainTemplate extends Tapable {\n  /**\n   *\n   * @param {TODO=} outputOptions output options for the MainTemplate\n   */\n  constructor(outputOptions) {\n    super();\n    /** @type {TODO?} */\n\n    this.outputOptions = outputOptions || {};\n    this.hooks = {\n      /** @type {SyncWaterfallHook<TODO[], RenderManifestOptions>} */\n      renderManifest: new SyncWaterfallHook([\"result\", \"options\"]),\n      modules: new SyncWaterfallHook([\"modules\", \"chunk\", \"hash\", \"moduleTemplate\", \"dependencyTemplates\"]),\n      moduleObj: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleIdExpression\"]),\n      requireEnsure: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"chunkIdExpression\"]),\n      bootstrap: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleTemplate\", \"dependencyTemplates\"]),\n      localVars: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      require: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      requireExtensions: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n\n      /** @type {SyncWaterfallHook<string, Chunk, string>} */\n      beforeStartup: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n\n      /** @type {SyncWaterfallHook<string, Chunk, string>} */\n      startup: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n\n      /** @type {SyncWaterfallHook<string, Chunk, string>} */\n      afterStartup: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      render: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleTemplate\", \"dependencyTemplates\"]),\n      renderWithEntry: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      moduleRequire: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleIdExpression\"]),\n      addModule: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleIdExpression\", \"moduleExpression\"]),\n      currentHash: new SyncWaterfallHook([\"source\", \"requestedLength\"]),\n      assetPath: new SyncWaterfallHook([\"path\", \"options\"]),\n      hash: new SyncHook([\"hash\"]),\n      hashForChunk: new SyncHook([\"hash\", \"chunk\"]),\n      globalHashPaths: new SyncWaterfallHook([\"paths\"]),\n      globalHash: new SyncBailHook([\"chunk\", \"paths\"]),\n      // TODO this should be moved somewhere else\n      // It's weird here\n      hotBootstrap: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"])\n    };\n    this.hooks.startup.tap(\"MainTemplate\", (source, chunk, hash) => {\n      /** @type {string[]} */\n      const buf = [];\n\n      if (chunk.entryModule) {\n        buf.push(\"// Load entry module and return exports\");\n        buf.push(\"return \".concat(this.renderRequireFunctionForModule(hash, chunk, JSON.stringify(chunk.entryModule.id)), \"(\").concat(this.requireFn, \".s = \").concat(JSON.stringify(chunk.entryModule.id), \");\"));\n      }\n\n      return Template.asString(buf);\n    });\n    this.hooks.render.tap(\"MainTemplate\", (bootstrapSource, chunk, hash, moduleTemplate, dependencyTemplates) => {\n      const source = new ConcatSource();\n      source.add(\"/******/ (function(modules) { // webpackBootstrap\\n\");\n      source.add(new PrefixSource(\"/******/\", bootstrapSource));\n      source.add(\"/******/ })\\n\");\n      source.add(\"/************************************************************************/\\n\");\n      source.add(\"/******/ (\");\n      source.add(this.hooks.modules.call(new RawSource(\"\"), chunk, hash, moduleTemplate, dependencyTemplates));\n      source.add(\")\");\n      return source;\n    });\n    this.hooks.localVars.tap(\"MainTemplate\", (source, chunk, hash) => {\n      return Template.asString([source, \"// The module cache\", \"var installedModules = {};\"]);\n    });\n\n    this.hooks.require.tap(\"MainTemplate\", (source, chunk, hash) => {\n      return Template.asString([source, \"// Check if module is in cache\", \"if(installedModules[moduleId]) {\", Template.indent(\"return installedModules[moduleId].exports;\"), \"}\", \"// Create a new module (and put it into the cache)\", \"var module = installedModules[moduleId] = {\", Template.indent(this.hooks.moduleObj.call(\"\", chunk, hash, \"moduleId\")), \"};\", \"\", Template.asString(outputOptions.strictModuleExceptionHandling ? [\"// Execute the module function\", \"var threw = true;\", \"try {\", Template.indent([\"modules[moduleId].call(module.exports, module, module.exports, \".concat(this.renderRequireFunctionForModule(hash, chunk, \"moduleId\"), \");\"), \"threw = false;\"]), \"} finally {\", Template.indent([\"if(threw) delete installedModules[moduleId];\"]), \"}\"] : [\"// Execute the module function\", \"modules[moduleId].call(module.exports, module, module.exports, \".concat(this.renderRequireFunctionForModule(hash, chunk, \"moduleId\"), \");\")]), \"\", \"// Flag the module as loaded\", \"module.l = true;\", \"\", \"// Return the exports of the module\", \"return module.exports;\"]);\n    });\n\n    this.hooks.moduleObj.tap(\"MainTemplate\", (source, chunk, hash, varModuleId) => {\n      return Template.asString([\"i: moduleId,\", \"l: false,\", \"exports: {}\"]);\n    });\n    this.hooks.requireExtensions.tap(\"MainTemplate\", (source, chunk, hash) => {\n      const buf = [];\n      const chunkMaps = chunk.getChunkMaps(); // Check if there are non initial chunks which need to be imported using require-ensure\n\n      if (Object.keys(chunkMaps.hash).length) {\n        buf.push(\"// This file contains only the entry chunk.\");\n        buf.push(\"// The chunk loading function for additional chunks\");\n        buf.push(\"\".concat(this.requireFn, \".e = function requireEnsure(chunkId) {\"));\n        buf.push(Template.indent(\"var promises = [];\"));\n        buf.push(Template.indent(this.hooks.requireEnsure.call(\"\", chunk, hash, \"chunkId\")));\n        buf.push(Template.indent(\"return Promise.all(promises);\"));\n        buf.push(\"};\");\n      } else if (chunk.hasModuleInGraph(m => m.blocks.some(b => b.chunkGroup && b.chunkGroup.chunks.length > 0))) {\n        // There async blocks in the graph, so we need to add an empty requireEnsure\n        // function anyway. This can happen with multiple entrypoints.\n        buf.push(\"// The chunk loading function for additional chunks\");\n        buf.push(\"// Since all referenced chunks are already included\");\n        buf.push(\"// in this file, this function is empty here.\");\n        buf.push(\"\".concat(this.requireFn, \".e = function requireEnsure() {\"));\n        buf.push(Template.indent(\"return Promise.resolve();\"));\n        buf.push(\"};\");\n      }\n\n      buf.push(\"\");\n      buf.push(\"// expose the modules object (__webpack_modules__)\");\n      buf.push(\"\".concat(this.requireFn, \".m = modules;\"));\n      buf.push(\"\");\n      buf.push(\"// expose the module cache\");\n      buf.push(\"\".concat(this.requireFn, \".c = installedModules;\"));\n      buf.push(\"\");\n      buf.push(\"// define getter function for harmony exports\");\n      buf.push(\"\".concat(this.requireFn, \".d = function(exports, name, getter) {\"));\n      buf.push(Template.indent([\"if(!\".concat(this.requireFn, \".o(exports, name)) {\"), Template.indent([\"Object.defineProperty(exports, name, { enumerable: true, get: getter });\"]), \"}\"]));\n      buf.push(\"};\");\n      buf.push(\"\");\n      buf.push(\"// define __esModule on exports\");\n      buf.push(\"\".concat(this.requireFn, \".r = function(exports) {\"));\n      buf.push(Template.indent([\"if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\", Template.indent([\"Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\"]), \"}\", \"Object.defineProperty(exports, '__esModule', { value: true });\"]));\n      buf.push(\"};\");\n      buf.push(\"\");\n      buf.push(\"// create a fake namespace object\");\n      buf.push(\"// mode & 1: value is a module id, require it\");\n      buf.push(\"// mode & 2: merge all properties of value into the ns\");\n      buf.push(\"// mode & 4: return value when already ns object\");\n      buf.push(\"// mode & 8|1: behave like require\");\n      buf.push(\"\".concat(this.requireFn, \".t = function(value, mode) {\"));\n      buf.push(Template.indent([\"if(mode & 1) value = \".concat(this.requireFn, \"(value);\"), \"if(mode & 8) return value;\", \"if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\", \"var ns = Object.create(null);\", \"\".concat(this.requireFn, \".r(ns);\"), \"Object.defineProperty(ns, 'default', { enumerable: true, value: value });\", \"if(mode & 2 && typeof value != 'string') for(var key in value) \" + \"\".concat(this.requireFn, \".d(ns, key, function(key) { \") + \"return value[key]; \" + \"}.bind(null, key));\", \"return ns;\"]));\n      buf.push(\"};\");\n      buf.push(\"\");\n      buf.push(\"// getDefaultExport function for compatibility with non-harmony modules\");\n      buf.push(this.requireFn + \".n = function(module) {\");\n      buf.push(Template.indent([\"var getter = module && module.__esModule ?\", Template.indent([\"function getDefault() { return module['default']; } :\", \"function getModuleExports() { return module; };\"]), \"\".concat(this.requireFn, \".d(getter, 'a', getter);\"), \"return getter;\"]));\n      buf.push(\"};\");\n      buf.push(\"\");\n      buf.push(\"// Object.prototype.hasOwnProperty.call\");\n      buf.push(\"\".concat(this.requireFn, \".o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\"));\n      const publicPath = this.getPublicPath({\n        hash: hash\n      });\n      buf.push(\"\");\n      buf.push(\"// __webpack_public_path__\");\n      buf.push(\"\".concat(this.requireFn, \".p = \").concat(JSON.stringify(publicPath), \";\"));\n      return Template.asString(buf);\n    });\n    this.requireFn = \"__webpack_require__\";\n  }\n  /**\n   *\n   * @param {RenderManifestOptions} options render manifest options\n   * @returns {TODO[]} returns render manifest\n   */\n\n\n  getRenderManifest(options) {\n    const result = [];\n    this.hooks.renderManifest.call(result, options);\n    return result;\n  }\n  /**\n   * TODO webpack 5: remove moduleTemplate and dependencyTemplates\n   * @param {string} hash hash to be used for render call\n   * @param {Chunk} chunk Chunk instance\n   * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates\n   * @returns {string[]} the generated source of the bootstrap code\n   */\n\n\n  renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates) {\n    const buf = [];\n    buf.push(this.hooks.bootstrap.call(\"\", chunk, hash, moduleTemplate, dependencyTemplates));\n    buf.push(this.hooks.localVars.call(\"\", chunk, hash));\n    buf.push(\"\");\n    buf.push(\"// The require function\");\n    buf.push(\"function \".concat(this.requireFn, \"(moduleId) {\"));\n    buf.push(Template.indent(this.hooks.require.call(\"\", chunk, hash)));\n    buf.push(\"}\");\n    buf.push(\"\");\n    buf.push(Template.asString(this.hooks.requireExtensions.call(\"\", chunk, hash)));\n    buf.push(\"\");\n    buf.push(Template.asString(this.hooks.beforeStartup.call(\"\", chunk, hash)));\n    const afterStartupCode = Template.asString(this.hooks.afterStartup.call(\"\", chunk, hash));\n\n    if (afterStartupCode) {\n      // TODO webpack 5: this is a bit hacky to avoid a breaking change\n      // change it to a better way\n      buf.push(\"var startupResult = (function() {\");\n    }\n\n    buf.push(Template.asString(this.hooks.startup.call(\"\", chunk, hash)));\n\n    if (afterStartupCode) {\n      buf.push(\"})();\");\n      buf.push(afterStartupCode);\n      buf.push(\"return startupResult;\");\n    }\n\n    return buf;\n  }\n  /**\n   * @param {string} hash hash to be used for render call\n   * @param {Chunk} chunk Chunk instance\n   * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates\n   * @returns {ConcatSource} the newly generated source from rendering\n   */\n\n\n  render(hash, chunk, moduleTemplate, dependencyTemplates) {\n    const buf = this.renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates);\n    let source = this.hooks.render.call(new OriginalSource(Template.prefix(buf, \" \\t\") + \"\\n\", \"webpack/bootstrap\"), chunk, hash, moduleTemplate, dependencyTemplates);\n\n    if (chunk.hasEntryModule()) {\n      source = this.hooks.renderWithEntry.call(source, chunk, hash);\n    }\n\n    if (!source) {\n      throw new Error(\"Compiler error: MainTemplate plugin 'render' should return something\");\n    }\n\n    chunk.rendered = true;\n    return new ConcatSource(source, \";\");\n  }\n  /**\n   *\n   * @param {string} hash hash for render fn\n   * @param {Chunk} chunk Chunk instance for require\n   * @param {(number|string)=} varModuleId module id\n   * @returns {TODO} the moduleRequire hook call return signature\n   */\n\n\n  renderRequireFunctionForModule(hash, chunk, varModuleId) {\n    return this.hooks.moduleRequire.call(this.requireFn, chunk, hash, varModuleId);\n  }\n  /**\n   *\n   * @param {string} hash hash for render add fn\n   * @param {Chunk} chunk Chunk instance for require add fn\n   * @param {(string|number)=} varModuleId module id\n   * @param {Module} varModule Module instance\n   * @returns {TODO} renderAddModule call\n   */\n\n\n  renderAddModule(hash, chunk, varModuleId, varModule) {\n    return this.hooks.addModule.call(\"modules[\".concat(varModuleId, \"] = \").concat(varModule, \";\"), chunk, hash, varModuleId, varModule);\n  }\n  /**\n   *\n   * @param {string} hash string hash\n   * @param {number=} length length\n   * @returns {string} call hook return\n   */\n\n\n  renderCurrentHashCode(hash, length) {\n    length = length || Infinity;\n    return this.hooks.currentHash.call(JSON.stringify(hash.substr(0, length)), length);\n  }\n  /**\n   *\n   * @param {object} options get public path options\n   * @returns {string} hook call\n   */\n\n\n  getPublicPath(options) {\n    return this.hooks.assetPath.call(this.outputOptions.publicPath || \"\", options);\n  }\n\n  getAssetPath(path, options) {\n    return this.hooks.assetPath.call(path, options);\n  }\n  /**\n   * Updates hash with information from this template\n   * @param {Hash} hash the hash to update\n   * @returns {void}\n   */\n\n\n  updateHash(hash) {\n    hash.update(\"maintemplate\");\n    hash.update(\"3\");\n    this.hooks.hash.call(hash);\n  }\n  /**\n   * TODO webpack 5: remove moduleTemplate and dependencyTemplates\n   * Updates hash with chunk-specific information from this template\n   * @param {Hash} hash the hash to update\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates\n   * @returns {void}\n   */\n\n\n  updateHashForChunk(hash, chunk, moduleTemplate, dependencyTemplates) {\n    this.updateHash(hash);\n    this.hooks.hashForChunk.call(hash, chunk);\n\n    for (const line of this.renderBootstrap(\"0000\", chunk, moduleTemplate, dependencyTemplates)) {\n      hash.update(line);\n    }\n  }\n\n  useChunkHash(chunk) {\n    const paths = this.hooks.globalHashPaths.call([]);\n    return !this.hooks.globalHash.call(chunk, paths);\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}