{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\n\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\nconst ParserHelpers = require(\"./ParserHelpers\");\n\nconst NullFactory = require(\"./NullFactory\");\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Parser\")} Parser */\n\n/** @typedef {null|undefined|RegExp|Function|string|number} CodeValuePrimitive */\n\n/** @typedef {CodeValuePrimitive|Record<string, CodeValuePrimitive>|RuntimeValue} CodeValue */\n\n\nclass RuntimeValue {\n  constructor(fn, fileDependencies) {\n    this.fn = fn;\n    this.fileDependencies = fileDependencies || [];\n  }\n\n  exec(parser) {\n    if (this.fileDependencies === true) {\n      parser.state.module.buildInfo.cacheable = false;\n    } else {\n      for (const fileDependency of this.fileDependencies) {\n        parser.state.module.buildInfo.fileDependencies.add(fileDependency);\n      }\n    }\n\n    return this.fn({\n      module: parser.state.module\n    });\n  }\n\n}\n\nconst stringifyObj = (obj, parser) => {\n  return \"Object({\" + Object.keys(obj).map(key => {\n    const code = obj[key];\n    return JSON.stringify(key) + \":\" + toCode(code, parser);\n  }).join(\",\") + \"})\";\n};\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {Parser} parser Parser\n * @returns {string} code converted to string that evaluates\n */\n\n\nconst toCode = (code, parser) => {\n  if (code === null) {\n    return \"null\";\n  }\n\n  if (code === undefined) {\n    return \"undefined\";\n  }\n\n  if (code instanceof RuntimeValue) {\n    return toCode(code.exec(parser), parser);\n  }\n\n  if (code instanceof RegExp && code.toString) {\n    return code.toString();\n  }\n\n  if (typeof code === \"function\" && code.toString) {\n    return \"(\" + code.toString() + \")\";\n  }\n\n  if (typeof code === \"object\") {\n    return stringifyObj(code, parser);\n  }\n\n  return code + \"\";\n};\n\nclass DefinePlugin {\n  /**\n   * Create a new define plugin\n   * @param {Record<string, CodeValue>} definitions A map of global object definitions\n   */\n  constructor(definitions) {\n    this.definitions = definitions;\n  }\n\n  static runtimeValue(fn, fileDependencies) {\n    return new RuntimeValue(fn, fileDependencies);\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler Webpack compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const definitions = this.definitions;\n    compiler.hooks.compilation.tap(\"DefinePlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      compilation.dependencyFactories.set(ConstDependency, new NullFactory());\n      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n      /**\n       * Handler\n       * @param {Parser} parser Parser\n       * @returns {void}\n       */\n\n      const handler = parser => {\n        /**\n         * Walk definitions\n         * @param {Object} definitions Definitions map\n         * @param {string} prefix Prefix string\n         * @returns {void}\n         */\n        const walkDefinitions = (definitions, prefix) => {\n          Object.keys(definitions).forEach(key => {\n            const code = definitions[key];\n\n            if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n              walkDefinitions(code, prefix + key + \".\");\n              applyObjectDefine(prefix + key, code);\n              return;\n            }\n\n            applyDefineKey(prefix, key);\n            applyDefine(prefix + key, code);\n          });\n        };\n        /**\n         * Apply define key\n         * @param {string} prefix Prefix\n         * @param {string} key Key\n         * @returns {void}\n         */\n\n\n        const applyDefineKey = (prefix, key) => {\n          const splittedKey = key.split(\".\");\n          splittedKey.slice(1).forEach((_, i) => {\n            const fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n            parser.hooks.canRename.for(fullKey).tap(\"DefinePlugin\", ParserHelpers.approve);\n          });\n        };\n        /**\n         * Apply Code\n         * @param {string} key Key\n         * @param {CodeValue} code Code\n         * @returns {void}\n         */\n\n\n        const applyDefine = (key, code) => {\n          const isTypeof = /^typeof\\s+/.test(key);\n          if (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n          let recurse = false;\n          let recurseTypeof = false;\n\n          if (!isTypeof) {\n            parser.hooks.canRename.for(key).tap(\"DefinePlugin\", ParserHelpers.approve);\n            parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", expr => {\n              /**\n               * this is needed in case there is a recursion in the DefinePlugin\n               * to prevent an endless recursion\n               * e.g.: new DefinePlugin({\n               * \"a\": \"b\",\n               * \"b\": \"a\"\n               * });\n               */\n              if (recurse) return;\n              recurse = true;\n              const res = parser.evaluate(toCode(code, parser));\n              recurse = false;\n              res.setRange(expr.range);\n              return res;\n            });\n            parser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n              const strCode = toCode(code, parser);\n\n              if (/__webpack_require__/.test(strCode)) {\n                return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);\n              } else {\n                return ParserHelpers.toConstantDependency(parser, strCode)(expr);\n              }\n            });\n          }\n\n          parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n            /**\n             * this is needed in case there is a recursion in the DefinePlugin\n             * to prevent an endless recursion\n             * e.g.: new DefinePlugin({\n             * \"typeof a\": \"typeof b\",\n             * \"typeof b\": \"typeof a\"\n             * });\n             */\n            if (recurseTypeof) return;\n            recurseTypeof = true;\n            const typeofCode = isTypeof ? toCode(code, parser) : \"typeof (\" + toCode(code, parser) + \")\";\n            const res = parser.evaluate(typeofCode);\n            recurseTypeof = false;\n            res.setRange(expr.range);\n            return res;\n          });\n          parser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n            const typeofCode = isTypeof ? toCode(code, parser) : \"typeof (\" + toCode(code, parser) + \")\";\n            const res = parser.evaluate(typeofCode);\n            if (!res.isString()) return;\n            return ParserHelpers.toConstantDependency(parser, JSON.stringify(res.string)).bind(parser)(expr);\n          });\n        };\n        /**\n         * Apply Object\n         * @param {string} key Key\n         * @param {Object} obj Object\n         * @returns {void}\n         */\n\n\n        const applyObjectDefine = (key, obj) => {\n          parser.hooks.canRename.for(key).tap(\"DefinePlugin\", ParserHelpers.approve);\n          parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", expr => new BasicEvaluatedExpression().setTruthy().setRange(expr.range));\n          parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n            return ParserHelpers.evaluateToString(\"object\")(expr);\n          });\n          parser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n            const strCode = stringifyObj(obj, parser);\n\n            if (/__webpack_require__/.test(strCode)) {\n              return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);\n            } else {\n              return ParserHelpers.toConstantDependency(parser, strCode)(expr);\n            }\n          });\n          parser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n            return ParserHelpers.toConstantDependency(parser, JSON.stringify(\"object\"))(expr);\n          });\n        };\n\n        walkDefinitions(definitions, \"\");\n      };\n\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"DefinePlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"DefinePlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"DefinePlugin\", handler);\n    });\n  }\n\n}\n\nmodule.exports = DefinePlugin;","map":null,"metadata":{},"sourceType":"script"}