{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst _require = require(\"webpack-sources\"),\n      ConcatSource = _require.ConcatSource,\n      OriginalSource = _require.OriginalSource;\n\nconst Template = require(\"./Template\");\n/** @typedef {import(\"../declarations/WebpackOptions\").LibraryCustomUmdObject} LibraryCustomUmdObject */\n\n/** @typedef {import(\"./Compilation\")} Compilation */\n\n/**\n * @param {string[]} accessor the accessor to convert to path\n * @returns {string} the path\n */\n\n\nconst accessorToObjectAccess = accessor => {\n  return accessor.map(a => \"[\".concat(JSON.stringify(a), \"]\")).join(\"\");\n};\n/**\n * @param {string=} base the path prefix\n * @param {string|string[]} accessor the accessor\n * @param {string=} joinWith the element separator\n * @returns {string} the path\n */\n\n\nconst accessorAccess = (base, accessor, joinWith = \", \") => {\n  const accessors = Array.isArray(accessor) ? accessor : [accessor];\n  return accessors.map((_, idx) => {\n    const a = base ? base + accessorToObjectAccess(accessors.slice(0, idx + 1)) : accessors[0] + accessorToObjectAccess(accessors.slice(1, idx + 1));\n    if (idx === accessors.length - 1) return a;\n    if (idx === 0 && base === undefined) return \"\".concat(a, \" = typeof \").concat(a, \" === \\\"object\\\" ? \").concat(a, \" : {}\");\n    return \"\".concat(a, \" = \").concat(a, \" || {}\");\n  }).join(joinWith);\n};\n/** @typedef {string | string[] | LibraryCustomUmdObject} UmdMainTemplatePluginName */\n\n/**\n * @typedef {Object} AuxiliaryCommentObject\n * @property {string} root\n * @property {string} commonjs\n * @property {string} commonjs2\n * @property {string} amd\n */\n\n/**\n * @typedef {Object} UmdMainTemplatePluginOption\n * @property {boolean=} optionalAmdExternalAsGlobal\n * @property {boolean} namedDefine\n * @property {string | AuxiliaryCommentObject} auxiliaryComment\n */\n\n\nclass UmdMainTemplatePlugin {\n  /**\n   * @param {UmdMainTemplatePluginName} name the name of the UMD library\n   * @param {UmdMainTemplatePluginOption} options the plugin option\n   */\n  constructor(name, options) {\n    if (typeof name === \"object\" && !Array.isArray(name)) {\n      this.name = name.root || name.amd || name.commonjs;\n      this.names = name;\n    } else {\n      this.name = name;\n      this.names = {\n        commonjs: name,\n        root: name,\n        amd: name\n      };\n    }\n\n    this.optionalAmdExternalAsGlobal = options.optionalAmdExternalAsGlobal;\n    this.namedDefine = options.namedDefine;\n    this.auxiliaryComment = options.auxiliaryComment;\n  }\n  /**\n   * @param {Compilation} compilation the compilation instance\n   * @returns {void}\n   */\n\n\n  apply(compilation) {\n    const mainTemplate = compilation.mainTemplate,\n          chunkTemplate = compilation.chunkTemplate,\n          runtimeTemplate = compilation.runtimeTemplate;\n\n    const onRenderWithEntry = (source, chunk, hash) => {\n      let externals = chunk.getModules().filter(m => m.external && (m.externalType === \"umd\" || m.externalType === \"umd2\"));\n      const optionalExternals = [];\n      let requiredExternals = [];\n\n      if (this.optionalAmdExternalAsGlobal) {\n        for (const m of externals) {\n          if (m.optional) {\n            optionalExternals.push(m);\n          } else {\n            requiredExternals.push(m);\n          }\n        }\n\n        externals = requiredExternals.concat(optionalExternals);\n      } else {\n        requiredExternals = externals;\n      }\n\n      const replaceKeys = str => {\n        return mainTemplate.getAssetPath(str, {\n          hash,\n          chunk\n        });\n      };\n\n      const externalsDepsArray = modules => {\n        return \"[\".concat(replaceKeys(modules.map(m => JSON.stringify(typeof m.request === \"object\" ? m.request.amd : m.request)).join(\", \")), \"]\");\n      };\n\n      const externalsRootArray = modules => {\n        return replaceKeys(modules.map(m => {\n          let request = m.request;\n          if (typeof request === \"object\") request = request.root;\n          return \"root\".concat(accessorToObjectAccess([].concat(request)));\n        }).join(\", \"));\n      };\n\n      const externalsRequireArray = type => {\n        return replaceKeys(externals.map(m => {\n          let expr;\n          let request = m.request;\n\n          if (typeof request === \"object\") {\n            request = request[type];\n          }\n\n          if (request === undefined) {\n            throw new Error(\"Missing external configuration for type:\" + type);\n          }\n\n          if (Array.isArray(request)) {\n            expr = \"require(\".concat(JSON.stringify(request[0]), \")\").concat(accessorToObjectAccess(request.slice(1)));\n          } else {\n            expr = \"require(\".concat(JSON.stringify(request), \")\");\n          }\n\n          if (m.optional) {\n            expr = \"(function webpackLoadOptionalExternalModule() { try { return \".concat(expr, \"; } catch(e) {} }())\");\n          }\n\n          return expr;\n        }).join(\", \"));\n      };\n\n      const externalsArguments = modules => {\n        return modules.map(m => \"__WEBPACK_EXTERNAL_MODULE_\".concat(Template.toIdentifier(\"\".concat(m.id)), \"__\")).join(\", \");\n      };\n\n      const libraryName = library => {\n        return JSON.stringify(replaceKeys([].concat(library).pop()));\n      };\n\n      let amdFactory;\n\n      if (optionalExternals.length > 0) {\n        const wrapperArguments = externalsArguments(requiredExternals);\n        const factoryArguments = requiredExternals.length > 0 ? externalsArguments(requiredExternals) + \", \" + externalsRootArray(optionalExternals) : externalsRootArray(optionalExternals);\n        amdFactory = \"function webpackLoadOptionalExternalModuleAmd(\".concat(wrapperArguments, \") {\\n\") + \"\\t\\t\\treturn factory(\".concat(factoryArguments, \");\\n\") + \"\t\t}\";\n      } else {\n        amdFactory = \"factory\";\n      }\n\n      const auxiliaryComment = this.auxiliaryComment;\n\n      const getAuxilaryComment = type => {\n        if (auxiliaryComment) {\n          if (typeof auxiliaryComment === \"string\") return \"\\t//\" + auxiliaryComment + \"\\n\";\n          if (auxiliaryComment[type]) return \"\\t//\" + auxiliaryComment[type] + \"\\n\";\n        }\n\n        return \"\";\n      };\n\n      return new ConcatSource(new OriginalSource(\"(function webpackUniversalModuleDefinition(root, factory) {\\n\" + getAuxilaryComment(\"commonjs2\") + \"\tif(typeof exports === 'object' && typeof module === 'object')\\n\" + \"\t\tmodule.exports = factory(\" + externalsRequireArray(\"commonjs2\") + \");\\n\" + getAuxilaryComment(\"amd\") + \"\telse if(typeof define === 'function' && define.amd)\\n\" + (requiredExternals.length > 0 ? this.names.amd && this.namedDefine === true ? \"\t\tdefine(\" + libraryName(this.names.amd) + \", \" + externalsDepsArray(requiredExternals) + \", \" + amdFactory + \");\\n\" : \"\t\tdefine(\" + externalsDepsArray(requiredExternals) + \", \" + amdFactory + \");\\n\" : this.names.amd && this.namedDefine === true ? \"\t\tdefine(\" + libraryName(this.names.amd) + \", [], \" + amdFactory + \");\\n\" : \"\t\tdefine([], \" + amdFactory + \");\\n\") + (this.names.root || this.names.commonjs ? getAuxilaryComment(\"commonjs\") + \"\telse if(typeof exports === 'object')\\n\" + \"\t\texports[\" + libraryName(this.names.commonjs || this.names.root) + \"] = factory(\" + externalsRequireArray(\"commonjs\") + \");\\n\" + getAuxilaryComment(\"root\") + \"\telse\\n\" + \"\t\t\" + replaceKeys(accessorAccess(\"root\", this.names.root || this.names.commonjs)) + \" = factory(\" + externalsRootArray(externals) + \");\\n\" : \"\telse {\\n\" + (externals.length > 0 ? \"\t\tvar a = typeof exports === 'object' ? factory(\" + externalsRequireArray(\"commonjs\") + \") : factory(\" + externalsRootArray(externals) + \");\\n\" : \"\t\tvar a = factory();\\n\") + \"\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\\n\" + \"\t}\\n\") + \"})(\".concat(runtimeTemplate.outputOptions.globalObject, \", function(\").concat(externalsArguments(externals), \") {\\nreturn \"), \"webpack/universalModuleDefinition\"), source, \";\\n})\");\n    };\n\n    for (const template of [mainTemplate, chunkTemplate]) {\n      template.hooks.renderWithEntry.tap(\"UmdMainTemplatePlugin\", onRenderWithEntry);\n    }\n\n    mainTemplate.hooks.globalHashPaths.tap(\"UmdMainTemplatePlugin\", paths => {\n      if (this.names.root) paths = paths.concat(this.names.root);\n      if (this.names.amd) paths = paths.concat(this.names.amd);\n      if (this.names.commonjs) paths = paths.concat(this.names.commonjs);\n      return paths;\n    });\n    mainTemplate.hooks.hash.tap(\"UmdMainTemplatePlugin\", hash => {\n      hash.update(\"umd\");\n      hash.update(\"\".concat(this.names.root));\n      hash.update(\"\".concat(this.names.amd));\n      hash.update(\"\".concat(this.names.commonjs));\n    });\n  }\n\n}\n\nmodule.exports = UmdMainTemplatePlugin;","map":null,"metadata":{},"sourceType":"script"}