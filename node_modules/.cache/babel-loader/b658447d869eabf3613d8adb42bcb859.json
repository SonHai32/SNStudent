{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n\nconst Tapable = require(\"tapable/lib/Tapable\");\n\nconst SyncHook = require(\"tapable/lib/SyncHook\");\n\nconst AsyncSeriesBailHook = require(\"tapable/lib/AsyncSeriesBailHook\");\n\nconst AsyncSeriesHook = require(\"tapable/lib/AsyncSeriesHook\");\n\nconst createInnerContext = require(\"./createInnerContext\");\n\nconst REGEXP_NOT_MODULE = /^\\.$|^\\.[\\\\\\/]|^\\.\\.$|^\\.\\.[\\/\\\\]|^\\/|^[A-Z]:[\\\\\\/]/i;\nconst REGEXP_DIRECTORY = /[\\/\\\\]$/i;\n\nconst memoryFsJoin = require(\"memory-fs/lib/join\");\n\nconst memoizedJoin = new Map();\n\nconst memoryFsNormalize = require(\"memory-fs/lib/normalize\");\n\nfunction withName(name, hook) {\n  hook.name = name;\n  return hook;\n}\n\nfunction toCamelCase(str) {\n  return str.replace(/-([a-z])/g, str => str.substr(1).toUpperCase());\n}\n\nconst deprecatedPushToMissing = util.deprecate((set, item) => {\n  set.add(item);\n}, \"Resolver: 'missing' is now a Set. Use add instead of push.\");\nconst deprecatedResolveContextInCallback = util.deprecate(x => {\n  return x;\n}, \"Resolver: The callback argument was splitted into resolveContext and callback.\");\nconst deprecatedHookAsString = util.deprecate(x => {\n  return x;\n}, \"Resolver#doResolve: The type arguments (string) is now a hook argument (Hook). Pass a reference to the hook instead.\");\n\nclass Resolver extends Tapable {\n  constructor(fileSystem) {\n    super();\n    this.fileSystem = fileSystem;\n    this.hooks = {\n      resolveStep: withName(\"resolveStep\", new SyncHook([\"hook\", \"request\"])),\n      noResolve: withName(\"noResolve\", new SyncHook([\"request\", \"error\"])),\n      resolve: withName(\"resolve\", new AsyncSeriesBailHook([\"request\", \"resolveContext\"])),\n      result: new AsyncSeriesHook([\"result\", \"resolveContext\"])\n    };\n\n    this._pluginCompat.tap(\"Resolver: before/after\", options => {\n      if (/^before-/.test(options.name)) {\n        options.name = options.name.substr(7);\n        options.stage = -10;\n      } else if (/^after-/.test(options.name)) {\n        options.name = options.name.substr(6);\n        options.stage = 10;\n      }\n    });\n\n    this._pluginCompat.tap(\"Resolver: step hooks\", options => {\n      const name = options.name;\n      const stepHook = !/^resolve(-s|S)tep$|^no(-r|R)esolve$/.test(name);\n\n      if (stepHook) {\n        options.async = true;\n        this.ensureHook(name);\n        const fn = options.fn;\n\n        options.fn = (request, resolverContext, callback) => {\n          const innerCallback = (err, result) => {\n            if (err) return callback(err);\n            if (result !== undefined) return callback(null, result);\n            callback();\n          };\n\n          for (const key in resolverContext) {\n            innerCallback[key] = resolverContext[key];\n          }\n\n          fn.call(this, request, innerCallback);\n        };\n      }\n    });\n  }\n\n  ensureHook(name) {\n    if (typeof name !== \"string\") return name;\n    name = toCamelCase(name);\n\n    if (/^before/.test(name)) {\n      return this.ensureHook(name[6].toLowerCase() + name.substr(7)).withOptions({\n        stage: -10\n      });\n    }\n\n    if (/^after/.test(name)) {\n      return this.ensureHook(name[5].toLowerCase() + name.substr(6)).withOptions({\n        stage: 10\n      });\n    }\n\n    const hook = this.hooks[name];\n\n    if (!hook) {\n      return this.hooks[name] = withName(name, new AsyncSeriesBailHook([\"request\", \"resolveContext\"]));\n    }\n\n    return hook;\n  }\n\n  getHook(name) {\n    if (typeof name !== \"string\") return name;\n    name = toCamelCase(name);\n\n    if (/^before/.test(name)) {\n      return this.getHook(name[6].toLowerCase() + name.substr(7)).withOptions({\n        stage: -10\n      });\n    }\n\n    if (/^after/.test(name)) {\n      return this.getHook(name[5].toLowerCase() + name.substr(6)).withOptions({\n        stage: 10\n      });\n    }\n\n    const hook = this.hooks[name];\n\n    if (!hook) {\n      throw new Error(\"Hook \".concat(name, \" doesn't exist\"));\n    }\n\n    return hook;\n  }\n\n  resolveSync(context, path, request) {\n    let err,\n        result,\n        sync = false;\n    this.resolve(context, path, request, {}, (e, r) => {\n      err = e;\n      result = r;\n      sync = true;\n    });\n    if (!sync) throw new Error(\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\");\n    if (err) throw err;\n    return result;\n  }\n\n  resolve(context, path, request, resolveContext, callback) {\n    // TODO remove in enhanced-resolve 5\n    // For backward compatiblity START\n    if (typeof callback !== \"function\") {\n      callback = deprecatedResolveContextInCallback(resolveContext); // resolveContext is a function containing additional properties\n      // It's now used for resolveContext and callback\n    } // END\n\n\n    const obj = {\n      context: context,\n      path: path,\n      request: request\n    };\n    const message = \"resolve '\" + request + \"' in '\" + path + \"'\"; // Try to resolve assuming there is no error\n    // We don't log stuff in this case\n\n    return this.doResolve(this.hooks.resolve, obj, message, {\n      missing: resolveContext.missing,\n      stack: resolveContext.stack\n    }, (err, result) => {\n      if (!err && result) {\n        return callback(null, result.path === false ? false : result.path + (result.query || \"\"), result);\n      }\n\n      const localMissing = new Set(); // TODO remove in enhanced-resolve 5\n\n      localMissing.push = item => deprecatedPushToMissing(localMissing, item);\n\n      const log = [];\n      return this.doResolve(this.hooks.resolve, obj, message, {\n        log: msg => {\n          if (resolveContext.log) {\n            resolveContext.log(msg);\n          }\n\n          log.push(msg);\n        },\n        missing: localMissing,\n        stack: resolveContext.stack\n      }, (err, result) => {\n        if (err) return callback(err);\n        const error = new Error(\"Can't \" + message);\n        error.details = log.join(\"\\n\");\n        error.missing = Array.from(localMissing);\n        this.hooks.noResolve.call(obj, error);\n        return callback(error);\n      });\n    });\n  }\n\n  doResolve(hook, request, message, resolveContext, callback) {\n    // TODO remove in enhanced-resolve 5\n    // For backward compatiblity START\n    if (typeof callback !== \"function\") {\n      callback = deprecatedResolveContextInCallback(resolveContext); // resolveContext is a function containing additional properties\n      // It's now used for resolveContext and callback\n    }\n\n    if (typeof hook === \"string\") {\n      const name = toCamelCase(hook);\n      hook = deprecatedHookAsString(this.hooks[name]);\n\n      if (!hook) {\n        throw new Error(\"Hook \\\"\".concat(name, \"\\\" doesn't exist\"));\n      }\n    } // END\n\n\n    if (typeof callback !== \"function\") throw new Error(\"callback is not a function \" + Array.from(arguments));\n    if (!resolveContext) throw new Error(\"resolveContext is not an object \" + Array.from(arguments));\n    const stackLine = hook.name + \": (\" + request.path + \") \" + (request.request || \"\") + (request.query || \"\") + (request.directory ? \" directory\" : \"\") + (request.module ? \" module\" : \"\");\n    let newStack;\n\n    if (resolveContext.stack) {\n      newStack = new Set(resolveContext.stack);\n\n      if (resolveContext.stack.has(stackLine)) {\n        // Prevent recursion\n        const recursionError = new Error(\"Recursion in resolving\\nStack:\\n  \" + Array.from(newStack).join(\"\\n  \"));\n        recursionError.recursion = true;\n        if (resolveContext.log) resolveContext.log(\"abort resolving because of recursion\");\n        return callback(recursionError);\n      }\n\n      newStack.add(stackLine);\n    } else {\n      newStack = new Set([stackLine]);\n    }\n\n    this.hooks.resolveStep.call(hook, request);\n\n    if (hook.isUsed()) {\n      const innerContext = createInnerContext({\n        log: resolveContext.log,\n        missing: resolveContext.missing,\n        stack: newStack\n      }, message);\n      return hook.callAsync(request, innerContext, (err, result) => {\n        if (err) return callback(err);\n        if (result) return callback(null, result);\n        callback();\n      });\n    } else {\n      callback();\n    }\n  }\n\n  parse(identifier) {\n    if (identifier === \"\") return null;\n    const part = {\n      request: \"\",\n      query: \"\",\n      module: false,\n      directory: false,\n      file: false\n    };\n    const idxQuery = identifier.indexOf(\"?\");\n\n    if (idxQuery === 0) {\n      part.query = identifier;\n    } else if (idxQuery > 0) {\n      part.request = identifier.slice(0, idxQuery);\n      part.query = identifier.slice(idxQuery);\n    } else {\n      part.request = identifier;\n    }\n\n    if (part.request) {\n      part.module = this.isModule(part.request);\n      part.directory = this.isDirectory(part.request);\n\n      if (part.directory) {\n        part.request = part.request.substr(0, part.request.length - 1);\n      }\n    }\n\n    return part;\n  }\n\n  isModule(path) {\n    return !REGEXP_NOT_MODULE.test(path);\n  }\n\n  isDirectory(path) {\n    return REGEXP_DIRECTORY.test(path);\n  }\n\n  join(path, request) {\n    let cacheEntry;\n    let pathCache = memoizedJoin.get(path);\n\n    if (typeof pathCache === \"undefined\") {\n      memoizedJoin.set(path, pathCache = new Map());\n    } else {\n      cacheEntry = pathCache.get(request);\n      if (typeof cacheEntry !== \"undefined\") return cacheEntry;\n    }\n\n    cacheEntry = memoryFsJoin(path, request);\n    pathCache.set(request, cacheEntry);\n    return cacheEntry;\n  }\n\n  normalize(path) {\n    return memoryFsNormalize(path);\n  }\n\n}\n\nmodule.exports = Resolver;","map":null,"metadata":{},"sourceType":"script"}