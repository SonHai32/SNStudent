{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n/* istanbul ignore next */\n\n\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown';\n/* istanbul ignore next */\n\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync';\nconst needEISDIRHandled = fs.lchown && !process.version.match(/v1[1-9]+\\./) && !process.version.match(/v10\\.[6-9]/);\n/* istanbul ignore next */\n\nconst handleEISDIR = needEISDIRHandled ? (path, uid, gid, cb) => er => {\n  // Node prior to v10 had a very questionable implementation of\n  // fs.lchown, which would always try to call fs.open on a directory\n  // Fall back to fs.chown in those cases.\n  if (!er || er.code !== 'EISDIR') cb(er);else fs.chown(path, uid, gid, cb);\n} : (_, __, ___, cb) => cb;\n/* istanbul ignore next */\n\nconst handleEISDirSync = needEISDIRHandled ? (path, uid, gid) => {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid);\n  } catch (er) {\n    if (er.code !== 'EISDIR') throw er;\n    fs.chownSync(path, uid, gid);\n  }\n} : fs[LCHOWNSYNC]; // fs.readdir could only accept an options object as of node v6\n\nconst nodeVersion = process.version;\n\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb);\n\nlet readdirSync = (path, options) => fs.readdirSync(path, options);\n/* istanbul ignore next */\n\n\nif (/^v4\\./.test(nodeVersion)) readdir = (path, options, cb) => fs.readdir(path, cb);\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string') return fs.lstat(path.resolve(p, child), (er, stats) => {\n    if (er) return cb(er);\n    stats.name = child;\n    chownrKid(p, stats, uid, gid, cb);\n  });\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er) return cb(er);\n      const cpath = path.resolve(p, child.name);\n      fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, cb));\n    });\n  } else {\n    const cpath = path.resolve(p, child.name);\n    fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, cb));\n  }\n};\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, {\n    withFileTypes: true\n  }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er && er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP') return cb(er);\n    if (er || !children.length) return fs[LCHOWN](p, uid, gid, handleEISDIR(p, uid, gid, cb));\n    let len = children.length;\n    let errState = null;\n\n    const then = er => {\n      if (errState) return;\n      if (er) return cb(errState = er);\n      if (--len === 0) return fs[LCHOWN](p, uid, gid, handleEISDIR(p, uid, gid, cb));\n    };\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then));\n  });\n};\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    const stats = fs.lstatSync(path.resolve(p, child));\n    stats.name = child;\n    child = stats;\n  }\n\n  if (child.isDirectory()) chownrSync(path.resolve(p, child.name), uid, gid);\n  handleEISDirSync(path.resolve(p, child.name), uid, gid);\n};\n\nconst chownrSync = (p, uid, gid) => {\n  let children;\n\n  try {\n    children = readdirSync(p, {\n      withFileTypes: true\n    });\n  } catch (er) {\n    if (er && er.code === 'ENOTDIR' && er.code !== 'ENOTSUP') return handleEISDirSync(p, uid, gid);\n    throw er;\n  }\n\n  if (children.length) children.forEach(child => chownrKidSync(p, child, uid, gid));\n  return handleEISDirSync(p, uid, gid);\n};\n\nmodule.exports = chownr;\nchownr.sync = chownrSync;","map":null,"metadata":{},"sourceType":"script"}