{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\n\nconst schema = require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\");\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n\n\nclass LimitChunkCountPlugin {\n  /**\n   * @param {LimitChunkCountPluginOptions=} options options object\n   */\n  constructor(options) {\n    if (!options) options = {};\n    validateOptions(schema, options, \"Limit Chunk Count Plugin\");\n    this.options = options;\n  }\n\n  apply(compiler) {\n    const options = this.options;\n    compiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n      compilation.hooks.optimizeChunksAdvanced.tap(\"LimitChunkCountPlugin\", chunks => {\n        const maxChunks = options.maxChunks;\n        if (!maxChunks) return;\n        if (maxChunks < 1) return;\n        if (chunks.length <= maxChunks) return;\n        const orderedChunks = chunks.slice().sort((a, b) => a.compareTo(b));\n        const sortedExtendedPairCombinations = orderedChunks.reduce((combinations, a, idx) => {\n          // create combination pairs\n          for (let i = 0; i < idx; i++) {\n            const b = orderedChunks[i];\n            combinations.push([b, a]);\n          }\n\n          return combinations;\n        }, []).map(pair => {\n          // extend combination pairs with size and integrated size\n          const a = pair[0].size(options);\n          const b = pair[1].size(options);\n          const ab = pair[0].integratedSize(pair[1], options);\n          return [a + b - ab, ab, pair[0], pair[1], a, b];\n        }).filter(extendedPair => {\n          // filter pairs that do not have an integratedSize\n          // meaning they can NOT be integrated!\n          return extendedPair[1] !== false;\n        }).sort((a, b) => {\n          // sadly javascript does an inplace sort here\n          // sort them by size\n          const diff1 = b[0] - a[0];\n          if (diff1 !== 0) return diff1;\n          const diff2 = a[1] - b[1];\n          if (diff2 !== 0) return diff2;\n          const diff3 = a[2].compareTo(b[2]);\n          if (diff3 !== 0) return diff3;\n          return a[3].compareTo(b[3]);\n        });\n        const pair = sortedExtendedPairCombinations[0];\n\n        if (pair && pair[2].integrate(pair[3], \"limit\")) {\n          chunks.splice(chunks.indexOf(pair[3]), 1);\n          return true;\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = LimitChunkCountPlugin;","map":null,"metadata":{},"sourceType":"script"}