{"ast":null,"code":"\"use strict\";\n/**\n * intersect creates Set containing the intersection of elements between all sets\n * @param {Set[]} sets an array of sets being checked for shared elements\n * @returns {Set<TODO>} returns a new Set containing the intersecting items\n */\n\nconst intersect = sets => {\n  if (sets.length === 0) return new Set();\n  if (sets.length === 1) return new Set(sets[0]);\n  let minSize = Infinity;\n  let minIndex = -1;\n\n  for (let i = 0; i < sets.length; i++) {\n    const size = sets[i].size;\n\n    if (size < minSize) {\n      minIndex = i;\n      minSize = size;\n    }\n  }\n\n  const current = new Set(sets[minIndex]);\n\n  for (let i = 0; i < sets.length; i++) {\n    if (i === minIndex) continue;\n    const set = sets[i];\n\n    for (const item of current) {\n      if (!set.has(item)) {\n        current.delete(item);\n      }\n    }\n  }\n\n  return current;\n};\n/**\n * Checks if a set is the subset of another set\n * @param {Set<TODO>} bigSet a Set which contains the original elements to compare against\n * @param {Set<TODO>} smallSet the set whos elements might be contained inside of bigSet\n * @returns {boolean} returns true if smallSet contains all elements inside of the bigSet\n */\n\n\nconst isSubset = (bigSet, smallSet) => {\n  if (bigSet.size < smallSet.size) return false;\n\n  for (const item of smallSet) {\n    if (!bigSet.has(item)) return false;\n  }\n\n  return true;\n};\n\nexports.intersect = intersect;\nexports.isSubset = isSubset;","map":null,"metadata":{},"sourceType":"script"}