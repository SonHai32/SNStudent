{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Generator = require(\"../Generator\");\n\nconst WebAssemblyParser = require(\"./WebAssemblyParser\");\n\nconst WebAssemblyGenerator = require(\"./WebAssemblyGenerator\");\n\nconst WebAssemblyJavascriptGenerator = require(\"./WebAssemblyJavascriptGenerator\");\n\nconst WebAssemblyImportDependency = require(\"../dependencies/WebAssemblyImportDependency\");\n\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n\nconst WebAssemblyInInitialChunkError = require(\"./WebAssemblyInInitialChunkError\");\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nclass WebAssemblyModulesPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * @param {Compiler} compiler compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"WebAssemblyModulesPlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      compilation.dependencyFactories.set(WebAssemblyImportDependency, normalModuleFactory);\n      compilation.dependencyFactories.set(WebAssemblyExportImportedDependency, normalModuleFactory);\n      normalModuleFactory.hooks.createParser.for(\"webassembly/experimental\").tap(\"WebAssemblyModulesPlugin\", () => {\n        return new WebAssemblyParser();\n      });\n      normalModuleFactory.hooks.createGenerator.for(\"webassembly/experimental\").tap(\"WebAssemblyModulesPlugin\", () => {\n        return Generator.byType({\n          javascript: new WebAssemblyJavascriptGenerator(),\n          webassembly: new WebAssemblyGenerator(this.options)\n        });\n      });\n      compilation.chunkTemplate.hooks.renderManifest.tap(\"WebAssemblyModulesPlugin\", (result, options) => {\n        const chunk = options.chunk;\n        const outputOptions = options.outputOptions;\n        const moduleTemplates = options.moduleTemplates;\n        const dependencyTemplates = options.dependencyTemplates;\n\n        for (const module of chunk.modulesIterable) {\n          if (module.type && module.type.startsWith(\"webassembly\")) {\n            const filenameTemplate = outputOptions.webassemblyModuleFilename;\n            result.push({\n              render: () => this.renderWebAssembly(module, moduleTemplates.webassembly, dependencyTemplates),\n              filenameTemplate,\n              pathOptions: {\n                module\n              },\n              identifier: \"webassemblyModule\".concat(module.id),\n              hash: module.hash\n            });\n          }\n        }\n\n        return result;\n      });\n      compilation.hooks.afterChunks.tap(\"WebAssemblyModulesPlugin\", () => {\n        const initialWasmModules = new Set();\n\n        for (const chunk of compilation.chunks) {\n          if (chunk.canBeInitial()) {\n            for (const module of chunk.modulesIterable) {\n              if (module.type.startsWith(\"webassembly\")) {\n                initialWasmModules.add(module);\n              }\n            }\n          }\n        }\n\n        for (const module of initialWasmModules) {\n          compilation.errors.push(new WebAssemblyInInitialChunkError(module, compilation.requestShortener));\n        }\n      });\n    });\n  }\n\n  renderWebAssembly(module, moduleTemplate, dependencyTemplates) {\n    return moduleTemplate.render(module, dependencyTemplates, {});\n  }\n\n}\n\nmodule.exports = WebAssemblyModulesPlugin;","map":null,"metadata":{},"sourceType":"script"}