{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"./util/identifier\");\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} RecordsChunks\n * @property {Record<string, number>=} byName\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} RecordsModules\n * @property {Record<string, number>=} byIdentifier\n * @property {Record<string, number>=} bySource\n * @property {Record<number, number>=} usedIds\n */\n\n/**\n * @typedef {Object} Records\n * @property {RecordsChunks=} chunks\n * @property {RecordsModules=} modules\n */\n\n\nclass RecordIdsPlugin {\n  /**\n   * @param {Object} options Options object\n   * @param {boolean=} options.portableIds true, when ids need to be portable\n   */\n  constructor(options) {\n    this.options = options || {};\n  }\n  /**\n   * @param {Compiler} compiler the Compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const portableIds = this.options.portableIds;\n    compiler.hooks.compilation.tap(\"RecordIdsPlugin\", compilation => {\n      compilation.hooks.recordModules.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Module[]} modules the modules array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (modules, records) => {\n        if (!records.modules) records.modules = {};\n        if (!records.modules.byIdentifier) records.modules.byIdentifier = {};\n        if (!records.modules.usedIds) records.modules.usedIds = {};\n\n        for (const module of modules) {\n          if (typeof module.id !== \"number\") continue;\n          const identifier = portableIds ? identifierUtils.makePathsRelative(compiler.context, module.identifier(), compilation.cache) : module.identifier();\n          records.modules.byIdentifier[identifier] = module.id;\n          records.modules.usedIds[module.id] = module.id;\n        }\n      });\n      compilation.hooks.reviveModules.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Module[]} modules the modules array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (modules, records) => {\n        if (!records.modules) return;\n\n        if (records.modules.byIdentifier) {\n          /** @type {Set<number>} */\n          const usedIds = new Set();\n\n          for (const module of modules) {\n            if (module.id !== null) continue;\n            const identifier = portableIds ? identifierUtils.makePathsRelative(compiler.context, module.identifier(), compilation.cache) : module.identifier();\n            const id = records.modules.byIdentifier[identifier];\n            if (id === undefined) continue;\n            if (usedIds.has(id)) continue;\n            usedIds.add(id);\n            module.id = id;\n          }\n        }\n\n        if (Array.isArray(records.modules.usedIds)) {\n          compilation.usedModuleIds = new Set(records.modules.usedIds);\n        }\n      });\n      /**\n       * @param {Module} module the module\n       * @returns {string} the (portable) identifier\n       */\n\n      const getModuleIdentifier = module => {\n        if (portableIds) {\n          return identifierUtils.makePathsRelative(compiler.context, module.identifier(), compilation.cache);\n        }\n\n        return module.identifier();\n      };\n      /**\n       * @param {Chunk} chunk the chunk\n       * @returns {string[]} sources of the chunk\n       */\n\n\n      const getChunkSources = chunk => {\n        /** @type {string[]} */\n        const sources = [];\n\n        for (const chunkGroup of chunk.groupsIterable) {\n          const index = chunkGroup.chunks.indexOf(chunk);\n\n          for (const origin of chunkGroup.origins) {\n            if (origin.module) {\n              if (origin.request) {\n                sources.push(\"\".concat(index, \" \").concat(getModuleIdentifier(origin.module), \" \").concat(origin.request));\n              } else if (typeof origin.loc === \"string\") {\n                sources.push(\"\".concat(index, \" \").concat(getModuleIdentifier(origin.module), \" \").concat(origin.loc));\n              } else if (origin.loc && typeof origin.loc === \"object\" && origin.loc.start) {\n                sources.push(\"\".concat(index, \" \").concat(getModuleIdentifier(origin.module), \" \").concat(JSON.stringify(origin.loc.start)));\n              }\n            }\n          }\n        }\n\n        return sources;\n      };\n\n      compilation.hooks.recordChunks.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Chunk[]} chunks the chunks array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (chunks, records) => {\n        if (!records.chunks) records.chunks = {};\n        if (!records.chunks.byName) records.chunks.byName = {};\n        if (!records.chunks.bySource) records.chunks.bySource = {};\n        /** @type {Set<number>} */\n\n        const usedIds = new Set();\n\n        for (const chunk of chunks) {\n          if (typeof chunk.id !== \"number\") continue;\n          const name = chunk.name;\n          if (name) records.chunks.byName[name] = chunk.id;\n          const sources = getChunkSources(chunk);\n\n          for (const source of sources) {\n            records.chunks.bySource[source] = chunk.id;\n          }\n\n          usedIds.add(chunk.id);\n        }\n\n        records.chunks.usedIds = Array.from(usedIds).sort();\n      });\n      compilation.hooks.reviveChunks.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Chunk[]} chunks the chunks array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (chunks, records) => {\n        if (!records.chunks) return;\n        /** @type {Set<number>} */\n\n        const usedIds = new Set();\n\n        if (records.chunks.byName) {\n          for (const chunk of chunks) {\n            if (chunk.id !== null) continue;\n            if (!chunk.name) continue;\n            const id = records.chunks.byName[chunk.name];\n            if (id === undefined) continue;\n            if (usedIds.has(id)) continue;\n            usedIds.add(id);\n            chunk.id = id;\n          }\n        }\n\n        if (records.chunks.bySource) {\n          for (const chunk of chunks) {\n            const sources = getChunkSources(chunk);\n\n            for (const source of sources) {\n              const id = records.chunks.bySource[source];\n              if (id === undefined) continue;\n              if (usedIds.has(id)) continue;\n              usedIds.add(id);\n              chunk.id = id;\n              break;\n            }\n          }\n        }\n\n        if (Array.isArray(records.chunks.usedIds)) {\n          compilation.usedChunkIds = new Set(records.chunks.usedIds);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = RecordIdsPlugin;","map":null,"metadata":{},"sourceType":"script"}