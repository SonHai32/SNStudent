{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst asyncLib = require(\"neo-async\");\n\nconst _require = require(\"tapable\"),\n      Tapable = _require.Tapable,\n      AsyncSeriesWaterfallHook = _require.AsyncSeriesWaterfallHook,\n      SyncWaterfallHook = _require.SyncWaterfallHook,\n      SyncBailHook = _require.SyncBailHook,\n      SyncHook = _require.SyncHook,\n      HookMap = _require.HookMap;\n\nconst NormalModule = require(\"./NormalModule\");\n\nconst RawModule = require(\"./RawModule\");\n\nconst RuleSet = require(\"./RuleSet\");\n\nconst _require2 = require(\"./util/cleverMerge\"),\n      cachedCleverMerge = _require2.cachedCleverMerge;\n\nconst EMPTY_RESOLVE_OPTIONS = {};\nconst MATCH_RESOURCE_REGEX = /^([^!]+)!=!/;\n\nconst loaderToIdent = data => {\n  if (!data.options) {\n    return data.loader;\n  }\n\n  if (typeof data.options === \"string\") {\n    return data.loader + \"?\" + data.options;\n  }\n\n  if (typeof data.options !== \"object\") {\n    throw new Error(\"loader options must be string or object\");\n  }\n\n  if (data.ident) {\n    return data.loader + \"??\" + data.ident;\n  }\n\n  return data.loader + \"?\" + JSON.stringify(data.options);\n};\n\nconst identToLoaderRequest = resultString => {\n  const idx = resultString.indexOf(\"?\");\n\n  if (idx >= 0) {\n    const loader = resultString.substr(0, idx);\n    const options = resultString.substr(idx + 1);\n    return {\n      loader,\n      options\n    };\n  } else {\n    return {\n      loader: resultString,\n      options: undefined\n    };\n  }\n};\n\nconst dependencyCache = new WeakMap();\n\nclass NormalModuleFactory extends Tapable {\n  constructor(context, resolverFactory, options) {\n    super();\n    this.hooks = {\n      resolver: new SyncWaterfallHook([\"resolver\"]),\n      factory: new SyncWaterfallHook([\"factory\"]),\n      beforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n      afterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n      createModule: new SyncBailHook([\"data\"]),\n      module: new SyncWaterfallHook([\"module\", \"data\"]),\n      createParser: new HookMap(() => new SyncBailHook([\"parserOptions\"])),\n      parser: new HookMap(() => new SyncHook([\"parser\", \"parserOptions\"])),\n      createGenerator: new HookMap(() => new SyncBailHook([\"generatorOptions\"])),\n      generator: new HookMap(() => new SyncHook([\"generator\", \"generatorOptions\"]))\n    };\n\n    this._pluginCompat.tap(\"NormalModuleFactory\", options => {\n      switch (options.name) {\n        case \"before-resolve\":\n        case \"after-resolve\":\n          options.async = true;\n          break;\n\n        case \"parser\":\n          this.hooks.parser.for(\"javascript/auto\").tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n          return true;\n      }\n\n      let match;\n      match = /^parser (.+)$/.exec(options.name);\n\n      if (match) {\n        this.hooks.parser.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(this));\n        return true;\n      }\n\n      match = /^create-parser (.+)$/.exec(options.name);\n\n      if (match) {\n        this.hooks.createParser.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(this));\n        return true;\n      }\n    });\n\n    this.resolverFactory = resolverFactory;\n    this.ruleSet = new RuleSet(options.defaultRules.concat(options.rules));\n    this.cachePredicate = typeof options.unsafeCache === \"function\" ? options.unsafeCache : Boolean.bind(null, options.unsafeCache);\n    this.context = context || \"\";\n    this.parserCache = Object.create(null);\n    this.generatorCache = Object.create(null);\n    this.hooks.factory.tap(\"NormalModuleFactory\", () => (result, callback) => {\n      let resolver = this.hooks.resolver.call(null); // Ignored\n\n      if (!resolver) return callback();\n      resolver(result, (err, data) => {\n        if (err) return callback(err); // Ignored\n\n        if (!data) return callback(); // direct module\n\n        if (typeof data.source === \"function\") return callback(null, data);\n        this.hooks.afterResolve.callAsync(data, (err, result) => {\n          if (err) return callback(err); // Ignored\n\n          if (!result) return callback();\n          let createdModule = this.hooks.createModule.call(result);\n\n          if (!createdModule) {\n            if (!result.request) {\n              return callback(new Error(\"Empty dependency (no request)\"));\n            }\n\n            createdModule = new NormalModule(result);\n          }\n\n          createdModule = this.hooks.module.call(createdModule, result);\n          return callback(null, createdModule);\n        });\n      });\n    });\n    this.hooks.resolver.tap(\"NormalModuleFactory\", () => (data, callback) => {\n      const contextInfo = data.contextInfo;\n      const context = data.context;\n      const request = data.request;\n      const loaderResolver = this.getResolver(\"loader\");\n      const normalResolver = this.getResolver(\"normal\", data.resolveOptions);\n      let matchResource = undefined;\n      let requestWithoutMatchResource = request;\n      const matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);\n\n      if (matchResourceMatch) {\n        matchResource = matchResourceMatch[1];\n\n        if (/^\\.\\.?\\//.test(matchResource)) {\n          matchResource = path.join(context, matchResource);\n        }\n\n        requestWithoutMatchResource = request.substr(matchResourceMatch[0].length);\n      }\n\n      const noPreAutoLoaders = requestWithoutMatchResource.startsWith(\"-!\");\n      const noAutoLoaders = noPreAutoLoaders || requestWithoutMatchResource.startsWith(\"!\");\n      const noPrePostAutoLoaders = requestWithoutMatchResource.startsWith(\"!!\");\n      let elements = requestWithoutMatchResource.replace(/^-?!+/, \"\").replace(/!!+/g, \"!\").split(\"!\");\n      let resource = elements.pop();\n      elements = elements.map(identToLoaderRequest);\n      asyncLib.parallel([callback => this.resolveRequestArray(contextInfo, context, elements, loaderResolver, callback), callback => {\n        if (resource === \"\" || resource[0] === \"?\") {\n          return callback(null, {\n            resource\n          });\n        }\n\n        normalResolver.resolve(contextInfo, context, resource, {}, (err, resource, resourceResolveData) => {\n          if (err) return callback(err);\n          callback(null, {\n            resourceResolveData,\n            resource\n          });\n        });\n      }], (err, results) => {\n        if (err) return callback(err);\n        let loaders = results[0];\n        const resourceResolveData = results[1].resourceResolveData;\n        resource = results[1].resource; // translate option idents\n\n        try {\n          for (const item of loaders) {\n            if (typeof item.options === \"string\" && item.options[0] === \"?\") {\n              const ident = item.options.substr(1);\n              item.options = this.ruleSet.findOptionsByIdent(ident);\n              item.ident = ident;\n            }\n          }\n        } catch (e) {\n          return callback(e);\n        }\n\n        if (resource === false) {\n          // ignored\n          return callback(null, new RawModule(\"/* (ignored) */\", \"ignored \".concat(context, \" \").concat(request), \"\".concat(request, \" (ignored)\")));\n        }\n\n        const userRequest = (matchResource !== undefined ? \"\".concat(matchResource, \"!=!\") : \"\") + loaders.map(loaderToIdent).concat([resource]).join(\"!\");\n        let resourcePath = matchResource !== undefined ? matchResource : resource;\n        let resourceQuery = \"\";\n        const queryIndex = resourcePath.indexOf(\"?\");\n\n        if (queryIndex >= 0) {\n          resourceQuery = resourcePath.substr(queryIndex);\n          resourcePath = resourcePath.substr(0, queryIndex);\n        }\n\n        const result = this.ruleSet.exec({\n          resource: resourcePath,\n          realResource: matchResource !== undefined ? resource.replace(/\\?.*/, \"\") : resourcePath,\n          resourceQuery,\n          issuer: contextInfo.issuer,\n          compiler: contextInfo.compiler\n        });\n        const settings = {};\n        const useLoadersPost = [];\n        const useLoaders = [];\n        const useLoadersPre = [];\n\n        for (const r of result) {\n          if (r.type === \"use\") {\n            if (r.enforce === \"post\" && !noPrePostAutoLoaders) {\n              useLoadersPost.push(r.value);\n            } else if (r.enforce === \"pre\" && !noPreAutoLoaders && !noPrePostAutoLoaders) {\n              useLoadersPre.push(r.value);\n            } else if (!r.enforce && !noAutoLoaders && !noPrePostAutoLoaders) {\n              useLoaders.push(r.value);\n            }\n          } else if (typeof r.value === \"object\" && r.value !== null && typeof settings[r.type] === \"object\" && settings[r.type] !== null) {\n            settings[r.type] = cachedCleverMerge(settings[r.type], r.value);\n          } else {\n            settings[r.type] = r.value;\n          }\n        }\n\n        asyncLib.parallel([this.resolveRequestArray.bind(this, contextInfo, this.context, useLoadersPost, loaderResolver), this.resolveRequestArray.bind(this, contextInfo, this.context, useLoaders, loaderResolver), this.resolveRequestArray.bind(this, contextInfo, this.context, useLoadersPre, loaderResolver)], (err, results) => {\n          if (err) return callback(err);\n\n          if (matchResource === undefined) {\n            loaders = results[0].concat(loaders, results[1], results[2]);\n          } else {\n            loaders = results[0].concat(results[1], loaders, results[2]);\n          }\n\n          process.nextTick(() => {\n            const type = settings.type;\n            const resolveOptions = settings.resolve;\n            callback(null, {\n              context: context,\n              request: loaders.map(loaderToIdent).concat([resource]).join(\"!\"),\n              dependencies: data.dependencies,\n              userRequest,\n              rawRequest: request,\n              loaders,\n              resource,\n              matchResource,\n              resourceResolveData,\n              settings,\n              type,\n              parser: this.getParser(type, settings.parser),\n              generator: this.getGenerator(type, settings.generator),\n              resolveOptions\n            });\n          });\n        });\n      });\n    });\n  }\n\n  create(data, callback) {\n    const dependencies = data.dependencies;\n    const cacheEntry = dependencyCache.get(dependencies[0]);\n    if (cacheEntry) return callback(null, cacheEntry);\n    const context = data.context || this.context;\n    const resolveOptions = data.resolveOptions || EMPTY_RESOLVE_OPTIONS;\n    const request = dependencies[0].request;\n    const contextInfo = data.contextInfo || {};\n    this.hooks.beforeResolve.callAsync({\n      contextInfo,\n      resolveOptions,\n      context,\n      request,\n      dependencies\n    }, (err, result) => {\n      if (err) return callback(err); // Ignored\n\n      if (!result) return callback();\n      const factory = this.hooks.factory.call(null); // Ignored\n\n      if (!factory) return callback();\n      factory(result, (err, module) => {\n        if (err) return callback(err);\n\n        if (module && this.cachePredicate(module)) {\n          for (const d of dependencies) {\n            dependencyCache.set(d, module);\n          }\n        }\n\n        callback(null, module);\n      });\n    });\n  }\n\n  resolveRequestArray(contextInfo, context, array, resolver, callback) {\n    if (array.length === 0) return callback(null, []);\n    asyncLib.map(array, (item, callback) => {\n      resolver.resolve(contextInfo, context, item.loader, {}, (err, result) => {\n        if (err && /^[^/]*$/.test(item.loader) && !/-loader$/.test(item.loader)) {\n          return resolver.resolve(contextInfo, context, item.loader + \"-loader\", {}, err2 => {\n            if (!err2) {\n              err.message = err.message + \"\\n\" + \"BREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\\n\" + \"                 You need to specify '\".concat(item.loader, \"-loader' instead of '\").concat(item.loader, \"',\\n\") + \"                 see https://webpack.js.org/migrate/3/#automatic-loader-module-name-extension-removed\";\n            }\n\n            callback(err);\n          });\n        }\n\n        if (err) return callback(err);\n        const optionsOnly = item.options ? {\n          options: item.options\n        } : undefined;\n        return callback(null, Object.assign({}, item, identToLoaderRequest(result), optionsOnly));\n      });\n    }, callback);\n  }\n\n  getParser(type, parserOptions) {\n    let ident = type;\n\n    if (parserOptions) {\n      if (parserOptions.ident) {\n        ident = \"\".concat(type, \"|\").concat(parserOptions.ident);\n      } else {\n        ident = JSON.stringify([type, parserOptions]);\n      }\n    }\n\n    if (ident in this.parserCache) {\n      return this.parserCache[ident];\n    }\n\n    return this.parserCache[ident] = this.createParser(type, parserOptions);\n  }\n\n  createParser(type, parserOptions = {}) {\n    const parser = this.hooks.createParser.for(type).call(parserOptions);\n\n    if (!parser) {\n      throw new Error(\"No parser registered for \".concat(type));\n    }\n\n    this.hooks.parser.for(type).call(parser, parserOptions);\n    return parser;\n  }\n\n  getGenerator(type, generatorOptions) {\n    let ident = type;\n\n    if (generatorOptions) {\n      if (generatorOptions.ident) {\n        ident = \"\".concat(type, \"|\").concat(generatorOptions.ident);\n      } else {\n        ident = JSON.stringify([type, generatorOptions]);\n      }\n    }\n\n    if (ident in this.generatorCache) {\n      return this.generatorCache[ident];\n    }\n\n    return this.generatorCache[ident] = this.createGenerator(type, generatorOptions);\n  }\n\n  createGenerator(type, generatorOptions = {}) {\n    const generator = this.hooks.createGenerator.for(type).call(generatorOptions);\n\n    if (!generator) {\n      throw new Error(\"No generator registered for \".concat(type));\n    }\n\n    this.hooks.generator.for(type).call(generator, generatorOptions);\n    return generator;\n  }\n\n  getResolver(type, resolveOptions) {\n    return this.resolverFactory.get(type, resolveOptions || EMPTY_RESOLVE_OPTIONS);\n  }\n\n}\n\nmodule.exports = NormalModuleFactory;","map":null,"metadata":{},"sourceType":"script"}