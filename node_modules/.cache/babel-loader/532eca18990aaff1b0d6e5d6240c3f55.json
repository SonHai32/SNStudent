{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nconst globToRegExp = require(\"./globToRegExp\").globToRegExp;\n\nfunction parseType(type) {\n  const items = type.split(\"+\");\n  const t = items.shift();\n  return {\n    type: t === \"*\" ? null : t,\n    features: items\n  };\n}\n\nfunction isTypeMatched(baseType, testedType) {\n  if (typeof baseType === \"string\") baseType = parseType(baseType);\n  if (typeof testedType === \"string\") testedType = parseType(testedType);\n  if (testedType.type && testedType.type !== baseType.type) return false;\n  return testedType.features.every(requiredFeature => {\n    return baseType.features.indexOf(requiredFeature) >= 0;\n  });\n}\n\nfunction isResourceTypeMatched(baseType, testedType) {\n  baseType = baseType.split(\"/\");\n  testedType = testedType.split(\"/\");\n  if (baseType.length !== testedType.length) return false;\n\n  for (let i = 0; i < baseType.length; i++) {\n    if (!isTypeMatched(baseType[i], testedType[i])) return false;\n  }\n\n  return true;\n}\n\nfunction isResourceTypeSupported(context, type) {\n  return context.supportedResourceTypes && context.supportedResourceTypes.some(supportedType => {\n    return isResourceTypeMatched(supportedType, type);\n  });\n}\n\nfunction isEnvironment(context, env) {\n  return context.environments && context.environments.every(environment => {\n    return isTypeMatched(environment, env);\n  });\n}\n\nconst globCache = {};\n\nfunction getGlobRegExp(glob) {\n  const regExp = globCache[glob] || (globCache[glob] = globToRegExp(glob));\n  return regExp;\n}\n\nfunction matchGlob(glob, relativePath) {\n  const regExp = getGlobRegExp(glob);\n  return regExp.exec(relativePath);\n}\n\nfunction isGlobMatched(glob, relativePath) {\n  return !!matchGlob(glob, relativePath);\n}\n\nfunction isConditionMatched(context, condition) {\n  const items = condition.split(\"|\");\n  return items.some(function testFn(item) {\n    item = item.trim();\n    const inverted = /^!/.test(item);\n    if (inverted) return !testFn(item.substr(1));\n\n    if (/^[a-z]+:/.test(item)) {\n      // match named condition\n      const match = /^([a-z]+):\\s*/.exec(item);\n      const value = item.substr(match[0].length);\n      const name = match[1];\n\n      switch (name) {\n        case \"referrer\":\n          return isGlobMatched(value, context.referrer);\n\n        default:\n          return false;\n      }\n    } else if (item.indexOf(\"/\") >= 0) {\n      // match supported type\n      return isResourceTypeSupported(context, item);\n    } else {\n      // match environment\n      return isEnvironment(context, item);\n    }\n  });\n}\n\nfunction isKeyMatched(context, key) {\n  while (true) {\n    //eslint-disable-line\n    const match = /^\\[([^\\]]+)\\]\\s*/.exec(key);\n    if (!match) return key;\n    key = key.substr(match[0].length);\n    const condition = match[1];\n\n    if (!isConditionMatched(context, condition)) {\n      return false;\n    }\n  }\n}\n\nfunction getField(context, configuration, field) {\n  let value;\n  Object.keys(configuration).forEach(key => {\n    const pureKey = isKeyMatched(context, key);\n\n    if (pureKey === field) {\n      value = configuration[key];\n    }\n  });\n  return value;\n}\n\nfunction getMain(context, configuration) {\n  return getField(context, configuration, \"main\");\n}\n\nfunction getExtensions(context, configuration) {\n  return getField(context, configuration, \"extensions\");\n}\n\nfunction matchModule(context, configuration, request) {\n  const modulesField = getField(context, configuration, \"modules\");\n  if (!modulesField) return request;\n  let newRequest = request;\n  const keys = Object.keys(modulesField);\n  let iteration = 0;\n  let match;\n  let index;\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const pureKey = isKeyMatched(context, key);\n    match = matchGlob(pureKey, newRequest);\n\n    if (match) {\n      const value = modulesField[key];\n\n      if (typeof value !== \"string\") {\n        return value;\n      } else if (/^\\(.+\\)$/.test(pureKey)) {\n        newRequest = newRequest.replace(getGlobRegExp(pureKey), value);\n      } else {\n        index = 1;\n        newRequest = value.replace(/(\\/?\\*)?\\*/g, replaceMatcher);\n      }\n\n      i = -1;\n\n      if (iteration++ > keys.length) {\n        throw new Error(\"Request '\" + request + \"' matches recursively\");\n      }\n    }\n  }\n\n  return newRequest;\n\n  function replaceMatcher(find) {\n    switch (find) {\n      case \"/**\":\n        {\n          const m = match[index++];\n          return m ? \"/\" + m : \"\";\n        }\n\n      case \"**\":\n      case \"*\":\n        return match[index++];\n    }\n  }\n}\n\nfunction matchType(context, configuration, relativePath) {\n  const typesField = getField(context, configuration, \"types\");\n  if (!typesField) return undefined;\n  let type;\n  Object.keys(typesField).forEach(key => {\n    const pureKey = isKeyMatched(context, key);\n\n    if (isGlobMatched(pureKey, relativePath)) {\n      const value = typesField[key];\n      if (!type && /\\/\\*$/.test(value)) throw new Error(\"value ('\" + value + \"') of key '\" + key + \"' contains '*', but there is no previous value defined\");\n      type = value.replace(/\\/\\*$/, \"/\" + type);\n    }\n  });\n  return type;\n}\n\nexports.parseType = parseType;\nexports.isTypeMatched = isTypeMatched;\nexports.isResourceTypeSupported = isResourceTypeSupported;\nexports.isEnvironment = isEnvironment;\nexports.isGlobMatched = isGlobMatched;\nexports.isConditionMatched = isConditionMatched;\nexports.isKeyMatched = isKeyMatched;\nexports.getField = getField;\nexports.getMain = getMain;\nexports.getExtensions = getExtensions;\nexports.matchModule = matchModule;\nexports.matchType = matchType;","map":null,"metadata":{},"sourceType":"script"}