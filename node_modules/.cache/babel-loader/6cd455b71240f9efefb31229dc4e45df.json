{"ast":null,"code":"\"use strict\";\n\nconst path = require(\"path\");\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\n/**\n *\n * @param {string} maybeAbsolutePath path to check\n * @returns {boolean} returns true if path is \"Absolute Path\"-like\n */\n\n\nconst looksLikeAbsolutePath = maybeAbsolutePath => {\n  if (/^\\/.*\\/$/.test(maybeAbsolutePath)) {\n    // this 'path' is actually a regexp generated by dynamic requires.\n    // Don't treat it as an absolute path.\n    return false;\n  }\n\n  return /^(?:[a-z]:\\\\|\\/)/i.test(maybeAbsolutePath);\n};\n/**\n *\n * @param {string} p path to normalize\n * @returns {string} normalized version of path\n */\n\n\nconst normalizePathSeparator = p => p.replace(/\\\\/g, \"/\");\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\n\n\nconst _makePathsRelative = (context, identifier) => {\n  return identifier.split(/([|! ])/).map(str => looksLikeAbsolutePath(str) ? normalizePathSeparator(path.relative(context, str)) : str).join(\"\");\n};\n/**\n *\n * @param {string} context context used to create relative path\n * @param {string} identifier identifier used to create relative path\n * @param {MakeRelativePathsCache=} cache the cache object being set\n * @returns {string} the returned relative path\n */\n\n\nexports.makePathsRelative = (context, identifier, cache) => {\n  if (!cache) return _makePathsRelative(context, identifier);\n  const relativePaths = cache.relativePaths || (cache.relativePaths = new Map());\n  let cachedResult;\n  let contextCache = relativePaths.get(context);\n\n  if (contextCache === undefined) {\n    relativePaths.set(context, contextCache = new Map());\n  } else {\n    cachedResult = contextCache.get(identifier);\n  }\n\n  if (cachedResult !== undefined) {\n    return cachedResult;\n  } else {\n    const relativePath = _makePathsRelative(context, identifier);\n\n    contextCache.set(identifier, relativePath);\n    return relativePath;\n  }\n};\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\n\n\nexports.contextify = (context, request) => {\n  return request.split(\"!\").map(r => {\n    const splitPath = r.split(\"?\", 2);\n\n    if (/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n      splitPath[0] = path.win32.relative(context, splitPath[0]);\n\n      if (!/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n        splitPath[0] = splitPath[0].replace(/\\\\/g, \"/\");\n      }\n    }\n\n    if (/^\\//.test(splitPath[0])) {\n      splitPath[0] = path.posix.relative(context, splitPath[0]);\n    }\n\n    if (!/^(\\.\\.\\/|\\/|[a-zA-Z]:\\\\)/.test(splitPath[0])) {\n      splitPath[0] = \"./\" + splitPath[0];\n    }\n\n    return splitPath.join(\"?\");\n  }).join(\"!\");\n};","map":null,"metadata":{},"sourceType":"script"}