{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/home/hari/Desktop/web-dev/React/cstudy/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst Generator = require(\"../Generator\");\n\nconst Template = require(\"../Template\");\n\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n\nconst _require = require(\"webpack-sources\"),\n      RawSource = _require.RawSource;\n\nconst _require2 = require(\"@webassemblyjs/wasm-edit\"),\n      editWithAST = _require2.editWithAST,\n      addWithAST = _require2.addWithAST;\n\nconst _require3 = require(\"@webassemblyjs/wasm-parser\"),\n      decode = _require3.decode;\n\nconst t = require(\"@webassemblyjs/ast\");\n\nconst _require4 = require(\"@webassemblyjs/helper-module-context\"),\n      moduleContextFromModuleAST = _require4.moduleContextFromModuleAST;\n\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"./WebAssemblyUtils\").UsedWasmDependency} UsedWasmDependency */\n\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../Dependency\").DependencyTemplate} DependencyTemplate */\n\n/**\n * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform\n */\n\n/**\n * @template T\n * @param {Function[]} fns transforms\n * @returns {Function} composed transform\n */\n\n\nconst compose = (...fns) => {\n  return fns.reduce((prevFn, nextFn) => {\n    return value => nextFn(prevFn(value));\n  }, value => value);\n}; // TODO replace with @callback\n\n/**\n * Removes the start instruction\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\n\n\nconst removeStartFunc = state => bin => {\n  return editWithAST(state.ast, bin, {\n    Start(path) {\n      path.remove();\n    }\n\n  });\n};\n/**\n * Get imported globals\n *\n * @param {Object} ast Module's AST\n * @returns {Array<t.ModuleImport>} - nodes\n */\n\n\nconst getImportedGlobals = ast => {\n  const importedGlobals = [];\n  t.traverse(ast, {\n    ModuleImport({\n      node\n    }) {\n      if (t.isGlobalType(node.descr) === true) {\n        importedGlobals.push(node);\n      }\n    }\n\n  });\n  return importedGlobals;\n};\n\nconst getCountImportedFunc = ast => {\n  let count = 0;\n  t.traverse(ast, {\n    ModuleImport({\n      node\n    }) {\n      if (t.isFuncImportDescr(node.descr) === true) {\n        count++;\n      }\n    }\n\n  });\n  return count;\n};\n/**\n * Get next type index\n *\n * @param {Object} ast Module's AST\n * @returns {t.Index} - index\n */\n\n\nconst getNextTypeIndex = ast => {\n  const typeSectionMetadata = t.getSectionMetadata(ast, \"type\");\n\n  if (typeSectionMetadata === undefined) {\n    return t.indexLiteral(0);\n  }\n\n  return t.indexLiteral(typeSectionMetadata.vectorOfSize.value);\n};\n/**\n * Get next func index\n *\n * The Func section metadata provide informations for implemented funcs\n * in order to have the correct index we shift the index by number of external\n * functions.\n *\n * @param {Object} ast Module's AST\n * @param {Number} countImportedFunc number of imported funcs\n * @returns {t.Index} - index\n */\n\n\nconst getNextFuncIndex = (ast, countImportedFunc) => {\n  const funcSectionMetadata = t.getSectionMetadata(ast, \"func\");\n\n  if (funcSectionMetadata === undefined) {\n    return t.indexLiteral(0 + countImportedFunc);\n  }\n\n  const vectorOfSize = funcSectionMetadata.vectorOfSize.value;\n  return t.indexLiteral(vectorOfSize + countImportedFunc);\n};\n/**\n * Create a init instruction for a global\n * @param {t.GlobalType} globalType the global type\n * @returns {t.Instruction} init expression\n */\n\n\nconst createDefaultInitForGlobal = globalType => {\n  if (globalType.valtype[0] === \"i\") {\n    // create NumberLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.numberLiteralFromRaw(66)]);\n  } else if (globalType.valtype[0] === \"f\") {\n    // create FloatLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.floatLiteral(66, false, false, \"66\")]);\n  } else {\n    throw new Error(\"unknown type: \" + globalType.valtype);\n  }\n};\n/**\n * Rewrite the import globals:\n * - removes the ModuleImport instruction\n * - injects at the same offset a mutable global of the same time\n *\n * Since the imported globals are before the other global declarations, our\n * indices will be preserved.\n *\n * Note that globals will become mutable.\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\n\n\nconst rewriteImportedGlobals = state => bin => {\n  const additionalInitCode = state.additionalInitCode;\n  const newGlobals = [];\n  bin = editWithAST(state.ast, bin, {\n    ModuleImport(path) {\n      if (t.isGlobalType(path.node.descr) === true) {\n        const globalType = path.node.descr;\n        globalType.mutability = \"var\";\n        const init = [createDefaultInitForGlobal(globalType), t.instruction(\"end\")];\n        newGlobals.push(t.global(globalType, init));\n        path.remove();\n      }\n    },\n\n    // in order to preserve non-imported global's order we need to re-inject\n    // those as well\n    Global(path) {\n      const node = path.node;\n\n      const _node$init = _slicedToArray(node.init, 1),\n            init = _node$init[0];\n\n      if (init.id === \"get_global\") {\n        node.globalType.mutability = \"var\";\n        const initialGlobalidx = init.args[0];\n        node.init = [createDefaultInitForGlobal(node.globalType), t.instruction(\"end\")];\n        additionalInitCode.push(\n        /**\n         * get_global in global initilizer only work for imported globals.\n         * They have the same indices than the init params, so use the\n         * same index.\n         */\n        t.instruction(\"get_local\", [initialGlobalidx]), t.instruction(\"set_global\", [t.indexLiteral(newGlobals.length)]));\n      }\n\n      newGlobals.push(node);\n      path.remove();\n    }\n\n  }); // Add global declaration instructions\n\n  return addWithAST(state.ast, bin, newGlobals);\n};\n/**\n * Rewrite the export names\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Module} state.module Module\n * @param {Set<string>} state.externalExports Module\n * @returns {ArrayBufferTransform} transform\n */\n\n\nconst rewriteExportNames = ({\n  ast,\n  module,\n  externalExports\n}) => bin => {\n  return editWithAST(ast, bin, {\n    ModuleExport(path) {\n      const isExternal = externalExports.has(path.node.name);\n\n      if (isExternal) {\n        path.remove();\n        return;\n      }\n\n      const usedName = module.isUsed(path.node.name);\n\n      if (!usedName) {\n        path.remove();\n        return;\n      }\n\n      path.node.name = usedName;\n    }\n\n  });\n};\n/**\n * Mangle import names and modules\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names\n * @returns {ArrayBufferTransform} transform\n */\n\n\nconst rewriteImports = ({\n  ast,\n  usedDependencyMap\n}) => bin => {\n  return editWithAST(ast, bin, {\n    ModuleImport(path) {\n      const result = usedDependencyMap.get(path.node.module + \":\" + path.node.name);\n\n      if (result !== undefined) {\n        path.node.module = result.module;\n        path.node.name = result.name;\n      }\n    }\n\n  });\n};\n/**\n * Add an init function.\n *\n * The init function fills the globals given input arguments.\n *\n * @param {Object} state transformation state\n * @param {Object} state.ast Module's ast\n * @param {t.Identifier} state.initFuncId identifier of the init function\n * @param {t.Index} state.startAtFuncOffset index of the start function\n * @param {t.ModuleImport[]} state.importedGlobals list of imported globals\n * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function\n * @param {t.Index} state.nextFuncIndex index of the next function\n * @param {t.Index} state.nextTypeIndex index of the next type\n * @returns {ArrayBufferTransform} transform\n */\n\n\nconst addInitFunction = ({\n  ast,\n  initFuncId,\n  startAtFuncOffset,\n  importedGlobals,\n  additionalInitCode,\n  nextFuncIndex,\n  nextTypeIndex\n}) => bin => {\n  const funcParams = importedGlobals.map(importedGlobal => {\n    // used for debugging\n    const id = t.identifier(\"\".concat(importedGlobal.module, \".\").concat(importedGlobal.name));\n    return t.funcParam(importedGlobal.descr.valtype, id);\n  });\n  const funcBody = importedGlobals.reduce((acc, importedGlobal, index) => {\n    const args = [t.indexLiteral(index)];\n    const body = [t.instruction(\"get_local\", args), t.instruction(\"set_global\", args)];\n    return [...acc, ...body];\n  }, []);\n\n  if (typeof startAtFuncOffset === \"number\") {\n    funcBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));\n  }\n\n  for (const instr of additionalInitCode) {\n    funcBody.push(instr);\n  }\n\n  funcBody.push(t.instruction(\"end\"));\n  const funcResults = []; // Code section\n\n  const funcSignature = t.signature(funcParams, funcResults);\n  const func = t.func(initFuncId, funcSignature, funcBody); // Type section\n\n  const functype = t.typeInstruction(undefined, funcSignature); // Func section\n\n  const funcindex = t.indexInFuncSection(nextTypeIndex); // Export section\n\n  const moduleExport = t.moduleExport(initFuncId.value, t.moduleExportDescr(\"Func\", nextFuncIndex));\n  return addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);\n};\n/**\n * Extract mangle mappings from module\n * @param {Module} module current module\n * @param {boolean} mangle mangle imports\n * @returns {Map<string, UsedWasmDependency>} mappings to mangled names\n */\n\n\nconst getUsedDependencyMap = (module, mangle) => {\n  /** @type {Map<string, UsedWasmDependency>} */\n  const map = new Map();\n\n  for (const usedDep of WebAssemblyUtils.getUsedDependencies(module, mangle)) {\n    const dep = usedDep.dependency;\n    const request = dep.request;\n    const exportName = dep.name;\n    map.set(request + \":\" + exportName, usedDep);\n  }\n\n  return map;\n};\n\nclass WebAssemblyGenerator extends Generator {\n  constructor(options) {\n    super();\n    this.options = options;\n  }\n  /**\n   * @param {NormalModule} module module for which the code should be generated\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates\n   * @param {RuntimeTemplate} runtimeTemplate the runtime template\n   * @param {string} type which kind of code should be generated\n   * @returns {Source} generated code\n   */\n\n\n  generate(module, dependencyTemplates, runtimeTemplate, type) {\n    let bin = module.originalSource().source();\n    const initFuncId = t.identifier(Array.isArray(module.usedExports) ? Template.numberToIdentifer(module.usedExports.length) : \"__webpack_init__\"); // parse it\n\n    const ast = decode(bin, {\n      ignoreDataSection: true,\n      ignoreCodeSection: true,\n      ignoreCustomNameSection: true\n    });\n    const moduleContext = moduleContextFromModuleAST(ast.body[0]);\n    const importedGlobals = getImportedGlobals(ast);\n    const countImportedFunc = getCountImportedFunc(ast);\n    const startAtFuncOffset = moduleContext.getStart();\n    const nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);\n    const nextTypeIndex = getNextTypeIndex(ast);\n    const usedDependencyMap = getUsedDependencyMap(module, this.options.mangleImports);\n    const externalExports = new Set(module.dependencies.filter(d => d instanceof WebAssemblyExportImportedDependency).map(d => {\n      const wasmDep =\n      /** @type {WebAssemblyExportImportedDependency} */\n      d;\n      return wasmDep.exportName;\n    }));\n    /** @type {t.Instruction[]} */\n\n    const additionalInitCode = [];\n    const transform = compose(rewriteExportNames({\n      ast,\n      module,\n      externalExports\n    }), removeStartFunc({\n      ast\n    }), rewriteImportedGlobals({\n      ast,\n      additionalInitCode\n    }), rewriteImports({\n      ast,\n      usedDependencyMap\n    }), addInitFunction({\n      ast,\n      initFuncId,\n      importedGlobals,\n      additionalInitCode,\n      startAtFuncOffset,\n      nextFuncIndex,\n      nextTypeIndex\n    }));\n    const newBin = transform(bin);\n    return new RawSource(newBin);\n  }\n\n}\n\nmodule.exports = WebAssemblyGenerator;","map":null,"metadata":{},"sourceType":"script"}