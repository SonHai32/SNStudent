{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst AMDRequireItemDependency = require(\"./AMDRequireItemDependency\");\n\nconst AMDRequireArrayDependency = require(\"./AMDRequireArrayDependency\");\n\nconst AMDRequireContextDependency = require(\"./AMDRequireContextDependency\");\n\nconst AMDRequireDependenciesBlock = require(\"./AMDRequireDependenciesBlock\");\n\nconst UnsupportedDependency = require(\"./UnsupportedDependency\");\n\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\n\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\n\nconst LocalModulesHelpers = require(\"./LocalModulesHelpers\");\n\nconst ConstDependency = require(\"./ConstDependency\");\n\nconst getFunctionExpression = require(\"./getFunctionExpression\");\n\nconst UnsupportedFeatureWarning = require(\"../UnsupportedFeatureWarning\");\n\nclass AMDRequireDependenciesBlockParserPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n\n  processFunctionArgument(parser, expression) {\n    let bindThis = true;\n    const fnData = getFunctionExpression(expression);\n\n    if (fnData) {\n      parser.inScope(fnData.fn.params.filter(i => {\n        return ![\"require\", \"module\", \"exports\"].includes(i.name);\n      }), () => {\n        if (fnData.fn.body.type === \"BlockStatement\") {\n          parser.walkStatement(fnData.fn.body);\n        } else {\n          parser.walkExpression(fnData.fn.body);\n        }\n      });\n      parser.walkExpressions(fnData.expressions);\n\n      if (fnData.needThis === false) {\n        bindThis = false;\n      }\n    } else {\n      parser.walkExpression(expression);\n    }\n\n    return bindThis;\n  }\n\n  apply(parser) {\n    parser.hooks.call.for(\"require\").tap(\"AMDRequireDependenciesBlockParserPlugin\", this.processCallRequire.bind(this, parser));\n  }\n\n  processArray(parser, expr, param) {\n    if (param.isArray()) {\n      for (const p of param.items) {\n        const result = this.processItem(parser, expr, p);\n\n        if (result === undefined) {\n          this.processContext(parser, expr, p);\n        }\n      }\n\n      return true;\n    } else if (param.isConstArray()) {\n      const deps = [];\n\n      for (const request of param.array) {\n        let dep, localModule;\n\n        if (request === \"require\") {\n          dep = \"__webpack_require__\";\n        } else if ([\"exports\", \"module\"].includes(request)) {\n          dep = request;\n        } else if (localModule = LocalModulesHelpers.getLocalModule(parser.state, request)) {\n          dep = new LocalModuleDependency(localModule, undefined, false);\n          dep.loc = expr.loc;\n          parser.state.current.addDependency(dep);\n        } else {\n          dep = this.newRequireItemDependency(request);\n          dep.loc = expr.loc;\n          dep.optional = !!parser.scope.inTry;\n          parser.state.current.addDependency(dep);\n        }\n\n        deps.push(dep);\n      }\n\n      const dep = this.newRequireArrayDependency(deps, param.range);\n      dep.loc = expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    }\n  }\n\n  processItem(parser, expr, param) {\n    if (param.isConditional()) {\n      for (const p of param.options) {\n        const result = this.processItem(parser, expr, p);\n\n        if (result === undefined) {\n          this.processContext(parser, expr, p);\n        }\n      }\n\n      return true;\n    } else if (param.isString()) {\n      let dep, localModule;\n\n      if (param.string === \"require\") {\n        dep = new ConstDependency(\"__webpack_require__\", param.string);\n      } else if (param.string === \"module\") {\n        dep = new ConstDependency(parser.state.module.buildInfo.moduleArgument, param.range);\n      } else if (param.string === \"exports\") {\n        dep = new ConstDependency(parser.state.module.buildInfo.exportsArgument, param.range);\n      } else if (localModule = LocalModulesHelpers.getLocalModule(parser.state, param.string)) {\n        dep = new LocalModuleDependency(localModule, param.range, false);\n      } else {\n        dep = this.newRequireItemDependency(param.string, param.range);\n      }\n\n      dep.loc = expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    }\n  }\n\n  processContext(parser, expr, param) {\n    const dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {}, parser);\n    if (!dep) return;\n    dep.loc = expr.loc;\n    dep.optional = !!parser.scope.inTry;\n    parser.state.current.addDependency(dep);\n    return true;\n  }\n\n  processArrayForRequestString(param) {\n    if (param.isArray()) {\n      const result = param.items.map(item => this.processItemForRequestString(item));\n      if (result.every(Boolean)) return result.join(\" \");\n    } else if (param.isConstArray()) {\n      return param.array.join(\" \");\n    }\n  }\n\n  processItemForRequestString(param) {\n    if (param.isConditional()) {\n      const result = param.options.map(item => this.processItemForRequestString(item));\n      if (result.every(Boolean)) return result.join(\"|\");\n    } else if (param.isString()) {\n      return param.string;\n    }\n  }\n\n  processCallRequire(parser, expr) {\n    let param;\n    let dep;\n    let result;\n    const old = parser.state.current;\n\n    if (expr.arguments.length >= 1) {\n      param = parser.evaluateExpression(expr.arguments[0]);\n      dep = this.newRequireDependenciesBlock(expr, param.range, expr.arguments.length > 1 ? expr.arguments[1].range : null, expr.arguments.length > 2 ? expr.arguments[2].range : null, parser.state.module, expr.loc, this.processArrayForRequestString(param));\n      parser.state.current = dep;\n    }\n\n    if (expr.arguments.length === 1) {\n      parser.inScope([], () => {\n        result = this.processArray(parser, expr, param);\n      });\n      parser.state.current = old;\n      if (!result) return;\n      parser.state.current.addBlock(dep);\n      return true;\n    }\n\n    if (expr.arguments.length === 2 || expr.arguments.length === 3) {\n      try {\n        parser.inScope([], () => {\n          result = this.processArray(parser, expr, param);\n        });\n\n        if (!result) {\n          dep = new UnsupportedDependency(\"unsupported\", expr.range);\n          old.addDependency(dep);\n\n          if (parser.state.module) {\n            parser.state.module.errors.push(new UnsupportedFeatureWarning(parser.state.module, \"Cannot statically analyse 'require(…, …)' in line \" + expr.loc.start.line, expr.loc));\n          }\n\n          dep = null;\n          return true;\n        }\n\n        dep.functionBindThis = this.processFunctionArgument(parser, expr.arguments[1]);\n\n        if (expr.arguments.length === 3) {\n          dep.errorCallbackBindThis = this.processFunctionArgument(parser, expr.arguments[2]);\n        }\n      } finally {\n        parser.state.current = old;\n        if (dep) parser.state.current.addBlock(dep);\n      }\n\n      return true;\n    }\n  }\n\n  newRequireDependenciesBlock(expr, arrayRange, functionRange, errorCallbackRange, module, loc, request) {\n    return new AMDRequireDependenciesBlock(expr, arrayRange, functionRange, errorCallbackRange, module, loc, request);\n  }\n\n  newRequireItemDependency(request, range) {\n    return new AMDRequireItemDependency(request, range);\n  }\n\n  newRequireArrayDependency(depsArray, range) {\n    return new AMDRequireArrayDependency(depsArray, range);\n  }\n\n}\n\nmodule.exports = AMDRequireDependenciesBlockParserPlugin;","map":null,"metadata":{},"sourceType":"script"}