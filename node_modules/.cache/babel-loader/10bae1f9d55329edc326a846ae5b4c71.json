{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _sourceMap = require(\"source-map\");\n\nvar _webpackSources = require(\"webpack-sources\");\n\nvar _RequestShortener = _interopRequireDefault(require(\"webpack/lib/RequestShortener\"));\n\nvar _ModuleFilenameHelpers = _interopRequireDefault(require(\"webpack/lib/ModuleFilenameHelpers\"));\n\nvar _schemaUtils = _interopRequireDefault(require(\"schema-utils\"));\n\nvar _serializeJavascript = _interopRequireDefault(require(\"serialize-javascript\"));\n\nvar _package = _interopRequireDefault(require(\"terser/package.json\"));\n\nvar _options = _interopRequireDefault(require(\"./options.json\"));\n\nvar _TaskRunner = _interopRequireDefault(require(\"./TaskRunner\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst warningRegex = /\\[.+:([0-9]+),([0-9]+)\\]/;\n\nclass TerserPlugin {\n  constructor(options = {}) {\n    (0, _schemaUtils.default)(_options.default, options, 'Terser Plugin');\n    const minify = options.minify,\n          _options$terserOption = options.terserOptions,\n          terserOptions = _options$terserOption === void 0 ? {} : _options$terserOption,\n          _options$test = options.test,\n          test = _options$test === void 0 ? /\\.m?js(\\?.*)?$/i : _options$test,\n          _options$chunkFilter = options.chunkFilter,\n          chunkFilter = _options$chunkFilter === void 0 ? () => true : _options$chunkFilter,\n          _options$warningsFilt = options.warningsFilter,\n          warningsFilter = _options$warningsFilt === void 0 ? () => true : _options$warningsFilt,\n          _options$extractComme = options.extractComments,\n          extractComments = _options$extractComme === void 0 ? false : _options$extractComme,\n          _options$sourceMap = options.sourceMap,\n          sourceMap = _options$sourceMap === void 0 ? false : _options$sourceMap,\n          _options$cache = options.cache,\n          cache = _options$cache === void 0 ? false : _options$cache,\n          _options$cacheKeys = options.cacheKeys,\n          cacheKeys = _options$cacheKeys === void 0 ? defaultCacheKeys => defaultCacheKeys : _options$cacheKeys,\n          _options$parallel = options.parallel,\n          parallel = _options$parallel === void 0 ? false : _options$parallel,\n          include = options.include,\n          exclude = options.exclude;\n    this.options = {\n      test,\n      chunkFilter,\n      warningsFilter,\n      extractComments,\n      sourceMap,\n      cache,\n      cacheKeys,\n      parallel,\n      include,\n      exclude,\n      minify,\n      terserOptions: _objectSpread({\n        output: {\n          comments: extractComments ? false : /^\\**!|@preserve|@license|@cc_on/i\n        }\n      }, terserOptions)\n    };\n  }\n\n  static isSourceMap(input) {\n    // All required options for `new SourceMapConsumer(...options)`\n    // https://github.com/mozilla/source-map#new-sourcemapconsumerrawsourcemap\n    return Boolean(input && input.version && input.sources && Array.isArray(input.sources) && typeof input.mappings === 'string');\n  }\n\n  static buildSourceMap(inputSourceMap) {\n    if (!inputSourceMap || !TerserPlugin.isSourceMap(inputSourceMap)) {\n      return null;\n    }\n\n    return new _sourceMap.SourceMapConsumer(inputSourceMap);\n  }\n\n  static buildError(err, file, sourceMap, requestShortener) {\n    // Handling error which should have line, col, filename and message\n    if (err.line) {\n      const original = sourceMap && sourceMap.originalPositionFor({\n        line: err.line,\n        column: err.col\n      });\n\n      if (original && original.source && requestShortener) {\n        return new Error(\"\".concat(file, \" from Terser\\n\").concat(err.message, \" [\").concat(requestShortener.shorten(original.source), \":\").concat(original.line, \",\").concat(original.column, \"][\").concat(file, \":\").concat(err.line, \",\").concat(err.col, \"]\"));\n      }\n\n      return new Error(\"\".concat(file, \" from Terser\\n\").concat(err.message, \" [\").concat(file, \":\").concat(err.line, \",\").concat(err.col, \"]\"));\n    } else if (err.stack) {\n      return new Error(\"\".concat(file, \" from Terser\\n\").concat(err.stack));\n    }\n\n    return new Error(\"\".concat(file, \" from Terser\\n\").concat(err.message));\n  }\n\n  static buildWarning(warning, file, sourceMap, requestShortener, warningsFilter) {\n    let warningMessage = warning;\n    let locationMessage = '';\n    let source = null;\n\n    if (sourceMap) {\n      const match = warningRegex.exec(warning);\n\n      if (match) {\n        const line = +match[1];\n        const column = +match[2];\n        const original = sourceMap.originalPositionFor({\n          line,\n          column\n        });\n\n        if (original && original.source && original.source !== file && requestShortener) {\n          source = original.source;\n          warningMessage = \"\".concat(warningMessage.replace(warningRegex, ''));\n          locationMessage = \"[\".concat(requestShortener.shorten(original.source), \":\").concat(original.line, \",\").concat(original.column, \"]\");\n        }\n      }\n    }\n\n    if (warningsFilter && !warningsFilter(warning, source)) {\n      return null;\n    }\n\n    return \"Terser Plugin: \".concat(warningMessage).concat(locationMessage);\n  }\n\n  apply(compiler) {\n    const buildModuleFn = moduleArg => {\n      // to get detailed location info about errors\n      moduleArg.useSourceMap = true;\n    };\n\n    const optimizeFn = (compilation, chunks, callback) => {\n      const taskRunner = new _TaskRunner.default({\n        cache: this.options.cache,\n        parallel: this.options.parallel\n      });\n      const processedAssets = new WeakSet();\n      const tasks = [];\n      const chunkFilter = this.options.chunkFilter;\n      Array.from(chunks).filter(chunk => chunkFilter && chunkFilter(chunk)).reduce((acc, chunk) => acc.concat(chunk.files || []), []).concat(compilation.additionalChunkAssets || []).filter(_ModuleFilenameHelpers.default.matchObject.bind(null, this.options)).forEach(file => {\n        let inputSourceMap;\n        const asset = compilation.assets[file];\n\n        if (processedAssets.has(asset)) {\n          return;\n        }\n\n        try {\n          let input;\n\n          if (this.options.sourceMap && asset.sourceAndMap) {\n            const _asset$sourceAndMap = asset.sourceAndMap(),\n                  source = _asset$sourceAndMap.source,\n                  map = _asset$sourceAndMap.map;\n\n            input = source;\n\n            if (TerserPlugin.isSourceMap(map)) {\n              inputSourceMap = map;\n            } else {\n              inputSourceMap = map;\n              compilation.warnings.push(new Error(\"\".concat(file, \" contains invalid source map\")));\n            }\n          } else {\n            input = asset.source();\n            inputSourceMap = null;\n          } // Handling comment extraction\n\n\n          let commentsFile = false;\n\n          if (this.options.extractComments) {\n            commentsFile = this.options.extractComments.filename || \"\".concat(file, \".LICENSE\");\n\n            if (typeof commentsFile === 'function') {\n              commentsFile = commentsFile(file);\n            }\n          }\n\n          const task = {\n            file,\n            input,\n            inputSourceMap,\n            commentsFile,\n            extractComments: this.options.extractComments,\n            terserOptions: this.options.terserOptions,\n            minify: this.options.minify\n          };\n\n          if (this.options.cache) {\n            const defaultCacheKeys = {\n              terser: _package.default.version,\n              node_version: process.version,\n              // eslint-disable-next-line global-require\n              'terser-webpack-plugin': require('../package.json').version,\n              'terser-webpack-plugin-options': this.options,\n              hash: _crypto.default.createHash('md4').update(input).digest('hex')\n            };\n            task.cacheKeys = this.options.cacheKeys(defaultCacheKeys, file);\n          }\n\n          tasks.push(task);\n        } catch (error) {\n          compilation.errors.push(TerserPlugin.buildError(error, file, TerserPlugin.buildSourceMap(inputSourceMap), new _RequestShortener.default(compiler.context)));\n        }\n      });\n      taskRunner.run(tasks, (tasksError, results) => {\n        if (tasksError) {\n          compilation.errors.push(tasksError);\n          return;\n        }\n\n        results.forEach((data, index) => {\n          const _tasks$index = tasks[index],\n                file = _tasks$index.file,\n                input = _tasks$index.input,\n                inputSourceMap = _tasks$index.inputSourceMap,\n                commentsFile = _tasks$index.commentsFile;\n          const error = data.error,\n                map = data.map,\n                code = data.code,\n                warnings = data.warnings;\n          let extractedComments = data.extractedComments;\n          let sourceMap = null;\n\n          if (error || warnings && warnings.length > 0) {\n            sourceMap = TerserPlugin.buildSourceMap(inputSourceMap);\n          } // Handling results\n          // Error case: add errors, and go to next file\n\n\n          if (error) {\n            compilation.errors.push(TerserPlugin.buildError(error, file, sourceMap, new _RequestShortener.default(compiler.context)));\n            return;\n          }\n\n          let outputSource;\n\n          if (map) {\n            outputSource = new _webpackSources.SourceMapSource(code, file, JSON.parse(map), input, inputSourceMap, true);\n          } else {\n            outputSource = new _webpackSources.RawSource(code);\n          } // Write extracted comments to commentsFile\n\n\n          if (commentsFile && extractedComments && extractedComments.length > 0) {\n            if (commentsFile in compilation.assets) {\n              const commentsFileSource = compilation.assets[commentsFile].source();\n              extractedComments = extractedComments.filter(comment => !commentsFileSource.includes(comment));\n            }\n\n            if (extractedComments.length > 0) {\n              // Add a banner to the original file\n              if (this.options.extractComments.banner !== false) {\n                let banner = this.options.extractComments.banner || \"For license information please see \".concat(_path.default.posix.basename(commentsFile));\n\n                if (typeof banner === 'function') {\n                  banner = banner(commentsFile);\n                }\n\n                if (banner) {\n                  outputSource = new _webpackSources.ConcatSource(\"/*! \".concat(banner, \" */\\n\"), outputSource);\n                }\n              }\n\n              const commentsSource = new _webpackSources.RawSource(\"\".concat(extractedComments.join('\\n\\n'), \"\\n\"));\n\n              if (commentsFile in compilation.assets) {\n                // commentsFile already exists, append new comments...\n                if (compilation.assets[commentsFile] instanceof _webpackSources.ConcatSource) {\n                  compilation.assets[commentsFile].add('\\n');\n                  compilation.assets[commentsFile].add(commentsSource);\n                } else {\n                  compilation.assets[commentsFile] = new _webpackSources.ConcatSource(compilation.assets[commentsFile], '\\n', commentsSource);\n                }\n              } else {\n                compilation.assets[commentsFile] = commentsSource;\n              }\n            }\n          } // Updating assets\n\n\n          processedAssets.add(compilation.assets[file] = outputSource); // Handling warnings\n\n          if (warnings && warnings.length > 0) {\n            warnings.forEach(warning => {\n              const builtWarning = TerserPlugin.buildWarning(warning, file, sourceMap, new _RequestShortener.default(compiler.context), this.options.warningsFilter);\n\n              if (builtWarning) {\n                compilation.warnings.push(builtWarning);\n              }\n            });\n          }\n        });\n        taskRunner.exit();\n        callback();\n      });\n    };\n\n    const plugin = {\n      name: this.constructor.name\n    };\n    compiler.hooks.compilation.tap(plugin, compilation => {\n      if (this.options.sourceMap) {\n        compilation.hooks.buildModule.tap(plugin, buildModuleFn);\n      }\n\n      const mainTemplate = compilation.mainTemplate,\n            chunkTemplate = compilation.chunkTemplate; // Regenerate `contenthash` for minified assets\n\n      for (const template of [mainTemplate, chunkTemplate]) {\n        template.hooks.hashForChunk.tap(plugin, hash => {\n          const data = (0, _serializeJavascript.default)({\n            terser: _package.default.version,\n            terserOptions: this.options.terserOptions\n          });\n          hash.update('TerserPlugin');\n          hash.update(data);\n        });\n      }\n\n      compilation.hooks.optimizeChunkAssets.tapAsync(plugin, optimizeFn.bind(this, compilation));\n    });\n  }\n\n}\n\nvar _default = TerserPlugin;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}