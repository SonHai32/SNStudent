{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst path = require(\"path\");\n\nconst _require = require(\"tapable\"),\n      Tapable = _require.Tapable,\n      AsyncSeriesWaterfallHook = _require.AsyncSeriesWaterfallHook,\n      SyncWaterfallHook = _require.SyncWaterfallHook;\n\nconst ContextModule = require(\"./ContextModule\");\n\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\n/** @typedef {import(\"./Module\")} Module */\n\n\nconst EMPTY_RESOLVE_OPTIONS = {};\nmodule.exports = class ContextModuleFactory extends Tapable {\n  constructor(resolverFactory) {\n    super();\n    this.hooks = {\n      /** @type {AsyncSeriesWaterfallHook<TODO>} */\n      beforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {AsyncSeriesWaterfallHook<TODO>} */\n      afterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {SyncWaterfallHook<string[]>} */\n      contextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\n      /** @type {SyncWaterfallHook<TODO[]>} */\n      alternatives: new AsyncSeriesWaterfallHook([\"modules\"])\n    };\n\n    this._pluginCompat.tap(\"ContextModuleFactory\", options => {\n      switch (options.name) {\n        case \"before-resolve\":\n        case \"after-resolve\":\n        case \"alternatives\":\n          options.async = true;\n          break;\n      }\n    });\n\n    this.resolverFactory = resolverFactory;\n  }\n\n  create(data, callback) {\n    const context = data.context;\n    const dependencies = data.dependencies;\n    const resolveOptions = data.resolveOptions;\n    const dependency = dependencies[0];\n    this.hooks.beforeResolve.callAsync(Object.assign({\n      context: context,\n      dependencies: dependencies,\n      resolveOptions\n    }, dependency.options), (err, beforeResolveResult) => {\n      if (err) return callback(err); // Ignored\n\n      if (!beforeResolveResult) return callback();\n      const context = beforeResolveResult.context;\n      const request = beforeResolveResult.request;\n      const resolveOptions = beforeResolveResult.resolveOptions;\n      let loaders,\n          resource,\n          loadersPrefix = \"\";\n      const idx = request.lastIndexOf(\"!\");\n\n      if (idx >= 0) {\n        let loadersRequest = request.substr(0, idx + 1);\n        let i;\n\n        for (i = 0; i < loadersRequest.length && loadersRequest[i] === \"!\"; i++) {\n          loadersPrefix += \"!\";\n        }\n\n        loadersRequest = loadersRequest.substr(i).replace(/!+$/, \"\").replace(/!!+/g, \"!\");\n\n        if (loadersRequest === \"\") {\n          loaders = [];\n        } else {\n          loaders = loadersRequest.split(\"!\");\n        }\n\n        resource = request.substr(idx + 1);\n      } else {\n        loaders = [];\n        resource = request;\n      }\n\n      const contextResolver = this.resolverFactory.get(\"context\", resolveOptions || EMPTY_RESOLVE_OPTIONS);\n      const loaderResolver = this.resolverFactory.get(\"loader\", EMPTY_RESOLVE_OPTIONS);\n      asyncLib.parallel([callback => {\n        contextResolver.resolve({}, context, resource, {}, (err, result) => {\n          if (err) return callback(err);\n          callback(null, result);\n        });\n      }, callback => {\n        asyncLib.map(loaders, (loader, callback) => {\n          loaderResolver.resolve({}, context, loader, {}, (err, result) => {\n            if (err) return callback(err);\n            callback(null, result);\n          });\n        }, callback);\n      }], (err, result) => {\n        if (err) return callback(err);\n        this.hooks.afterResolve.callAsync(Object.assign({\n          addon: loadersPrefix + result[1].join(\"!\") + (result[1].length > 0 ? \"!\" : \"\"),\n          resource: result[0],\n          resolveDependencies: this.resolveDependencies.bind(this)\n        }, beforeResolveResult), (err, result) => {\n          if (err) return callback(err); // Ignored\n\n          if (!result) return callback();\n          return callback(null, new ContextModule(result.resolveDependencies, result));\n        });\n      });\n    });\n  }\n\n  resolveDependencies(fs, options, callback) {\n    const cmf = this;\n    let resource = options.resource;\n    let resourceQuery = options.resourceQuery;\n    let recursive = options.recursive;\n    let regExp = options.regExp;\n    let include = options.include;\n    let exclude = options.exclude;\n    if (!regExp || !resource) return callback(null, []);\n\n    const addDirectory = (directory, callback) => {\n      fs.readdir(directory, (err, files) => {\n        if (err) return callback(err);\n        files = cmf.hooks.contextModuleFiles.call(files);\n        if (!files || files.length === 0) return callback(null, []);\n        asyncLib.map(files.filter(p => p.indexOf(\".\") !== 0), (segment, callback) => {\n          const subResource = path.join(directory, segment);\n\n          if (!exclude || !subResource.match(exclude)) {\n            fs.stat(subResource, (err, stat) => {\n              if (err) {\n                if (err.code === \"ENOENT\") {\n                  // ENOENT is ok here because the file may have been deleted between\n                  // the readdir and stat calls.\n                  return callback();\n                } else {\n                  return callback(err);\n                }\n              }\n\n              if (stat.isDirectory()) {\n                if (!recursive) return callback();\n                addDirectory.call(this, subResource, callback);\n              } else if (stat.isFile() && (!include || subResource.match(include))) {\n                const obj = {\n                  context: resource,\n                  request: \".\" + subResource.substr(resource.length).replace(/\\\\/g, \"/\")\n                };\n                this.hooks.alternatives.callAsync([obj], (err, alternatives) => {\n                  if (err) return callback(err);\n                  alternatives = alternatives.filter(obj => regExp.test(obj.request)).map(obj => {\n                    const dep = new ContextElementDependency(obj.request + resourceQuery, obj.request);\n                    dep.optional = true;\n                    return dep;\n                  });\n                  callback(null, alternatives);\n                });\n              } else {\n                callback();\n              }\n            });\n          } else {\n            callback();\n          }\n        }, (err, result) => {\n          if (err) return callback(err);\n          if (!result) return callback(null, []);\n          callback(null, result.filter(Boolean).reduce((a, i) => a.concat(i), []));\n        });\n      });\n    };\n\n    addDirectory(resource, callback);\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}