{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nclass MergeDuplicateChunksPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"MergeDuplicateChunksPlugin\", compilation => {\n      compilation.hooks.optimizeChunksBasic.tap(\"MergeDuplicateChunksPlugin\", chunks => {\n        // remember already tested chunks for performance\n        const notDuplicates = new Set(); // for each chunk\n\n        for (const chunk of chunks) {\n          // track a Set of all chunk that could be duplicates\n          let possibleDuplicates;\n\n          for (const module of chunk.modulesIterable) {\n            if (possibleDuplicates === undefined) {\n              // when possibleDuplicates is not yet set,\n              // create a new Set from chunks of the current module\n              // including only chunks with the same number of modules\n              for (const dup of module.chunksIterable) {\n                if (dup !== chunk && chunk.getNumberOfModules() === dup.getNumberOfModules() && !notDuplicates.has(dup)) {\n                  // delay allocating the new Set until here, reduce memory pressure\n                  if (possibleDuplicates === undefined) {\n                    possibleDuplicates = new Set();\n                  }\n\n                  possibleDuplicates.add(dup);\n                }\n              } // when no chunk is possible we can break here\n\n\n              if (possibleDuplicates === undefined) break;\n            } else {\n              // validate existing possible duplicates\n              for (const dup of possibleDuplicates) {\n                // remove possible duplicate when module is not contained\n                if (!dup.containsModule(module)) {\n                  possibleDuplicates.delete(dup);\n                }\n              } // when all chunks has been removed we can break here\n\n\n              if (possibleDuplicates.size === 0) break;\n            }\n          } // when we found duplicates\n\n\n          if (possibleDuplicates !== undefined && possibleDuplicates.size > 0) {\n            for (const otherChunk of possibleDuplicates) {\n              if (otherChunk.hasRuntime() !== chunk.hasRuntime()) continue; // merge them\n\n              if (chunk.integrate(otherChunk, \"duplicate\")) {\n                chunks.splice(chunks.indexOf(otherChunk), 1);\n              }\n            }\n          } // don't check already processed chunks twice\n\n\n          notDuplicates.add(chunk);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = MergeDuplicateChunksPlugin;","map":null,"metadata":{},"sourceType":"script"}