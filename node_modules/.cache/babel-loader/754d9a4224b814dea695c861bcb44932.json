{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nconst figgyPudding = require('figgy-pudding');\n\nconst Transform = require('stream').Transform;\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512'];\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;\nconst SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/;\nconst STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)*$/;\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/;\nconst SsriOpts = figgyPudding({\n  algorithms: {\n    default: ['sha512']\n  },\n  error: {\n    default: false\n  },\n  integrity: {},\n  options: {\n    default: []\n  },\n  pickAlgorithm: {\n    default: () => getPrioritizedHash\n  },\n  Promise: {\n    default: () => Promise\n  },\n  sep: {\n    default: ' '\n  },\n  single: {\n    default: false\n  },\n  size: {},\n  strict: {\n    default: false\n  }\n});\n\nclass Hash {\n  get isHash() {\n    return true;\n  }\n\n  constructor(hash, opts) {\n    opts = SsriOpts(opts);\n    const strict = !!opts.strict;\n    this.source = hash.trim(); // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n\n    const match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);\n\n    if (!match) {\n      return;\n    }\n\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) {\n      return;\n    }\n\n    this.algorithm = match[1];\n    this.digest = match[2];\n    const rawOpts = match[3];\n    this.options = rawOpts ? rawOpts.slice(1).split('?') : [];\n  }\n\n  hexDigest() {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex');\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  toString(opts) {\n    opts = SsriOpts(opts);\n\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!( // The spec has very restricted productions for algorithms.\n      // https://www.w3.org/TR/CSP2/#source-list-syntax\n      SPEC_ALGORITHMS.some(x => x === this.algorithm) && // Usually, if someone insists on using a \"different\" base64, we\n      // leave it as-is, since there's multiple standards, and the\n      // specified is not a URL-safe variant.\n      // https://www.w3.org/TR/CSP2/#base64_value\n      this.digest.match(BASE64_REGEX) && // Option syntax is strictly visual chars.\n      // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n      // https://tools.ietf.org/html/rfc5234#appendix-B.1\n      (this.options || []).every(opt => opt.match(VCHAR_REGEX)))) {\n        return '';\n      }\n    }\n\n    const options = this.options && this.options.length ? \"?\".concat(this.options.join('?')) : '';\n    return \"\".concat(this.algorithm, \"-\").concat(this.digest).concat(options);\n  }\n\n}\n\nclass Integrity {\n  get isIntegrity() {\n    return true;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  toString(opts) {\n    opts = SsriOpts(opts);\n    let sep = opts.sep || ' ';\n\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ');\n    }\n\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts);\n      }).filter(x => x.length).join(sep);\n    }).filter(x => x.length).join(sep);\n  }\n\n  concat(integrity, opts) {\n    opts = SsriOpts(opts);\n    const other = typeof integrity === 'string' ? integrity : stringify(integrity, opts);\n    return parse(\"\".concat(this.toString(opts), \" \").concat(other), opts);\n  }\n\n  hexDigest() {\n    return parse(this, {\n      single: true\n    }).hexDigest();\n  }\n\n  match(integrity, opts) {\n    opts = SsriOpts(opts);\n    const other = parse(integrity, opts);\n    const algo = other.pickAlgorithm(opts);\n    return this[algo] && other[algo] && this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest)) || false;\n  }\n\n  pickAlgorithm(opts) {\n    opts = SsriOpts(opts);\n    const pickAlgorithm = opts.pickAlgorithm;\n    const keys = Object.keys(this);\n\n    if (!keys.length) {\n      throw new Error(\"No algorithms available for \".concat(JSON.stringify(this.toString())));\n    }\n\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc;\n    });\n  }\n\n}\n\nmodule.exports.parse = parse;\n\nfunction parse(sri, opts) {\n  opts = SsriOpts(opts);\n\n  if (typeof sri === 'string') {\n    return _parse(sri, opts);\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity();\n    fullSri[sri.algorithm] = [sri];\n    return _parse(stringify(fullSri, opts), opts);\n  } else {\n    return _parse(stringify(sri, opts), opts);\n  }\n}\n\nfunction _parse(integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts);\n  }\n\n  return integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts);\n\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n\n      acc[algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n}\n\nmodule.exports.stringify = stringify;\n\nfunction stringify(obj, opts) {\n  opts = SsriOpts(opts);\n\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts);\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts);\n  } else {\n    return Integrity.prototype.toString.call(obj, opts);\n  }\n}\n\nmodule.exports.fromHex = fromHex;\n\nfunction fromHex(hexDigest, algorithm, opts) {\n  opts = SsriOpts(opts);\n  const optString = opts.options && opts.options.length ? \"?\".concat(opts.options.join('?')) : '';\n  return parse(\"\".concat(algorithm, \"-\").concat(Buffer.from(hexDigest, 'hex').toString('base64')).concat(optString), opts);\n}\n\nmodule.exports.fromData = fromData;\n\nfunction fromData(data, opts) {\n  opts = SsriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = opts.options && opts.options.length ? \"?\".concat(opts.options.join('?')) : '';\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64');\n    const hash = new Hash(\"\".concat(algo, \"-\").concat(digest).concat(optString), opts);\n\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n\n      acc[algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n}\n\nmodule.exports.fromStream = fromStream;\n\nfunction fromStream(stream, opts) {\n  opts = SsriOpts(opts);\n  const P = opts.Promise || Promise;\n  const istream = integrityStream(opts);\n  return new P((resolve, reject) => {\n    stream.pipe(istream);\n    stream.on('error', reject);\n    istream.on('error', reject);\n    let sri;\n    istream.on('integrity', s => {\n      sri = s;\n    });\n    istream.on('end', () => resolve(sri));\n    istream.on('data', () => {});\n  });\n}\n\nmodule.exports.checkData = checkData;\n\nfunction checkData(data, sri, opts) {\n  opts = SsriOpts(opts);\n  sri = parse(sri, opts);\n\n  if (!Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY'\n      });\n    } else {\n      return false;\n    }\n  }\n\n  const algorithm = sri.pickAlgorithm(opts);\n  const digest = crypto.createHash(algorithm).update(data).digest('base64');\n  const newSri = parse({\n    algorithm,\n    digest\n  });\n  const match = newSri.match(sri, opts);\n\n  if (match || !opts.error) {\n    return match;\n  } else if (typeof opts.size === 'number' && data.length !== opts.size) {\n    const err = new Error(\"data size mismatch when checking \".concat(sri, \".\\n  Wanted: \").concat(opts.size, \"\\n  Found: \").concat(data.length));\n    err.code = 'EBADSIZE';\n    err.found = data.length;\n    err.expected = opts.size;\n    err.sri = sri;\n    throw err;\n  } else {\n    const err = new Error(\"Integrity checksum failed when using \".concat(algorithm, \": Wanted \").concat(sri, \", but got \").concat(newSri, \". (\").concat(data.length, \" bytes)\"));\n    err.code = 'EINTEGRITY';\n    err.found = newSri;\n    err.expected = sri;\n    err.algorithm = algorithm;\n    err.sri = sri;\n    throw err;\n  }\n}\n\nmodule.exports.checkStream = checkStream;\n\nfunction checkStream(stream, sri, opts) {\n  opts = SsriOpts(opts);\n  const P = opts.Promise || Promise;\n  const checker = integrityStream(opts.concat({\n    integrity: sri\n  }));\n  return new P((resolve, reject) => {\n    stream.pipe(checker);\n    stream.on('error', reject);\n    checker.on('error', reject);\n    let sri;\n    checker.on('verified', s => {\n      sri = s;\n    });\n    checker.on('end', () => resolve(sri));\n    checker.on('data', () => {});\n  });\n}\n\nmodule.exports.integrityStream = integrityStream;\n\nfunction integrityStream(opts) {\n  opts = SsriOpts(opts); // For verification\n\n  const sri = opts.integrity && parse(opts.integrity, opts);\n  const goodSri = sri && Object.keys(sri).length;\n  const algorithm = goodSri && sri.pickAlgorithm(opts);\n  const digests = goodSri && sri[algorithm]; // Calculating stream\n\n  const algorithms = Array.from(new Set(opts.algorithms.concat(algorithm ? [algorithm] : [])));\n  const hashes = algorithms.map(crypto.createHash);\n  let streamSize = 0;\n  const stream = new Transform({\n    transform(chunk, enc, cb) {\n      streamSize += chunk.length;\n      hashes.forEach(h => h.update(chunk, enc));\n      cb(null, chunk, enc);\n    }\n\n  }).on('end', () => {\n    const optString = opts.options && opts.options.length ? \"?\".concat(opts.options.join('?')) : '';\n    const newSri = parse(hashes.map((h, i) => {\n      return \"\".concat(algorithms[i], \"-\").concat(h.digest('base64')).concat(optString);\n    }).join(' '), opts); // Integrity verification mode\n\n    const match = goodSri && newSri.match(sri, opts);\n\n    if (typeof opts.size === 'number' && streamSize !== opts.size) {\n      const err = new Error(\"stream size mismatch when checking \".concat(sri, \".\\n  Wanted: \").concat(opts.size, \"\\n  Found: \").concat(streamSize));\n      err.code = 'EBADSIZE';\n      err.found = streamSize;\n      err.expected = opts.size;\n      err.sri = sri;\n      stream.emit('error', err);\n    } else if (opts.integrity && !match) {\n      const err = new Error(\"\".concat(sri, \" integrity checksum failed when using \").concat(algorithm, \": wanted \").concat(digests, \" but got \").concat(newSri, \". (\").concat(streamSize, \" bytes)\"));\n      err.code = 'EINTEGRITY';\n      err.found = newSri;\n      err.expected = digests;\n      err.algorithm = algorithm;\n      err.sri = sri;\n      stream.emit('error', err);\n    } else {\n      stream.emit('size', streamSize);\n      stream.emit('integrity', newSri);\n      match && stream.emit('verified', match);\n    }\n  });\n  return stream;\n}\n\nmodule.exports.create = createIntegrity;\n\nfunction createIntegrity(opts) {\n  opts = SsriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = opts.options.length ? \"?\".concat(opts.options.join('?')) : '';\n  const hashes = algorithms.map(crypto.createHash);\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc));\n      return this;\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64');\n        const hash = new Hash(\"\".concat(algo, \"-\").concat(digest).concat(optString), opts);\n\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm;\n\n          if (!acc[algo]) {\n            acc[algo] = [];\n          }\n\n          acc[algo].push(hash);\n        }\n\n        return acc;\n      }, new Integrity());\n      return integrity;\n    }\n  };\n}\n\nconst NODE_HASHES = new Set(crypto.getHashes()); // This is a Best Effort™ at a reasonable priority for hash algos\n\nconst DEFAULT_PRIORITY = ['md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', // TODO - it's unclear _which_ of these Node will actually use as its name\n//        for the algorithm, so we guesswork it based on the OpenSSL names.\n'sha3', 'sha3-256', 'sha3-384', 'sha3-512', 'sha3_256', 'sha3_384', 'sha3_512'].filter(algo => NODE_HASHES.has(algo));\n\nfunction getPrioritizedHash(algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;\n}","map":null,"metadata":{},"sourceType":"script"}