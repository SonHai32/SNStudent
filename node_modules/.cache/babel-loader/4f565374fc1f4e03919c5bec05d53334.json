{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n\nconst _require = require(\"webpack-sources\"),\n      OriginalSource = _require.OriginalSource,\n      RawSource = _require.RawSource;\n\nconst Module = require(\"./Module\");\n\nconst AsyncDependenciesBlock = require(\"./AsyncDependenciesBlock\");\n\nconst Template = require(\"./Template\");\n\nconst contextify = require(\"./util/identifier\").contextify;\n/** @typedef {\"sync\" | \"eager\" | \"weak\" | \"async-weak\" | \"lazy\" | \"lazy-once\"} ContextMode Context mode */\n\n/** @typedef {import(\"./dependencies/ContextElementDependency\")} ContextElementDependency */\n\n/**\n * @callback ResolveDependenciesCallback\n * @param {Error=} err\n * @param {ContextElementDependency[]} dependencies\n */\n\n/**\n * @callback ResolveDependencies\n * @param {TODO} fs\n * @param {TODO} options\n * @param {ResolveDependenciesCallback} callback\n */\n\n\nclass ContextModule extends Module {\n  // type ContextMode = \"sync\" | \"eager\" | \"weak\" | \"async-weak\" | \"lazy\" | \"lazy-once\"\n  // type ContextOptions = { resource: string, recursive: boolean, regExp: RegExp, addon?: string, mode?: ContextMode, chunkName?: string, include?: RegExp, exclude?: RegExp, groupOptions?: Object }\n  // resolveDependencies: (fs: FS, options: ContextOptions, (err: Error?, dependencies: Dependency[]) => void) => void\n  // options: ContextOptions\n\n  /**\n   * @param {ResolveDependencies} resolveDependencies function to get dependencies in this context\n   * @param {TODO} options options object\n   */\n  constructor(resolveDependencies, options) {\n    let resource;\n    let resourceQuery;\n    const queryIdx = options.resource.indexOf(\"?\");\n\n    if (queryIdx >= 0) {\n      resource = options.resource.substr(0, queryIdx);\n      resourceQuery = options.resource.substr(queryIdx);\n    } else {\n      resource = options.resource;\n      resourceQuery = \"\";\n    }\n\n    super(\"javascript/dynamic\", resource); // Info from Factory\n\n    this.resolveDependencies = resolveDependencies;\n    this.options = Object.assign({}, options, {\n      resource: resource,\n      resourceQuery: resourceQuery\n    });\n\n    if (options.resolveOptions !== undefined) {\n      this.resolveOptions = options.resolveOptions;\n    } // Info from Build\n\n\n    this._contextDependencies = new Set([this.context]);\n\n    if (typeof options.mode !== \"string\") {\n      throw new Error(\"options.mode is a required option\");\n    }\n\n    this._identifier = this._createIdentifier();\n  }\n\n  updateCacheModule(module) {\n    this.resolveDependencies = module.resolveDependencies;\n    this.options = module.options;\n    this.resolveOptions = module.resolveOptions;\n  }\n\n  prettyRegExp(regexString) {\n    // remove the \"/\" at the front and the beginning\n    // \"/foo/\" -> \"foo\"\n    return regexString.substring(1, regexString.length - 1);\n  }\n\n  _createIdentifier() {\n    let identifier = this.context;\n\n    if (this.options.resourceQuery) {\n      identifier += \" \".concat(this.options.resourceQuery);\n    }\n\n    if (this.options.mode) {\n      identifier += \" \".concat(this.options.mode);\n    }\n\n    if (!this.options.recursive) {\n      identifier += \" nonrecursive\";\n    }\n\n    if (this.options.addon) {\n      identifier += \" \".concat(this.options.addon);\n    }\n\n    if (this.options.regExp) {\n      identifier += \" \".concat(this.options.regExp);\n    }\n\n    if (this.options.include) {\n      identifier += \" include: \".concat(this.options.include);\n    }\n\n    if (this.options.exclude) {\n      identifier += \" exclude: \".concat(this.options.exclude);\n    }\n\n    if (this.options.groupOptions) {\n      identifier += \" groupOptions: \".concat(JSON.stringify(this.options.groupOptions));\n    }\n\n    if (this.options.namespaceObject === \"strict\") {\n      identifier += \" strict namespace object\";\n    } else if (this.options.namespaceObject) {\n      identifier += \" namespace object\";\n    }\n\n    return identifier;\n  }\n\n  identifier() {\n    return this._identifier;\n  }\n\n  readableIdentifier(requestShortener) {\n    let identifier = requestShortener.shorten(this.context);\n\n    if (this.options.resourceQuery) {\n      identifier += \" \".concat(this.options.resourceQuery);\n    }\n\n    if (this.options.mode) {\n      identifier += \" \".concat(this.options.mode);\n    }\n\n    if (!this.options.recursive) {\n      identifier += \" nonrecursive\";\n    }\n\n    if (this.options.addon) {\n      identifier += \" \".concat(requestShortener.shorten(this.options.addon));\n    }\n\n    if (this.options.regExp) {\n      identifier += \" \".concat(this.prettyRegExp(this.options.regExp + \"\"));\n    }\n\n    if (this.options.include) {\n      identifier += \" include: \".concat(this.prettyRegExp(this.options.include + \"\"));\n    }\n\n    if (this.options.exclude) {\n      identifier += \" exclude: \".concat(this.prettyRegExp(this.options.exclude + \"\"));\n    }\n\n    if (this.options.groupOptions) {\n      const groupOptions = this.options.groupOptions;\n\n      for (const key of Object.keys(groupOptions)) {\n        identifier += \" \".concat(key, \": \").concat(groupOptions[key]);\n      }\n    }\n\n    if (this.options.namespaceObject === \"strict\") {\n      identifier += \" strict namespace object\";\n    } else if (this.options.namespaceObject) {\n      identifier += \" namespace object\";\n    }\n\n    return identifier;\n  }\n\n  libIdent(options) {\n    let identifier = contextify(options.context, this.context);\n\n    if (this.options.mode) {\n      identifier += \" \".concat(this.options.mode);\n    }\n\n    if (this.options.recursive) {\n      identifier += \" recursive\";\n    }\n\n    if (this.options.addon) {\n      identifier += \" \".concat(contextify(options.context, this.options.addon));\n    }\n\n    if (this.options.regExp) {\n      identifier += \" \".concat(this.prettyRegExp(this.options.regExp + \"\"));\n    }\n\n    if (this.options.include) {\n      identifier += \" include: \".concat(this.prettyRegExp(this.options.include + \"\"));\n    }\n\n    if (this.options.exclude) {\n      identifier += \" exclude: \".concat(this.prettyRegExp(this.options.exclude + \"\"));\n    }\n\n    return identifier;\n  }\n\n  needRebuild(fileTimestamps, contextTimestamps) {\n    const ts = contextTimestamps.get(this.context);\n\n    if (!ts) {\n      return true;\n    }\n\n    return ts >= this.buildInfo.builtTime;\n  }\n\n  build(options, compilation, resolver, fs, callback) {\n    this.built = true;\n    this.buildMeta = {};\n    this.buildInfo = {\n      builtTime: Date.now(),\n      contextDependencies: this._contextDependencies\n    };\n    this.resolveDependencies(fs, this.options, (err, dependencies) => {\n      if (err) return callback(err); // abort if something failed\n      // this will create an empty context\n\n      if (!dependencies) {\n        callback();\n        return;\n      } // enhance dependencies with meta info\n\n\n      for (const dep of dependencies) {\n        dep.loc = {\n          name: dep.userRequest\n        };\n        dep.request = this.options.addon + dep.request;\n      }\n\n      if (this.options.mode === \"sync\" || this.options.mode === \"eager\") {\n        // if we have an sync or eager context\n        // just add all dependencies and continue\n        this.dependencies = dependencies;\n      } else if (this.options.mode === \"lazy-once\") {\n        // for the lazy-once mode create a new async dependency block\n        // and add that block to this context\n        if (dependencies.length > 0) {\n          const block = new AsyncDependenciesBlock(Object.assign({}, this.options.groupOptions, {\n            name: this.options.chunkName\n          }), this);\n\n          for (const dep of dependencies) {\n            block.addDependency(dep);\n          }\n\n          this.addBlock(block);\n        }\n      } else if (this.options.mode === \"weak\" || this.options.mode === \"async-weak\") {\n        // we mark all dependencies as weak\n        for (const dep of dependencies) {\n          dep.weak = true;\n        }\n\n        this.dependencies = dependencies;\n      } else if (this.options.mode === \"lazy\") {\n        // if we are lazy create a new async dependency block per dependency\n        // and add all blocks to this context\n        let index = 0;\n\n        for (const dep of dependencies) {\n          let chunkName = this.options.chunkName;\n\n          if (chunkName) {\n            if (!/\\[(index|request)\\]/.test(chunkName)) {\n              chunkName += \"[index]\";\n            }\n\n            chunkName = chunkName.replace(/\\[index\\]/g, index++);\n            chunkName = chunkName.replace(/\\[request\\]/g, Template.toPath(dep.userRequest));\n          }\n\n          const block = new AsyncDependenciesBlock(Object.assign({}, this.options.groupOptions, {\n            name: chunkName\n          }), dep.module, dep.loc, dep.userRequest);\n          block.addDependency(dep);\n          this.addBlock(block);\n        }\n      } else {\n        callback(new Error(\"Unsupported mode \\\"\".concat(this.options.mode, \"\\\" in context\")));\n        return;\n      }\n\n      callback();\n    });\n  }\n\n  getUserRequestMap(dependencies) {\n    // if we filter first we get a new array\n    // therefor we dont need to create a clone of dependencies explicitly\n    // therefore the order of this is !important!\n    return dependencies.filter(dependency => dependency.module).sort((a, b) => {\n      if (a.userRequest === b.userRequest) {\n        return 0;\n      }\n\n      return a.userRequest < b.userRequest ? -1 : 1;\n    }).reduce((map, dep) => {\n      map[dep.userRequest] = dep.module.id;\n      return map;\n    }, Object.create(null));\n  }\n\n  getFakeMap(dependencies) {\n    if (!this.options.namespaceObject) {\n      return 9;\n    } // if we filter first we get a new array\n    // therefor we dont need to create a clone of dependencies explicitly\n    // therefore the order of this is !important!\n\n\n    let hasNonHarmony = false;\n    let hasNamespace = false;\n    let hasNamed = false;\n    const fakeMap = dependencies.filter(dependency => dependency.module).sort((a, b) => {\n      return b.module.id - a.module.id;\n    }).reduce((map, dep) => {\n      const exportsType = dep.module.buildMeta && dep.module.buildMeta.exportsType;\n      const id = dep.module.id;\n\n      if (!exportsType) {\n        map[id] = this.options.namespaceObject === \"strict\" ? 1 : 7;\n        hasNonHarmony = true;\n      } else if (exportsType === \"namespace\") {\n        map[id] = 9;\n        hasNamespace = true;\n      } else if (exportsType === \"named\") {\n        map[id] = 3;\n        hasNamed = true;\n      }\n\n      return map;\n    }, Object.create(null));\n\n    if (!hasNamespace && hasNonHarmony && !hasNamed) {\n      return this.options.namespaceObject === \"strict\" ? 1 : 7;\n    }\n\n    if (hasNamespace && !hasNonHarmony && !hasNamed) {\n      return 9;\n    }\n\n    if (!hasNamespace && !hasNonHarmony && hasNamed) {\n      return 3;\n    }\n\n    if (!hasNamespace && !hasNonHarmony && !hasNamed) {\n      return 9;\n    }\n\n    return fakeMap;\n  }\n\n  getFakeMapInitStatement(fakeMap) {\n    return typeof fakeMap === \"object\" ? \"var fakeMap = \".concat(JSON.stringify(fakeMap, null, \"\\t\"), \";\") : \"\";\n  }\n\n  getReturn(type) {\n    if (type === 9) {\n      return \"__webpack_require__(id)\";\n    }\n\n    return \"__webpack_require__.t(id, \".concat(type, \")\");\n  }\n\n  getReturnModuleObjectSource(fakeMap, fakeMapDataExpression = \"fakeMap[id]\") {\n    if (typeof fakeMap === \"number\") {\n      return \"return \".concat(this.getReturn(fakeMap), \";\");\n    }\n\n    return \"return __webpack_require__.t(id, \".concat(fakeMapDataExpression, \")\");\n  }\n\n  getSyncSource(dependencies, id) {\n    const map = this.getUserRequestMap(dependencies);\n    const fakeMap = this.getFakeMap(dependencies);\n    const returnModuleObject = this.getReturnModuleObjectSource(fakeMap);\n    return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\t\").concat(returnModuleObject, \"\\n}\\nfunction webpackContextResolve(req) {\\n\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn map[req];\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nmodule.exports = webpackContext;\\nwebpackContext.id = \").concat(JSON.stringify(id), \";\");\n  }\n\n  getWeakSyncSource(dependencies, id) {\n    const map = this.getUserRequestMap(dependencies);\n    const fakeMap = this.getFakeMap(dependencies);\n    const returnModuleObject = this.getReturnModuleObjectSource(fakeMap);\n    return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\tif(!__webpack_require__.m[id]) {\\n\\t\\tvar e = new Error(\\\"Module '\\\" + req + \\\"' ('\\\" + id + \\\"') is not available (weak dependency)\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\t\").concat(returnModuleObject, \"\\n}\\nfunction webpackContextResolve(req) {\\n\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn map[req];\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nwebpackContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackContext;\");\n  }\n\n  getAsyncWeakSource(dependencies, id) {\n    const map = this.getUserRequestMap(dependencies);\n    const fakeMap = this.getFakeMap(dependencies);\n    const returnModuleObject = this.getReturnModuleObjectSource(fakeMap);\n    return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackAsyncContext(req) {\\n\\treturn webpackAsyncContextResolve(req).then(function(id) {\\n\\t\\tif(!__webpack_require__.m[id]) {\\n\\t\\t\\tvar e = new Error(\\\"Module '\\\" + req + \\\"' ('\\\" + id + \\\"') is not available (weak dependency)\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\t\").concat(returnModuleObject, \"\\n\\t});\\n}\\nfunction webpackAsyncContextResolve(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn map[req];\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n  }\n\n  getEagerSource(dependencies, id) {\n    const map = this.getUserRequestMap(dependencies);\n    const fakeMap = this.getFakeMap(dependencies);\n    const thenFunction = fakeMap !== 9 ? \"function(id) {\\n\\t\\t\".concat(this.getReturnModuleObjectSource(fakeMap), \"\\n\\t}\") : \"__webpack_require__\";\n    return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackAsyncContext(req) {\\n\\treturn webpackAsyncContextResolve(req).then(\").concat(thenFunction, \");\\n}\\nfunction webpackAsyncContextResolve(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn map[req];\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n  }\n\n  getLazyOnceSource(block, dependencies, id, runtimeTemplate) {\n    const promise = runtimeTemplate.blockPromise({\n      block,\n      message: \"lazy-once context\"\n    });\n    const map = this.getUserRequestMap(dependencies);\n    const fakeMap = this.getFakeMap(dependencies);\n    const thenFunction = fakeMap !== 9 ? \"function(id) {\\n\\t\\t\".concat(this.getReturnModuleObjectSource(fakeMap), \";\\n\\t}\") : \"__webpack_require__\";\n    return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackAsyncContext(req) {\\n\\treturn webpackAsyncContextResolve(req).then(\").concat(thenFunction, \");\\n}\\nfunction webpackAsyncContextResolve(req) {\\n\\treturn \").concat(promise, \".then(function() {\\n\\t\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn map[req];\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n  }\n\n  getLazySource(blocks, id) {\n    let hasMultipleOrNoChunks = false;\n    let hasNoChunk = true;\n    const fakeMap = this.getFakeMap(blocks.map(b => b.dependencies[0]));\n    const hasFakeMap = typeof fakeMap === \"object\";\n    const map = blocks.filter(block => block.dependencies[0].module).map(block => {\n      const chunks = block.chunkGroup ? block.chunkGroup.chunks : [];\n\n      if (chunks.length > 0) {\n        hasNoChunk = false;\n      }\n\n      if (chunks.length !== 1) {\n        hasMultipleOrNoChunks = true;\n      }\n\n      return {\n        dependency: block.dependencies[0],\n        block: block,\n        userRequest: block.dependencies[0].userRequest,\n        chunks\n      };\n    }).sort((a, b) => {\n      if (a.userRequest === b.userRequest) return 0;\n      return a.userRequest < b.userRequest ? -1 : 1;\n    }).reduce((map, item) => {\n      const chunks = item.chunks;\n\n      if (hasNoChunk && !hasFakeMap) {\n        map[item.userRequest] = item.dependency.module.id;\n      } else {\n        const arrayStart = [item.dependency.module.id];\n\n        if (typeof fakeMap === \"object\") {\n          arrayStart.push(fakeMap[item.dependency.module.id]);\n        }\n\n        map[item.userRequest] = arrayStart.concat(chunks.map(chunk => chunk.id));\n      }\n\n      return map;\n    }, Object.create(null));\n    const shortMode = hasNoChunk && !hasFakeMap;\n    const chunksStartPosition = hasFakeMap ? 2 : 1;\n    const requestPrefix = hasNoChunk ? \"Promise.resolve()\" : hasMultipleOrNoChunks ? \"Promise.all(ids.slice(\".concat(chunksStartPosition, \").map(__webpack_require__.e))\") : \"__webpack_require__.e(ids[\".concat(chunksStartPosition, \"])\");\n    const returnModuleObject = this.getReturnModuleObjectSource(fakeMap, shortMode ? \"invalid\" : \"ids[1]\");\n    const webpackAsyncContext = requestPrefix === \"Promise.resolve()\" ? \"\".concat(shortMode ? \"\" : \"\", \"\\nfunction webpackAsyncContext(req) {\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\n\\t\\t\").concat(shortMode ? \"var id = map[req];\" : \"var ids = map[req], id = ids[0];\", \"\\n\\t\\t\").concat(returnModuleObject, \"\\n\\t});\\n}\") : \"function webpackAsyncContext(req) {\\n\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\treturn Promise.resolve().then(function() {\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t});\\n\\t}\\n\\n\\tvar ids = map[req], id = ids[0];\\n\\treturn \".concat(requestPrefix, \".then(function() {\\n\\t\\t\").concat(returnModuleObject, \"\\n\\t});\\n}\");\n    return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(webpackAsyncContext, \"\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n  }\n\n  getSourceForEmptyContext(id) {\n    return \"function webpackEmptyContext(req) {\\n\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\te.code = 'MODULE_NOT_FOUND';\\n\\tthrow e;\\n}\\nwebpackEmptyContext.keys = function() { return []; };\\nwebpackEmptyContext.resolve = webpackEmptyContext;\\nmodule.exports = webpackEmptyContext;\\nwebpackEmptyContext.id = \".concat(JSON.stringify(id), \";\");\n  }\n\n  getSourceForEmptyAsyncContext(id) {\n    return \"function webpackEmptyAsyncContext(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t});\\n}\\nwebpackEmptyAsyncContext.keys = function() { return []; };\\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\\nmodule.exports = webpackEmptyAsyncContext;\\nwebpackEmptyAsyncContext.id = \".concat(JSON.stringify(id), \";\");\n  }\n\n  getSourceString(asyncMode, runtimeTemplate) {\n    if (asyncMode === \"lazy\") {\n      if (this.blocks && this.blocks.length > 0) {\n        return this.getLazySource(this.blocks, this.id);\n      }\n\n      return this.getSourceForEmptyAsyncContext(this.id);\n    }\n\n    if (asyncMode === \"eager\") {\n      if (this.dependencies && this.dependencies.length > 0) {\n        return this.getEagerSource(this.dependencies, this.id);\n      }\n\n      return this.getSourceForEmptyAsyncContext(this.id);\n    }\n\n    if (asyncMode === \"lazy-once\") {\n      const block = this.blocks[0];\n\n      if (block) {\n        return this.getLazyOnceSource(block, block.dependencies, this.id, runtimeTemplate);\n      }\n\n      return this.getSourceForEmptyAsyncContext(this.id);\n    }\n\n    if (asyncMode === \"async-weak\") {\n      if (this.dependencies && this.dependencies.length > 0) {\n        return this.getAsyncWeakSource(this.dependencies, this.id);\n      }\n\n      return this.getSourceForEmptyAsyncContext(this.id);\n    }\n\n    if (asyncMode === \"weak\") {\n      if (this.dependencies && this.dependencies.length > 0) {\n        return this.getWeakSyncSource(this.dependencies, this.id);\n      }\n    }\n\n    if (this.dependencies && this.dependencies.length > 0) {\n      return this.getSyncSource(this.dependencies, this.id);\n    }\n\n    return this.getSourceForEmptyContext(this.id);\n  }\n\n  getSource(sourceString) {\n    if (this.useSourceMap) {\n      return new OriginalSource(sourceString, this.identifier());\n    }\n\n    return new RawSource(sourceString);\n  }\n\n  source(dependencyTemplates, runtimeTemplate) {\n    return this.getSource(this.getSourceString(this.options.mode, runtimeTemplate));\n  }\n\n  size() {\n    // base penalty\n    const initialSize = 160; // if we dont have dependencies we stop here.\n\n    return this.dependencies.reduce((size, dependency) => {\n      const element =\n      /** @type {ContextElementDependency} */\n      dependency;\n      return size + 5 + element.userRequest.length;\n    }, initialSize);\n  }\n\n} // TODO remove in webpack 5\n\n\nObject.defineProperty(ContextModule.prototype, \"recursive\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {boolean} is recursive\n   */\n  function () {\n    return this.options.recursive;\n  }, \"ContextModule.recursive has been moved to ContextModule.options.recursive\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {boolean} value is recursive\n   * @returns {void}\n   */\n  function (value) {\n    this.options.recursive = value;\n  }, \"ContextModule.recursive has been moved to ContextModule.options.recursive\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(ContextModule.prototype, \"regExp\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {RegExp} regular expression\n   */\n  function () {\n    return this.options.regExp;\n  }, \"ContextModule.regExp has been moved to ContextModule.options.regExp\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {RegExp} value Regular expression\n   * @returns {void}\n   */\n  function (value) {\n    this.options.regExp = value;\n  }, \"ContextModule.regExp has been moved to ContextModule.options.regExp\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(ContextModule.prototype, \"addon\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {string} addon\n   */\n  function () {\n    return this.options.addon;\n  }, \"ContextModule.addon has been moved to ContextModule.options.addon\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {string} value addon\n   * @returns {void}\n   */\n  function (value) {\n    this.options.addon = value;\n  }, \"ContextModule.addon has been moved to ContextModule.options.addon\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(ContextModule.prototype, \"async\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {boolean} is async\n   */\n  function () {\n    return this.options.mode;\n  }, \"ContextModule.async has been moved to ContextModule.options.mode\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {ContextMode} value Context mode\n   * @returns {void}\n   */\n  function (value) {\n    this.options.mode = value;\n  }, \"ContextModule.async has been moved to ContextModule.options.mode\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(ContextModule.prototype, \"chunkName\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {string} chunk name\n   */\n  function () {\n    return this.options.chunkName;\n  }, \"ContextModule.chunkName has been moved to ContextModule.options.chunkName\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {string} value chunk name\n   * @returns {void}\n   */\n  function (value) {\n    this.options.chunkName = value;\n  }, \"ContextModule.chunkName has been moved to ContextModule.options.chunkName\")\n});\nmodule.exports = ContextModule;","map":null,"metadata":{},"sourceType":"script"}