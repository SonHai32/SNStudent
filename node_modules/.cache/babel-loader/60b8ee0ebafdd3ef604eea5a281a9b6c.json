{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\n\nconst schema = require(\"../../schemas/plugins/optimize/MinChunkSizePlugin.json\");\n/** @typedef {import(\"../../declarations/plugins/optimize/MinChunkSizePlugin\").MinChunkSizePluginOptions} MinChunkSizePluginOptions */\n\n\nclass MinChunkSizePlugin {\n  /**\n   * @param {MinChunkSizePluginOptions} options options object\n   */\n  constructor(options) {\n    validateOptions(schema, options, \"Min Chunk Size Plugin\");\n    this.options = options;\n  }\n\n  apply(compiler) {\n    const options = this.options;\n    const minChunkSize = options.minChunkSize;\n    compiler.hooks.compilation.tap(\"MinChunkSizePlugin\", compilation => {\n      compilation.hooks.optimizeChunksAdvanced.tap(\"MinChunkSizePlugin\", chunks => {\n        const equalOptions = {\n          chunkOverhead: 1,\n          entryChunkMultiplicator: 1\n        };\n        const sortedSizeFilteredExtendedPairCombinations = chunks.reduce((combinations, a, idx) => {\n          // create combination pairs\n          for (let i = 0; i < idx; i++) {\n            const b = chunks[i];\n            combinations.push([b, a]);\n          }\n\n          return combinations;\n        }, []).filter(pair => {\n          // check if one of the chunks sizes is smaller than the minChunkSize\n          const p0SmallerThanMinChunkSize = pair[0].size(equalOptions) < minChunkSize;\n          const p1SmallerThanMinChunkSize = pair[1].size(equalOptions) < minChunkSize;\n          return p0SmallerThanMinChunkSize || p1SmallerThanMinChunkSize;\n        }).map(pair => {\n          // extend combination pairs with size and integrated size\n          const a = pair[0].size(options);\n          const b = pair[1].size(options);\n          const ab = pair[0].integratedSize(pair[1], options);\n          return [a + b - ab, ab, pair[0], pair[1]];\n        }).filter(pair => {\n          // filter pairs that do not have an integratedSize\n          // meaning they can NOT be integrated!\n          return pair[1] !== false;\n        }).sort((a, b) => {\n          // sadly javascript does an inplace sort here\n          // sort by size\n          const diff = b[0] - a[0];\n          if (diff !== 0) return diff;\n          return a[1] - b[1];\n        });\n        if (sortedSizeFilteredExtendedPairCombinations.length === 0) return;\n        const pair = sortedSizeFilteredExtendedPairCombinations[0];\n        pair[2].integrate(pair[3], \"min-size\");\n        chunks.splice(chunks.indexOf(pair[3]), 1);\n        return true;\n      });\n    });\n  }\n\n}\n\nmodule.exports = MinChunkSizePlugin;","map":null,"metadata":{},"sourceType":"script"}